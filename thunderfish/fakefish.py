"""
Generate artificial EOD waveforms and fields.

The two main functions are

generate_wavefish()
generate_pulsefish()

for generating EODs of wave-type and pulse_type electric fish, respectively.

The following functions use the two functions to generate waveforms of specific fishes:

generate_alepto(): mimicks the wave-type fish Apteronotus leptorhynchus, 
generate_eigenmannia(): mimicks the wave-type fish Eigenmannia, 

generate_monophasic_pulses(): mimicks a monophasic pulsefish,
generate_biphasic_pulses(): mimicks a biphasic pulsefish,
generate_triphasic_pulses(): mimicks a triphasic pulsefish.

The frequency traces of communication signals are generated by

chirps_frequency() for chirps, and
rises_frequency() for rises.

The returned frequency of these functions can then be directly passed on
to generate_wavefish() for generating a frequency modulated EOD waveform.

The spatial geometry of a fish's electric field is simulated by

efield() .

Electric field potententials can be transformed for nice contour plots via

transform_efield()

and a fish silhouette can be plotted on top with

plot_fishsilhouette() .
"""

import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
from matplotlib.path import Path
from matplotlib.patches import PathPatch


def generate_wavefish(frequency=100.0, samplerate=44100., duration=1., noise_std=0.05,
                      amplitudes=1.0, phases=0.0):
    """
    Generate EOD of a wave-type fish.

    The waveform is constructed by superimposing sinewaves of integral multiples of
    the fundamental frequency - the fundamental and its harmonics.
    The fundamental frequency of the EOD is given by frequency. The amplitude of the
    fundamental is given by the first element in amplitudes. The amplitudes and
    relative phases of higher harmonics are give by optional further elements of
    the amplitudes and phases lists.

    The generated waveform is duration seconds long and is sampled with samplerate Hertz.
    Gaussian white noise with a standard deviation of noise_std is added to the generated
    waveform.

    Parameters
    ----------
    frequency: float or array of floats
        EOD frequency of the fish in Hz. Either fixed number or array for
        time-dependent frequencies.
    samplerate: float
        Sampling rate in Hz.
    duration: float
        Duration of the generated data in seconds. Only used if frequency is float.
    noise_std: float
        Standard deviation of additive Gaussian white noise.
    amplitudes: float or list of floats
        Amplitudes of fundamental and optional harmonics.
    phases: float or list of floats
        Relative phases of fundamental and optional harmonics in radians.

    Returns
    -------
    data: array of floats
        Generated data of a wave-type fish.

    Raises
    ------
    IndexError: amplitudes and phases differ in length.
    """
    
    # compute phase:
    if np.isscalar(frequency):
        phase = np.arange(0, duration, 1./samplerate)
        phase *= frequency
    else:
        phase = np.cumsum(frequency)/samplerate
    # fix amplitudes and phases:
    if np.isscalar(amplitudes):
        amplitudes = [amplitudes]
    if np.isscalar(phases):
        phases = [phases]
    if len(amplitudes) != len(phases):
        raise IndexError('need exactly as many phases as amplitudes')
    # generate EOD:
    data = np.zeros(len(phase))
    for har, (ampl, phi) in enumerate(zip(amplitudes, phases)):
        data += ampl * np.sin(2*np.pi*(har+1)*phase+phi)
    # add noise:
    data += noise_std * np.random.randn(len(data))
    return data


def generate_alepto(frequency=100.0, samplerate=44100., duration=1., noise_std=0.01):
    """Generate EOD of a Apteronotus leptorhynchus.

    See generate_wavefish() for details.
    """
    return generate_wavefish(frequency=frequency, samplerate=samplerate, duration=duration,
                             noise_std=noise_std, amplitudes=[1.0, 0.5, 0.1, 0.01, 0.001],
                             phases=[0.0, 0.0, 0.0, 0.0, 0.0])


def generate_eigenmannia(frequency=100.0, samplerate=44100., duration=1., noise_std=0.01):
    """Generate EOD of an Eigenmannia.

    See generate_wavefish() for details.
    """
    return generate_wavefish(frequency=frequency, samplerate=samplerate, duration=duration,
                             noise_std=noise_std, amplitudes=[1.0, 0.25, 0.0, 0.01],
                             phases=[0.0, -0.48*np.pi, 0.0, 0.0])


def chirps_frequency(eodf=100.0, samplerate=44100., duration=1.,
                     chirp_freq=5.0, chirp_size=100.0, chirp_width=0.01, chirp_kurtosis=1.0):
    """
    Generate frequency trace with chirps.

    A chirp is modeled as a Gaussian frequency modulation.

    Parameters
    ----------
    eodf: float
        EOD frequency of the fish in Hz.
    samplerate: float
        Sampling rate in Hz.
    duration: float
        Duration of the generated data in seconds.
    chirp_freq: float
        Frequency of occurance of chirps in Hertz.
    chirp_size: float
        Size of the chirp (frequency increase above eodf) in Hertz.
    chirp_width: float
        Width of the chirp at 10% height in seconds.
    chirp_kurtosis (float):
        Shape of the chirp. =1: Gaussian, >1: more rectangular, <1: more peaked.

    Returns
    -------
    data: array of floats
        Generated frequency trace that can be passed on to generate_wavefish().
    """

    # baseline eod frequency:
    frequency = eodf * np.ones(int(duration*samplerate))
    # time points for chirps:
    chirp_period = 1.0/chirp_freq
    chirp_times = np.arange(0.5*chirp_period, duration, chirp_period)
    # chirp frequency waveform:
    chirp_t = np.arange(-2.0*chirp_width, 2.0*chirp_width, 1./samplerate)
    chirp_sig = 0.5*chirp_width / (2.0*np.log(10.0))**(0.5/chirp_kurtosis)
    chirp = chirp_size * np.exp(-0.5*((chirp_t/chirp_sig)**2.0)**chirp_kurtosis)
    # add chirps on baseline eodf:
    for c in chirp_times:
        index = int(c*samplerate)
        if index+len(chirp) > len(frequency):
            break
        frequency[index:index+len(chirp)] += chirp
    return frequency


def rises_frequency(eodf=100.0, samplerate=44100., duration=1.,
                    rise_freq=0.1, rise_size=10.0, rise_tau=1.0, decay_tau=10.0):
    """
    Generate frequency trace with rises.

    A rise is modeled as a double exponential frequency modulation.

    Parameters
    ----------
    eodf: float
        EOD frequency of the fish in Hz.
    samplerate: float
        Sampling rate in Hz.
    duration: float
        Duration of the generated data in seconds.
    rise_freq: float
        Frequency of occurance of rises in Hertz.
    rise_size: float
        Size of the rise (frequency increase above eodf) in Hertz.
    rise_tau: float
        Time constant of the frequency increase of the rise in seconds.
    decay_tau: float
        Time constant of the frequency decay of the rise in seconds.

    Returns
    -------
    data: array of floats
        Generated frequency trace that can be passed on to generate_wavefish().
    """

    # baseline eod frequency:
    frequency = eodf * np.ones(int(duration*samplerate))
    # time points for rises:
    rise_period = 1.0/rise_freq
    rise_times = np.arange(0.5*rise_period, duration, rise_period)
    # rise frequency waveform:
    rise_t = np.arange(0.0, 5.0*decay_tau, 1./samplerate)
    rise = rise_size * (1.0-np.exp(-rise_t/rise_tau)) * np.exp(-rise_t/decay_tau)
    # add rises on baseline eodf:
    for r in rise_times:
        index = int(r*samplerate)
        if index+len(rise) > len(frequency):
            rise_index = len(frequency)-index
            frequency[index:index+rise_index] += rise[:rise_index]
            break
        else:
            frequency[index:index+len(rise)] += rise
    return frequency


def generate_pulsefish(frequency=100.0, samplerate=44100., duration=1., noise_std=0.01,
                       jitter_cv=0.1, peak_stds=0.001, peak_amplitudes=1.0, peak_times=0.0):
    """
    Generate EOD of a pulse-type fish.

    Pulses are spaced by 1/frequency, jittered as determined by jitter_cv. Each pulse is
    a combination of Gaussian peaks, whose widths, amplitudes, and positions are given by
    their standard deviation peak_stds, peak_amplitudes, and peak_times, respectively.

    The generated waveform is duration seconds long and is sampled with samplerate Hertz.
    Gaussian white noise with a standard deviation of noise_std is added to the generated
    pulse train.

    Parameters
    ----------
    frequency: float
        EOD frequency of the fish in Hz.
    samplerate: float
        Sampling Rate in Hz.
    duration: float
        Duration of the generated data in seconds.
    noise_std: float
        Standard deviation of additive Gaussian white noise.
    jitter_cv: float
        Gaussian distributed jitter of pulse times as coefficient of variation of inter-pulse intervals.
    peak_stds: float or list of floats
        Standard deviation of Gaussian shaped peaks in seconds.
    peak_amplitudes: float or list of floats
        Amplitude of each peak (positive and negative).
    peak_times: float or list of floats
        Position of each Gaussian peak in seconds.

    Returns
    -------
    data: array of floats
        Generated data of a pulse-type fish.

    Raises
    ------
    IndexError: peak_stds or peak_amplitudes or peak_times differ in length.
    """

    # make sure peak properties are in a list:
    if np.isscalar(peak_stds):
        peak_stds = [peak_stds]
    if np.isscalar(peak_amplitudes):
        peak_amplitudes = [peak_amplitudes]
    if np.isscalar(peak_times):
        peak_times = [peak_times]
    if len(peak_stds) != len(peak_amplitudes) or len(peak_stds) != len(peak_times):
        raise IndexError('need exactly as many peak_stds as peak_amplitudes and peak_times')

    # time axis for single pulse:
    min_time_inx = np.argmin(peak_times)
    max_time_inx = np.argmax(peak_times)
    x = np.arange(-4.*peak_stds[min_time_inx] + peak_times[min_time_inx],
                  4.*peak_stds[max_time_inx] + peak_times[max_time_inx], 1.0/samplerate)
    pulse_duration = x[-1] - x[0]
    
    # generate a single pulse:
    pulse = np.zeros(len(x))
    for time, ampl, std in zip(peak_times, peak_amplitudes, peak_stds):
        pulse += ampl * np.exp(-0.5*((x-time)/std)**2) 

    # paste the pulse into the noise floor:
    time = np.arange(0, duration, 1. / samplerate)
    data = np.random.randn(len(time)) * noise_std
    period = 1.0/frequency
    jitter_std = period * jitter_cv
    first_pulse = np.max([pulse_duration, 3.0*jitter_std])
    pulse_times = np.arange(first_pulse, duration, period )
    pulse_times += np.random.randn(len(pulse_times)) * jitter_std
    pulse_indices = np.round(pulse_times * samplerate).astype(np.int)
    for inx in pulse_indices[(pulse_indices >= 0) & (pulse_indices < len(data)-len(pulse)-1)]:
        data[inx:inx + len(pulse)] += pulse

    return data


def generate_monophasic_pulses(frequency=100.0, samplerate=44100., duration=1.,
                               noise_std=0.01, jitter_cv=0.1):
    """Generate EOD of a monophasic pulse-type fish.

    See generate_pulsefish() for details.
    """
    return generate_pulsefish(frequency=frequency, samplerate=samplerate, duration=duration,
                              noise_std=noise_std, jitter_cv=jitter_cv,
                              peak_stds=0.0003, peak_amplitudes=1.0, peak_times=0.0)


def generate_biphasic_pulses(frequency=100.0, samplerate=44100., duration=1.,
                              noise_std=0.01, jitter_cv=0.1):
    """Generate EOD of a biphasic pulse-type fish.

    See generate_pulsefish() for details.
    """
    return generate_pulsefish(frequency=frequency, samplerate=samplerate, duration=duration,
                              noise_std=noise_std, jitter_cv=jitter_cv,
                              peak_stds=[0.0001, 0.0002],
                              peak_amplitudes=[1.0, -0.3],
                              peak_times=[0.0, 0.0003])


def generate_triphasic_pulses(frequency=100.0, samplerate=44100., duration=1.,
                              noise_std=0.01, jitter_cv=0.1):
    """Generate EOD of a triphasic pulse-type fish.

    See generate_pulsefish() for details.
    """
    return generate_pulsefish(frequency=frequency, samplerate=samplerate, duration=duration,
                              noise_std=noise_std, jitter_cv=jitter_cv,
                              peak_stds=[0.0001, 0.0001, 0.0002],
                              peak_amplitudes=[1.0, -0.8, 0.1],
                              peak_times=[0.0, 0.00015, 0.0004])


def efield(x, y, pos=(0, 0), direction=(1, 0), n=200):
    """ Spatial geometry of the electric field of an electric fish.

    This implements the model published in
    Chen, House, Krahe, Nelson (2005) "Modeling signal and background
    components of electrosensory scenes", J Comp Physiol A 191: 331-345

    The fields of several fish can be simply summed up.

    Parameters
    ----------
    x: array of floats
        1 to 3 dimensional array of x coordinates for which
        the field should be calculated.
    y: array of floats
        1 to 3 dimensional array of y coordinates for which
        the field should be calculated.
    pos: tuple of floats
        Coordinates of the fish's position (its center).
    direction: tuple of floats
        Coordinates of a vector defining the orientation of the fish.
    n: int
        Number of charges (monopoles) to be used.
        They are symmetrically distributed around the position and
        placed every Millimeter.

    Returns
    -------
    pot: array of float
        The potential of the fish at the x and y coordinates.
        Same shape as x or y.
    """
    nneg = 1
    npos = n - nneg
    ppx = 0.1
    pos = np.asarray(pos)
    direction = np.asarray(direction)
    direction /= np.linalg.norm(direction)
    charges = np.ones(n)/npos
    charges[:nneg] = -1/nneg
    poles = np.array([pos+k*ppx*direction for k in range(-n//2, -n//2+n)])
    pot = np.zeros(x.shape)
    for p, c in zip(poles, charges):
        xd = x-p[0]
        yd = y-p[1]
        r = np.concatenate((xd[..., np.newaxis], yd[..., np.newaxis]), axis=-1)
        rnorm = np.linalg.norm(r, axis=-1)
        rnorm[np.abs(rnorm) < 1e-12] = 1.0e-12
        pot += c/rnorm
    return pot


def transform_efield(pot, thresh=1.0):
    """ Transform spatial electric field for plotting.

    Takes the square root of positive potentials.
    Takes the square root of the absolute values of negative potentials
    and negates it.
    Then truncate symmetrically both positive and negative values to
    a threshold.

    The resulting transformed potential gives nice contour lines in a
    contour plot.

    Parameters
    ----------
    pot: array of float
        The potential of the fish.
    thresh: float or None
        Maximum absolute value of the returned potential.
        Must be positive!
        If None, take the smaller of the maximum of the
        positive values or of the absolute negative values. 

    Returns
    -------
    pot: array of float
        The transformed potential of the fish.
    """
    sel = pot>=0.0
    pot[sel] = pot[sel]**0.5
    pot[np.logical_not(sel)] = -((-pot[np.logical_not(sel)])**0.5)
    if thresh is None:
        thresh = min(np.max(pot), -np.min(pot))
    pot[pot>thresh] = thresh
    pot[pot<-thresh] = -thresh
    return pot


def plot_fishsilhouette(ax, pos, direction, size, **kwargs):
    """ Plot silhouette of an electric fish.

    Modified from Krahe 2004.

    Parameters
    ----------
    ax: matplotlib axes
        Axes where to draw the fish.
    pos: tuple of floats
        Coordinates of the fish's position (its center).
    direction: tuple of floats
        Coordinates of a vector defining the orientation of the fish.
    size: float
        Size of the fish. In conjunction with efiled() set it to `0.1*n`.
    kwargs: key word arguments
        Arguments for PathPatch used to draw the fish.
    """
    fish_shape = np.array([[6.04666013e-05, -5.50000000e-01],
                           [6.42715728e-04, -5.49747073e-01],
                           [8.26843903e-04, -5.49839247e-01],
                           [1.66158533e-03, -5.49732325e-01],
                           [2.18130315e-03, -5.49159367e-01],
                           [2.88750881e-03, -5.48397340e-01],
                           [3.80040701e-03, -5.45997553e-01],
                           [4.00709955e-03, -5.44359867e-01],
                           [4.44068932e-03, -5.39635730e-01],
                           [4.92235742e-03, -5.33699237e-01],
                           [5.42644240e-03, -5.27232555e-01],
                           [5.44635214e-03, -5.16662845e-01],
                           [5.27748809e-03, -4.95525676e-01],
                           [5.52230409e-03, -4.63826259e-01],
                           [5.52230409e-03, -4.00225718e-01],
                           [5.68600635e-03, -3.95986471e-01],
                           [6.02012119e-03, -3.87508242e-01],
                           [6.52420617e-03, -3.74791017e-01],
                           [7.02829116e-03, -3.62088186e-01],
                           [7.20806869e-03, -3.57844589e-01],
                           [7.55685774e-03, -3.49356966e-01],
                           [8.07539572e-03, -3.36625339e-01],
                           [8.21830337e-03, -3.32380451e-01],
                           [8.54320074e-03, -3.23892275e-01],
                           [9.04728572e-03, -3.11160641e-01],
                           [9.23288869e-03, -3.06999241e-01],
                           [9.56951069e-03, -2.98675129e-01],
                           [1.00592164e-02, -2.86188341e-01],
                           [1.03128074e-02, -2.76649491e-01],
                           [1.08224966e-02, -2.67004478e-01],
                           [1.09025043e-02, -2.62753683e-01],
                           [1.13414033e-02, -2.54271724e-01],
                           [1.21191365e-02, -2.41554499e-01],
                           [1.21877145e-02, -2.37303984e-01],
                           [1.26064826e-02, -2.28822172e-01],
                           [1.33553836e-02, -2.16104947e-01],
                           [1.37980434e-02, -2.11871459e-01],
                           [1.43909847e-02, -2.03389927e-01],
                           [1.51543387e-02, -1.90658293e-01],
                           [1.55977359e-02, -1.86429672e-01],
                           [1.61908985e-02, -1.77957770e-01],
                           [1.69542525e-02, -1.65240545e-01],
                           [1.73200754e-02, -1.61003466e-01],
                           [1.80128604e-02, -1.52526218e-01],
                           [1.90354096e-02, -1.39808986e-01],
                           [1.96383059e-02, -1.33495218e-01],
                           [2.06382686e-02, -1.20861636e-01],
                           [2.19056781e-02, -1.01893816e-01],
                           [2.22560157e-02, -9.76558669e-02],
                           [2.29344214e-02, -8.91782208e-02],
                           [2.39425914e-02, -7.64609885e-02],
                           [2.42920441e-02, -7.22181724e-02],
                           [2.49700812e-02, -6.37308959e-02],
                           [2.59782512e-02, -5.09992696e-02],
                           [2.64230494e-02, -4.67707369e-02],
                           [2.70165807e-02, -3.82988720e-02],
                           [2.77799347e-02, -2.55816470e-02],
                           [2.79653902e-02, -2.13480558e-02],
                           [2.83091649e-02, -1.28798189e-02],
                           [2.88132499e-02, -1.76987954e-04],
                           [2.95765670e-02, 1.88052406e-02],
                           [2.97267011e-02, 2.30402402e-02],
                           [3.00543269e-02, 3.15091113e-02],
                           [3.05584119e-02, 4.42119349e-02],
                           [3.10018090e-02, 4.84501864e-02],
                           [3.15949716e-02, 5.69413048e-02],
                           [3.23583256e-02, 6.96873325e-02],
                           [3.25381031e-02, 7.39213293e-02],
                           [3.28868922e-02, 8.23897579e-02],
                           [3.34054302e-02, 9.50925889e-02],
                           [3.35699436e-02, 9.93318064e-02],
                           [3.39044271e-02, 1.07810020e-01],
                           [3.44085121e-02, 1.20527245e-01],
                           [3.48203486e-02, 1.24791992e-01],
                           [3.59216077e-02, 1.33280175e-01],
                           [3.76930874e-02, 1.45997400e-01],
                           [3.89074484e-02, 1.50167605e-01],
                           [4.07642598e-02, 1.58606788e-01],
                           [4.32990640e-02, 1.71324020e-01],
                           [4.40315210e-02, 1.75541853e-01],
                           [4.48739903e-02, 1.84008969e-01],
                           [4.58677515e-02, 1.96740596e-01],
                           [4.59653830e-02, 2.00913138e-01],
                           [4.64028810e-02, 2.09241181e-01],
                           [4.71662349e-02, 2.21727976e-01],
                           [4.74255039e-02, 2.28180205e-01],
                           [4.79439682e-02, 2.40926233e-01],
                           [4.79439682e-02, 2.47176835e-01],
                           [4.75522626e-02, 2.58534756e-01],
                           [4.74254302e-02, 2.59894060e-01],
                           [4.85784250e-02, 2.59197883e-01],
                           [5.66178874e-02, 2.54859795e-01],
                           [6.51208631e-02, 2.51283188e-01],
                           [7.49345040e-02, 2.48369214e-01],
                           [8.03778844e-02, 2.47176857e-01],
                           [7.71534513e-02, 2.50621027e-01],
                           [6.84992943e-02, 2.59362485e-01],
                           [5.56936701e-02, 2.68767040e-01],
                           [4.88547279e-02, 2.72093831e-01],
                           [4.71661907e-02, 2.72611337e-01],
                           [4.71551297e-02, 2.74205885e-01],
                           [4.74252385e-02, 2.79077967e-01],
                           [5.09682052e-02, 2.85328569e-01],
                           [5.02192821e-02, 2.91795199e-01],
                           [4.94559650e-02, 2.98031393e-01],
                           [4.86926406e-02, 3.04498023e-01],
                           [4.82070642e-02, 3.08667947e-01],
                           [4.71999414e-02, 3.17003357e-01],
                           [4.56732998e-02, 3.29504553e-01],
                           [4.50490928e-02, 3.33751292e-01],
                           [4.37272929e-02, 3.42232913e-01],
                           [4.17109677e-02, 3.54950138e-01],
                           [4.11432453e-02, 3.59229330e-01],
                           [3.97154813e-02, 3.67731686e-01],
                           [3.74399167e-02, 3.80463313e-01],
                           [3.67805357e-02, 3.84705192e-01],
                           [3.54349105e-02, 3.93184645e-01],
                           [3.34041913e-02, 4.05901877e-01],
                           [3.28453177e-02, 4.10174440e-01],
                           [3.14146853e-02, 4.18658715e-01],
                           [2.91247193e-02, 4.31361539e-01],
                           [2.73532396e-02, 4.37842570e-01],
                           [2.42999490e-02, 4.44107574e-01],
                           [2.00166204e-02, 4.48504440e-01],
                           [1.68376625e-02, 4.50000000e-01],
                           [-1.68376625e-02, 4.50000000e-01],
                           [-2.00166204e-02, 4.48504440e-01],
                           [-2.42999490e-02, 4.44107574e-01],
                           [-2.73532396e-02, 4.37842570e-01],
                           [-2.91247193e-02, 4.31361539e-01],
                           [-3.14146853e-02, 4.18658715e-01],
                           [-3.28453177e-02, 4.10174440e-01],
                           [-3.34041913e-02, 4.05901877e-01],
                           [-3.54349105e-02, 3.93184645e-01],
                           [-3.67805357e-02, 3.84705192e-01],
                           [-3.74399167e-02, 3.80463313e-01],
                           [-3.97154813e-02, 3.67731686e-01],
                           [-4.11432453e-02, 3.59229330e-01],
                           [-4.17109677e-02, 3.54950138e-01],
                           [-4.37272929e-02, 3.42232913e-01],
                           [-4.50490928e-02, 3.33751292e-01],
                           [-4.56732998e-02, 3.29504553e-01],
                           [-4.71999414e-02, 3.17003357e-01],
                           [-4.82070642e-02, 3.08667947e-01],
                           [-4.86926406e-02, 3.04498023e-01],
                           [-4.94559650e-02, 2.98031393e-01],
                           [-5.02192821e-02, 2.91795199e-01],
                           [-5.09682052e-02, 2.85328569e-01],
                           [-4.74252385e-02, 2.79077967e-01],
                           [-4.71551297e-02, 2.74205885e-01],
                           [-4.71661907e-02, 2.72611337e-01],
                           [-4.88547279e-02, 2.72093831e-01],
                           [-5.56936701e-02, 2.68767040e-01],
                           [-6.84992943e-02, 2.59362485e-01],
                           [-7.71534513e-02, 2.50621027e-01],
                           [-8.03778844e-02, 2.47176857e-01],
                           [-7.49345040e-02, 2.48369214e-01],
                           [-6.51208631e-02, 2.51283188e-01],
                           [-5.66178874e-02, 2.54859795e-01],
                           [-4.85784250e-02, 2.59197883e-01],
                           [-4.74254302e-02, 2.59894060e-01],
                           [-4.75522626e-02, 2.58534756e-01],
                           [-4.79439682e-02, 2.47176835e-01],
                           [-4.79439682e-02, 2.40926233e-01],
                           [-4.74255039e-02, 2.28180205e-01],
                           [-4.71662349e-02, 2.21727976e-01],
                           [-4.64028810e-02, 2.09241181e-01],
                           [-4.59653830e-02, 2.00913138e-01],
                           [-4.58677515e-02, 1.96740596e-01],
                           [-4.48739903e-02, 1.84008969e-01],
                           [-4.40315210e-02, 1.75541853e-01],
                           [-4.32990640e-02, 1.71324020e-01],
                           [-4.07642598e-02, 1.58606788e-01],
                           [-3.89074484e-02, 1.50167605e-01],
                           [-3.76930874e-02, 1.45997400e-01],
                           [-3.59216077e-02, 1.33280175e-01],
                           [-3.48203486e-02, 1.24791992e-01],
                           [-3.44085121e-02, 1.20527245e-01],
                           [-3.39044271e-02, 1.07810020e-01],
                           [-3.35699436e-02, 9.93318064e-02],
                           [-3.34054302e-02, 9.50925889e-02],
                           [-3.28868922e-02, 8.23897579e-02],
                           [-3.25381031e-02, 7.39213293e-02],
                           [-3.23583256e-02, 6.96873325e-02],
                           [-3.15949716e-02, 5.69413048e-02],
                           [-3.10018090e-02, 4.84501864e-02],
                           [-3.05584119e-02, 4.42119349e-02],
                           [-3.00543269e-02, 3.15091113e-02],
                           [-2.97267011e-02, 2.30402402e-02],
                           [-2.95765670e-02, 1.88052406e-02],
                           [-2.88132499e-02, -1.76987954e-04],
                           [-2.83091649e-02, -1.28798189e-02],
                           [-2.79653902e-02, -2.13480558e-02],
                           [-2.77799347e-02, -2.55816470e-02],
                           [-2.70165807e-02, -3.82988720e-02],
                           [-2.64230494e-02, -4.67707369e-02],
                           [-2.59782512e-02, -5.09992696e-02],
                           [-2.49700812e-02, -6.37308959e-02],
                           [-2.42920441e-02, -7.22181724e-02],
                           [-2.39425914e-02, -7.64609885e-02],
                           [-2.29344214e-02, -8.91782208e-02],
                           [-2.22560157e-02, -9.76558669e-02],
                           [-2.19056781e-02, -1.01893816e-01],
                           [-2.06382686e-02, -1.20861636e-01],
                           [-1.96383059e-02, -1.33495218e-01],
                           [-1.90354096e-02, -1.39808986e-01],
                           [-1.80128604e-02, -1.52526218e-01],
                           [-1.73200754e-02, -1.61003466e-01],
                           [-1.69542525e-02, -1.65240545e-01],
                           [-1.61908985e-02, -1.77957770e-01],
                           [-1.55977359e-02, -1.86429672e-01],
                           [-1.51543387e-02, -1.90658293e-01],
                           [-1.43909847e-02, -2.03389927e-01],
                           [-1.37980434e-02, -2.11871459e-01],
                           [-1.33553836e-02, -2.16104947e-01],
                           [-1.26064826e-02, -2.28822172e-01],
                           [-1.21877145e-02, -2.37303984e-01],
                           [-1.21191365e-02, -2.41554499e-01],
                           [-1.13414033e-02, -2.54271724e-01],
                           [-1.09025043e-02, -2.62753683e-01],
                           [-1.08224966e-02, -2.67004478e-01],
                           [-1.03128074e-02, -2.76649491e-01],
                           [-1.00592164e-02, -2.86188341e-01],
                           [-9.56951069e-03, -2.98675129e-01],
                           [-9.23288869e-03, -3.06999241e-01],
                           [-9.04728572e-03, -3.11160641e-01],
                           [-8.54320074e-03, -3.23892275e-01],
                           [-8.21830337e-03, -3.32380451e-01],
                           [-8.07539572e-03, -3.36625339e-01],
                           [-7.55685774e-03, -3.49356966e-01],
                           [-7.20806869e-03, -3.57844589e-01],
                           [-7.02829116e-03, -3.62088186e-01],
                           [-6.52420617e-03, -3.74791017e-01],
                           [-6.02012119e-03, -3.87508242e-01],
                           [-5.68600635e-03, -3.95986471e-01],
                           [-5.52230409e-03, -4.00225718e-01],
                           [-5.52230409e-03, -4.63826259e-01],
                           [-5.27748809e-03, -4.95525676e-01],
                           [-5.44635214e-03, -5.16662845e-01],
                           [-5.42644240e-03, -5.27232555e-01],
                           [-4.92235742e-03, -5.33699237e-01],
                           [-4.44068932e-03, -5.39635730e-01],
                           [-4.00709955e-03, -5.44359867e-01],
                           [-3.80040701e-03, -5.45997553e-01],
                           [-2.88750881e-03, -5.48397340e-01],
                           [-2.18130315e-03, -5.49159367e-01],
                           [-1.66158533e-03, -5.49732325e-01],
                           [-8.26843903e-04, -5.49839247e-01],
                           [-6.42715728e-04, -5.49747073e-01],
                           [-6.04666013e-05, -5.50000000e-01]])
    codes = np.zeros(len(fish_shape))
    codes[:] = Path.LINETO
    codes[0] = Path.MOVETO
    codes[-1] = Path.CLOSEPOLY
    path = Path(fish_shape, codes)
    trans = mpl.transforms.Affine2D()
    trans.scale(size)
    angle = np.arctan2(-direction[0], direction[1])
    trans.rotate(angle)
    trans.translate(*pos)
    path = path.transformed(trans)
    ax.add_patch(PathPatch(path, **kwargs))

    
def main():
    import sys
    import os
    import matplotlib.pyplot as plt
    from audioio import write_audio
    from .consoleinput import read, select, save_inputs
    
    if len(sys.argv) > 1:
        if len(sys.argv) == 2 or sys.argv[1] != '-s':
            print('usage: fakefish [-h|--help] [-s audiofile]')
            print('')
            print('Without arguments, run a demo for illustrating fakefish functionality.')
            print('')
            print('-s audiofile: writes audiofile with user defined simulated electric fishes.')
            print('')
            print('by bendalab (2017)')
        else:
            # generate file:
            audiofile = sys.argv[2]
            samplerate = read('Sampling rate in Hz', '44100', float, 1.0)
            duration = read('Duration in seconds', '10', float, 0.001)
            nfish = read('Number of fish', '1', int, 1)
            ndata = read('Number of electrodes', '1', int, 1)
            fish_spread = 1
            if ndata > 1:
                fish_spread = read('Number of electrodes fish are spread over', '2', int, 1)
            data = np.random.randn(int(duration*samplerate), ndata)*0.01
            fish_indices = np.random.randint(ndata, size=nfish)
            eodt = 'a'
            eodf = 800.0
            eoda = 1.0
            eodsig = 'n'
            pulse_jitter = 0.1
            chirp_freq = 5.0
            chirp_size = 100.0
            chirp_width = 0.01
            chirp_kurtosis = 1.0            
            rise_freq = 0.1
            rise_size = 10.0
            rise_tau = 1.0
            rise_decay_tau = 10.0
            for k in range(nfish):
                print('')
                fish = 'Fish %d: ' % (k+1)
                eodt = select(fish + 'EOD type', eodt, ['a', 'e', '1', '2', '3'],
                              ['Apteronotus', 'Eigenmannia',
                               'monophasic pulse', 'biphasic pulse', 'triphasic pulse'])
                eodf = read(fish + 'EOD frequency in Hz', '%g'%eodf, float, 1.0, 3000.0)
                eoda = read(fish + 'EOD amplitude', '%g'%eoda, float, 0.0, 10.0)
                if eodt in 'ae':
                    eodsig = select(fish + 'Add communication signals', eodsig, ['n', 'c', 'r'],
                              ['fixed EOD', 'chirps', 'rises'])
                    eodfreq = eodf
                    if eodsig == 'c':
                        chirp_freq = read('Number of chirps per second', '%g'%chirp_freq, float, 0.001)
                        chirp_size = read('Size of chirp in Hz', '%g'%chirp_size, float, 1.0)
                        chirp_width = 0.001*read('Width of chirp in ms', '%g'%(1000.0*chirp_width), float, 1.0)
                        eodfreq = chirps_frequency(eodf, samplerate, duration,
                                                   chirp_freq, chirp_size, chirp_width, chirp_kurtosis)
                    elif eodsig == 'r':
                        rise_freq = read('Number of rises per second', '%g'%rise_freq, float, 0.00001)
                        rise_size = read('Size of rise in Hz', '%g'%rise_size, float, 0.01)
                        rise_tau = read('Time-constant of rise onset in seconds', '%g'%rise_tau, float, 0.01)
                        rise_decay_tau = read('Time-constant of rise decay in seconds', '%g'%rise_decay_tau, float, 0.01)
                        eodfreq = rises_frequency(eodf, samplerate, duration,
                                                  rise_freq, rise_size, rise_tau, rise_decay_tau)
                    if eodt == 'a':
                        fishdata = eoda*generate_alepto(eodfreq, samplerate, duration=duration,
                                                        noise_std=0.0)
                    elif eodt == 'e':
                        fishdata = eoda*generate_eigenmannia(eodfreq, samplerate, duration=duration,
                                                             noise_std=0.0)
                else:
                    pulse_jitter = read(fish + 'CV of pulse jitter', '%g'%pulse_jitter, float, 0.0, 2.0)
                    if eodt == '1':
                        fishdata = eoda*generate_monophasic_pulses(eodf, samplerate, duration,
                                                                   jitter_cv=pulse_jitter,
                                                                   noise_std=0.0)
                    elif eodt == '2':
                        fishdata = eoda*generate_biphasic_pulses(eodf, samplerate, duration,
                                                                 jitter_cv=pulse_jitter,
                                                                 noise_std=0.0)
                    elif eodt == '3':
                        fishdata = eoda*generate_triphasic_pulses(eodf, samplerate, duration,
                                                                  jitter_cv=pulse_jitter,
                                                                  noise_std=0.0)
                i = fish_indices[k]
                for j in range(fish_spread):
                    data[:, (i+j)%ndata] += fishdata*(0.2**j)

            maxdata = np.max(np.abs(data))
            write_audio(audiofile, 0.9*data/maxdata, samplerate)
            input_file = os.path.splitext(audiofile)[0] + '.inp' 
            save_inputs(input_file)
            print('\nWrote fakefish data to file "%s".' % audiofile)
    
    else:
        # demo:
        samplerate = 40000.  # in Hz
        duration = 10.0       # in sec

        inset_len = 0.01  # in sec
        inset_indices = int(inset_len*samplerate)
        ws_fac = 0.1  # whitespace factor or ylim (between 0. and 1.; preferably a small number)

        # generate data:
        time = np.arange(0, duration, 1./samplerate)

        eodf = 400.0
        #eodf = 500.0 - time/duration*400.0
        wavefish = generate_wavefish(eodf, samplerate, duration=duration, noise_std=0.02, 
                                     amplitudes=[1.0, 0.5, 0.1, 0.0001],
                                     phases=[0.0, 0.0, 0.0, 0.0])
        eodf = 650.0
        # wavefish = generate_alepto(eodf, samplerate, duration=duration)
        wavefish += 0.5*generate_eigenmannia(eodf, samplerate, duration=duration)

        pulsefish = generate_pulsefish(80., samplerate, duration=duration,
                                       noise_std=0.02, jitter_cv=0.1,
                                       peak_stds=[0.0001, 0.0002],
                                       peak_amplitudes=[1.0, -0.3],
                                       peak_times=[0.0, 0.0003])
        # pulsefish = generate_monophasic_pulses(80., samplerate, duration=duration)
        # pulsefish = generate_biphasic_pulses(80., samplerate, duration=duration)
        # pulsefish = generate_triphasic_pulses(80., samplerate, duration=duration)

        fig, ax = plt.subplots(nrows=2, ncols=2, figsize=(19, 10))

        # get proper wavefish ylim
        ymin = np.min(wavefish)
        ymax = np.max(wavefish)
        dy = ws_fac*(ymax - ymin)
        ymin -= dy
        ymax += dy

        # complete wavefish:
        ax[0][0].set_title('Wavefish')
        ax[0][0].set_ylim(ymin, ymax)
        ax[0][0].plot(time, wavefish)

        # wavefish zoom in:
        ax[0][1].set_title('Wavefish ZOOM IN')
        ax[0][1].set_ylim(ymin, ymax)
        ax[0][1].plot(time[:inset_indices], wavefish[:inset_indices], '-o')

        # get proper pulsefish ylim
        ymin = np.min(pulsefish)
        ymax = np.max(pulsefish)
        dy = ws_fac*(ymax - ymin)
        ymin -= dy
        ymax += dy

        # complete pulsefish:
        ax[1][0].set_title('Pulsefish')
        ax[1][0].set_ylim(ymin, ymax)
        ax[1][0].plot(time, pulsefish)

        # pulsefish zoom in:
        ax[1][1].set_title('Pulsefish ZOOM IN')
        ax[1][1].set_ylim(ymin, ymax)
        ax[1][1].plot(time[:inset_indices/2], pulsefish[:inset_indices/2], '-o')

        for row in ax:
            for c_ax in row:
                c_ax.set_xlabel('Time [sec]')
                c_ax.set_ylabel('Amplitude')

        plt.tight_layout()

        # chirps:
        chirps_freq = chirps_frequency(600.0, samplerate, duration=duration, chirp_kurtosis=1.0)
        chirps_data = generate_alepto(chirps_freq, samplerate)

        # rises:
        rises_freq = rises_frequency(600.0, samplerate, duration=duration, rise_size=20.0)
        rises_data = generate_alepto(rises_freq, samplerate)

        nfft = 256
        fig, ax = plt.subplots(nrows=2, ncols=1, figsize=(19, 10))
        ax[0].set_title('Chirps')
        ax[0].specgram(chirps_data, Fs=samplerate, NFFT=nfft, noverlap=nfft//16)
        time = np.arange(len(chirps_freq))/samplerate
        ax[0].plot(time[:-nfft/2], chirps_freq[nfft/2:], '-k', lw=2)
        ax[0].set_ylim(0.0, 3000.0)
        ax[0].set_ylabel('Frequency [Hz]')

        nfft = 4096
        ax[1].set_title('Rises')
        ax[1].specgram(rises_data, Fs=samplerate, NFFT=nfft, noverlap=nfft//2)
        time = np.arange(len(rises_freq))/samplerate
        ax[1].plot(time[:-nfft/4], rises_freq[nfft/4:], '-k', lw=2)
        ax[1].set_ylim(500.0, 700.0)
        ax[1].set_ylabel('Frequency [Hz]')
        ax[1].set_xlabel('Time [s]')
        plt.tight_layout()

        plt.show()

            
if __name__ == '__main__':
    main()
