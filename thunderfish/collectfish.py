"""
# Collect data generated by thunderfish in a wavefish and a pulsefish table.
"""

import os
import sys
import argparse
from .version import __version__, __year__
from .configfile import ConfigFile
from .tabledata import TableData, add_write_table_config, write_table_args
from .eodanalysis import wave_quality, wave_quality_args, add_eod_quality_config
from .eodanalysis import pulse_quality, pulse_quality_args


def collect_fish(files, insert_file=True, append_file=False, simplify_file=False,
                 max_fish=0, harmonics=None, peaks0=None, peaks1=None, cfg=None):
    """
    Combine all *-wavefish.* and/or *-pulsefish.* files into respective summary tables.

    Data from the *-wavespectrum-*.* and the *-pulsepeaks-*.* files can be added
    as specified by `harmonics`, `peaks0`, and `peaks1`.

    Parameters
    ----------
    files: list of strings
        Files to be combined.
    insert_file: boolean
        Insert the basename of the recording file as the first column.
    append_file: boolean
        Add the basename of the recording file as the last column.
        Overwrites `insert_file`.
    simplify_file: boolean
        Remove initial common directories from input files.
    max_fish: int
        Maximum number of fish to be taken, if 0 take all.
    harmonics: int
        Number of harmonic to be added to the wave-type fish table (amplitude, relampl, phase).
        This data is read in from the corresponding *-wavespectrum-*.* files.
    peaks0: int
        Index of the first peak of a EOD pulse to be added to the pulse-type fish table.
        This data is read in from the corresponding *-pulsepeaks-*.* files.
    peaks1: int
        Index of the last peak of a EOD pulse to be added to the pulse-type fish table.
        This data is read in from the corresponding *-pulsepeaks-*.* files.
    cfg: ConfigFile
        Configuration parameter for EOD quality assessment.

    Returns
    -------
    wave_table: TableData
        Summary table for all wave-type fish.
    pulse_table: TableData
        Summary table for all pulse-type fish.
    """
    if append_file and insert_file:
        insert_file = False
    # load data:    
    wave_table = None
    pulse_table = None
    file_pathes = []
    for file_name in files:
        # file name:
        table = None
        base_path, file_ext = os.path.splitext(file_name)[0:2]
        if base_path.endswith('-pulsefish'):
            base_path = base_path[:-10]
            fish_type = 'pulse'
        elif base_path.endswith('-wavefish'):
            base_path = base_path[:-9]
            fish_type = 'wave'
        else:
            continue
        if base_path.startswith('./'):
            base_path = base_path[2:]
        recording = base_path
        file_pathes.append(os.path.normpath(recording).split(os.path.sep))
        # data:
        data = TableData(file_name)
        table = wave_table if fish_type == 'wave' else pulse_table
        # prepare table:
        if not table:
            df = TableData(data)
            df.clear_data()
            if insert_file:
                df.insert(0, ['recording']*data.nsecs + ['file'], '', '%-s')
            if fish_type == 'wave':
                if harmonics is not None:
                    wave_spec = TableData(base_path + '-wavespectrum-0' + file_ext)
                    if data.nsecs > 0:
                        df.append_section('harmonics')
                    for h in range(harmonics+1):
                        df.append('ampl%d' % h, wave_spec.unit('amplitude'),
                                      wave_spec.format('amplitude'))
                        if h > 0:
                            df.append('relampl%d' % h, '%', '%.2f')
                            df.append('relpower%d' % h, '%', '%.2f')
                            df.append('phase%d' % h, 'rad', '%.3f')
            else:
                if peaks0 is not None:
                    pulse_peaks = TableData(base_path + '-pulsepeaks-0' + file_ext)
                    if data.nsecs > 0:
                        df.append_section('peaks')
                    for p in range(peaks0, peaks1+1):
                        if p != 1:
                            df.append('P%dtime' % p, 'ms', '%.3f')
                        df.append('P%dampl' % p, pulse_peaks.unit('amplitude'),
                                  pulse_peaks.format('amplitude'))
                        if p != 1:
                            df.append('P%drelampl' % p, '%', '%.2f')
                        df.append('P%dwidth' % p, 'ms', '%.3f')
            if append_file:
                df.append(['recording']*data.nsecs + ['file'], '', '%-s')
            if fish_type == 'wave':
                wave_table = df
            else:
                pulse_table = df
            table = wave_table if fish_type == 'wave' else pulse_table
        # fill table:
        n = data.rows() if not max_fish or max_fish > data.rows() else max_fish
        for r in range(n):
            # fish index:
            idx = r
            if 'index' in data:
                idx = data[r,'index']
            # clipped:
            clipped = 0.0
            if 'clipped' in data:
                clipped = 0.01*data[r,'clipped']
            # check quality:
            skips = ''
            if fish_type == 'wave':
                wave_spec = TableData(base_path + '-wavespectrum-%d'%idx + file_ext)
                if cfg is not None:
                    spec_data = wave_spec.array()
                    skips, msg = wave_quality(idx, clipped, 0.01*data[r,'noise'],
                                              0.01*data[r,'rmserror'],
                                              data[r,'power'], 0.01*spec_data[1:,3],
                                              **wave_quality_args(cfg))
            else:
                if cfg is not None:
                    skips, msg = pulse_quality(idx, clipped, 0.01*data[r,'noise'],
                                               **pulse_quality_args(cfg))
            if len(skips) > 0:
                print('skip fish %d from %s: %s' % (idx, recording, skips))
                continue
            # fill in data:
            data_col = 0
            if insert_file:
                table.append_data(recording, data_col)
                data_col += 1
            table.append_data(data[r,:].array(), data_col)
            if peaks0 is not None and fish_type == 'pulse':
                pulse_peaks = TableData(base_path + '-pulsepeaks-%d'%idx + file_ext)
                for p in range(peaks0, peaks1+1):
                    for pr in range(pulse_peaks.rows()):
                        if pulse_peaks[pr,'P'] == p:
                            break
                    else:
                        continue
                    if p != 1:
                        table.append_data(pulse_peaks[pr,'time'], 'P%dtime' % p)
                    table.append_data(pulse_peaks[pr,'amplitude'], 'P%dampl' % p)
                    if p != 1:
                        table.append_data(pulse_peaks[pr,'relampl'], 'P%drelampl' % p)
                    table.append_data(pulse_peaks[pr,'width'], 'P%dwidth' % p)
            elif harmonics is not None and fish_type == 'wave':
                for h in range(harmonics+1):
                    table.append_data(wave_spec[h,'amplitude'])
                    if h > 0:
                        table.append_data(wave_spec[h,'relampl'])
                        table.append_data(wave_spec[h,'relpower'])
                        table.append_data(wave_spec[h,'phase'])
            if append_file:
                table.append_data(recording)
            table.fill_data()
    # simplify pathes:
    if simplify_file and len(file_pathes) > 1:
        fp0 = file_pathes[0]
        for fi in range(len(fp0)):
            is_same = True
            for fp in file_pathes[1:]:
                if fi >= len(fp) or fp[fi] != fp0[fi]:
                    is_same = False
                    break
            if not is_same:
                break
        for table in wave_table, pulse_table:
            if table is not None:
                for k in range(table.rows()):
                    idx = table.index('file')
                    fps = os.path.normpath(table[k,idx]).split(os.path.sep)
                    table[k,idx] = os.path.sep.join(fps[fi:])
    return wave_table, pulse_table

    
def rangestr(string):
    """
    Parse string of the form N:M .
    """
    if string[0] == '=':
        string = '-' + string[1:]
    ss = string.split(':')
    v0 = v1 = None
    if len(ss) == 1:
        v0 = int(string)
        v1 = v0
    else:
        v0 = int(ss[0])
        v1 = int(ss[1])
    return (v0, v1)


def main():
    # command line arguments:
    parser = argparse.ArgumentParser(add_help=True,
        description='Collect data generated by thunderfish in a wavefish and a pulsefish table.',
        epilog='version %s by Benda-Lab (2019-%s)' % (__version__, __year__))
    parser.add_argument('--version', action='version', version=__version__)
    parser.add_argument('-t', dest='table_type', default=None, choices=['wave', 'pulse'],
                        help='wave-type or pulse-type fish')
    parser.add_argument('-a', dest='append_file', action='store_true',
                        help='append the file name as the last column')
    parser.add_argument('-c', dest='simplify_file', action='store_true',
                        help='remove initial common directories from input files')
    parser.add_argument('-m', dest='max_fish', type=int, metavar='N',
                        help='maximum number of fish to be taken from each recording')
    parser.add_argument('-p', dest='pulse_peaks', type=rangestr,
                        default=(None, None), metavar='N:M',
                        help='add properties of peak PN to PM of pulse-type EODs to the table')
    parser.add_argument('-w', dest='harmonics', type=int, metavar='N',
                        help='add properties of first N harmonics of wave-type EODs to the table')
    parser.add_argument('-r', dest='remove_cols', action='append', default=[], metavar='COLUMN',
                        help='columns to be removed from output table')
    parser.add_argument('-s', dest='statistics', action='store_true',
                        help='also write table with statistics')
    parser.add_argument('-n', dest='file_suffix', metavar='NAME', default='', type=str,
                        help='name for summary files that is appended to "wavefish" or "pulsefish"')
    parser.add_argument('-o', dest='out_path', metavar='PATH', default='.', type=str,
                        help='path where to store summary tables')
    parser.add_argument('-f', dest='format', default='auto', type=str,
                        choices=TableData.formats + ['same'],
                        help='file format used for saving summary tables ("same" uses same format as input files)')
    parser.add_argument('file', nargs='+', default='', type=str,
                        help='a *-wavefish.* or *-pulsefish.* file as generated by thunderfish')
    # fix minus sign issue:
    ca = []
    pa = False
    for a in sys.argv[1:]:
        if pa and a[0] == '-':
            a = '=' + a[1:]
        pa = False
        if a == '-p':
            pa = True
        ca.append(a)
    # read in command line arguments:    
    args = parser.parse_args(ca)
    table_type = args.table_type
    remove_cols = args.remove_cols
    statistics = args.statistics
    file_suffix = args.file_suffix
    out_path = args.out_path
    data_format = args.format
    # read configuration:
    cfgfile = __package__ + '.cfg'
    cfg = ConfigFile()
    add_eod_quality_config(cfg)
    add_write_table_config(cfg, table_format='csv', unit_style='row',
                           align_columns=True, shrink_width=False)
    cfg.load_files(cfgfile, args.file[0], 3)
    # output format:
    if data_format == 'same':
        ext = os.path.splitext(args.file[0])[1][1:]
        if ext in TableData.ext_formats:
            data_format = TableData.ext_formats[ext]
        else:
            data_format = 'dat'
    if data_format != 'auto':
        cfg.set('fileFormat', data_format)
    # create output folder:
    if not os.path.exists(out_path):
        os.makedirs(out_path)
    # collect files:
    wave_table, pulse_table = collect_fish(args.file, True, args.append_file,
                                           args.simplify_file,
                                           args.max_fish, args.harmonics,
                                           args.pulse_peaks[0],  args.pulse_peaks[1], cfg)
    # write tables:
    if len(file_suffix) > 0 and file_suffix[0] != '-':
        file_suffix = '-' + file_suffix
    if pulse_table and (not table_type or table_type == 'pulse'):
        for rc in remove_cols:
            if rc in pulse_table:
                pulse_table.remove(rc)
        pulse_table.write(os.path.join(out_path, 'pulsefish%s' % file_suffix),
                          **write_table_args(cfg))
        if statistics:
            s = pulse_table.statistics()
            s.write(os.path.join(out_path, 'pulsefish%s-statistics' % file_suffix),
                    **write_table_args(cfg))
    if wave_table and (not table_type or table_type == 'wave'):
        for rc in remove_cols:
            if rc in wave_table:
                wave_table.remove(rc)
        wave_table.write(os.path.join(out_path, 'wavefish%s' % file_suffix),
                         **write_table_args(cfg))
        if statistics:
            s = wave_table.statistics()
            s.write(os.path.join(out_path, 'wavefish%s-statistics' % file_suffix),
                    **write_table_args(cfg))


if __name__ == '__main__':
    main()
