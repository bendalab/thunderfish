<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>thunderfish.thunderbrowse API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>thunderfish.thunderbrowse</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="thunderfish.thunderbrowse.short_user_warning"><code class="name flex">
<span>def <span class="ident">short_user_warning</span></span>(<span>message, category, filename, lineno, file=None, line='')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def short_user_warning(message, category, filename, lineno, file=None, line=&#39;&#39;):
    if file is None:
        file = sys.stderr
    if category == UserWarning:
        file.write(&#39;%s line %d: %s\n&#39; % (&#39;/&#39;.join(filename.split(&#39;/&#39;)[-2:]), lineno, message))
    else:
        s = warnings.formatwarning(message, category, filename, lineno, line)
        file.write(s)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="thunderfish.thunderbrowse.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>cargs=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(cargs=None):
    warnings.showwarning = short_user_warning

    # config file name:
    cfgfile = __package__ + &#39;.cfg&#39;

    # command line arguments:
    if cargs is None:
        cargs = sys.argv[1:]
    parser = argparse.ArgumentParser(
        description=&#39;Browse mutlichannel EOD recordings.&#39;,
        epilog=&#39;version %s by Benda-Lab (2022-%s)&#39; % (__version__, __year__))
    parser.add_argument(&#39;--version&#39;, action=&#39;version&#39;, version=__version__)
    parser.add_argument(&#39;-v&#39;, action=&#39;count&#39;, dest=&#39;verbose&#39;)
    parser.add_argument(&#39;-c&#39;, dest=&#39;channels&#39;, default=&#39;&#39;,
                        type=str, metavar=&#39;CHANNELS&#39;,
                        help=&#39;Comma separated list of channels to be displayed (first channel is 0).&#39;)
    parser.add_argument(&#39;-t&#39;, dest=&#39;tmax&#39;, default=None,
                        type=float, metavar=&#39;TMAX&#39;,
                        help=&#39;Process and show only the first TMAX seconds.&#39;)
    parser.add_argument(&#39;-f&#39;, dest=&#39;fcutoff&#39;, default=None,
                        type=float, metavar=&#39;FREQ&#39;,
                        help=&#39;Cutoff frequency of optional high-pass filter.&#39;)
    parser.add_argument(&#39;-p&#39;, dest=&#39;pulses&#39;, action=&#39;store_true&#39;,
                        help=&#39;detect pulse fish EODs&#39;)
    parser.add_argument(&#39;file&#39;, nargs=1, default=&#39;&#39;, type=str,
                        help=&#39;name of the file with the time series data&#39;)
    args = parser.parse_args(cargs)
    filepath = args.file[0]
    cs = [s.strip() for s in args.channels.split(&#39;,&#39;)]
    channels = [int(c) for c in cs if len(c)&gt;0]
    tmax = args.tmax
    fcutoff = args.fcutoff
    pulses = args.pulses

    # set verbosity level from command line:
    verbose = 0
    if args.verbose != None:
        verbose = args.verbose

    # load data:
    filename = os.path.basename(filepath)
    with DataLoader(filepath, 10*60.0, 5.0, verbose) as data:
        SignalPlot(data, data.rate, data.unit, filename,
                   channels, tmax, fcutoff, pulses)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="thunderfish.thunderbrowse.SignalPlot"><code class="flex name class">
<span>class <span class="ident">SignalPlot</span></span>
<span>(</span><span>data, rate, unit, filename, show_channels=[], tmax=None, fcutoff=None, pulses=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SignalPlot:
    def __init__(self, data, rate, unit, filename,
                 show_channels=[], tmax=None, fcutoff=None,
                 pulses=False):
        self.filename = filename
        self.rate = rate
        self.data = data
        self.channels = self.data.shape[1] if len(self.data.shape) &gt; 1 else 1
        self.unit = unit
        self.tmax = (len(self.data)-1)/self.rate
        if not tmax is None:
            self.tmax = tmax
            self.data = data[:int(tmax*self.rate),:]
        self.toffset = 0.0
        self.twindow = 10.0
        if self.twindow &gt; self.tmax:
            self.twindow = np.round(2 ** (np.floor(np.log(self.tmax) / np.log(2.0)) + 1.0))
            if not tmax is None:
                self.twindow = tmax
        self.pulses = np.zeros((0, 3), dtype=int)
        self.labels = []
        self.fishes = []
        self.pulse_times = []
        self.pulse_gids = []
        if len(show_channels) == 0:
            self.show_channels = np.arange(self.channels)
        else:
            self.show_channels = np.array(show_channels)
        self.traces = len(self.show_channels)
        self.ymin = -1.0 * np.ones(self.traces)
        self.ymax = +1.0 * np.ones(self.traces)
        self.fmax = 100.0
        self.trace_artist = [None] * self.traces
        self.show_gid = False
        self.pulse_artist = []
        self.marker_artist = [None] * (self.traces + 1)
        self.ipis_artist = []
        self.ipis_labels = []
        self.figf = None
        self.axf = None
        self.pulse_colors = [&#39;C1&#39;, &#39;C2&#39;, &#39;C3&#39;, &#39;C4&#39;, &#39;C5&#39;, &#39;C6&#39;, &#39;C7&#39;, &#39;C8&#39;, &#39;C9&#39;, &#39;C0&#39;]
        self.help = False
        self.helptext = []
        self.audio = PlayAudio()

        # filter data:
        if not fcutoff is None:
            sos = butter(2, fcutoff, &#39;high&#39;, fs=rate, output=&#39;sos&#39;)
            self.data = sosfiltfilt(sos, self.data[:], 0)

        # pulse detection:
        if pulses:
            # label, group, channel, peak index, trough index
            all_pulses = np.zeros((0, 5), dtype=int)
            for c in range(self.channels):
                #thresh = 1*np.std(self.data[:int(2*self.rate),c])
                thresh = median_std_threshold(self.data[:,c], self.rate,
                                              thresh_fac=6.0)
                thresh = 0.01
                #p, t = detect_peaks(self.data[:,c], thresh)
                p, t, w, h = detect_pulses(self.data[:,c], self.rate,
                                           thresh,
                                           min_rel_slope_diff=0.25,
                                           min_width=0.0001,
                                           max_width=0.01,
                                           width_fac=5.0)
                # label, group, channel, peak, trough:
                pulses = np.hstack((np.arange(len(p))[:,np.newaxis],
                                    np.zeros((len(p), 1), dtype=int),
                                    np.ones((len(p), 1), dtype=int)*c,
                                    p[:,np.newaxis], t[:,np.newaxis]))
                all_pulses = np.vstack((all_pulses, pulses))
            self.pulses = all_pulses[np.argsort(all_pulses[:,3]),:]
            # grouping over channels:
            max_di = int(0.0002*self.rate)   # TODO: parameter
            l = -1
            k = 0
            while k &lt; len(self.pulses):
                tp = self.pulses[k,3]
                tt = self.pulses[k,4]
                height = self.data[self.pulses[k,3],self.pulses[k,2]] - \
                    self.data[self.pulses[k,4],self.pulses[k,2]]
                channel_counts = np.zeros(self.channels, dtype=int)
                channel_counts[self.pulses[k,2]] += 1
                for c in range(1, 3*self.channels):
                    if k+c &gt;= len(self.pulses):
                        break
                    # pulse too far away:
                    if channel_counts[self.pulses[k+c,2]] &gt; 1 or \
                       (np.abs(self.pulses[k+c,3] - tp) &gt; max_di and
                        np.abs(self.pulses[k+c,3] - tt) &gt; max_di and
                        np.abs(self.pulses[k+c,4] - tp) &gt; max_di and
                        np.abs(self.pulses[k+c,4] - tt) &gt; max_di):
                        break
                    channel_counts[self.pulses[k+c,2]] += 1
                    height_kc = self.data[self.pulses[k+c,3],self.pulses[k+c,2]] - \
                        self.data[self.pulses[k+c,4],self.pulses[k+c,2]]
                    # heighest pulse sets time reference:
                    if height_kc &gt; height:
                        tp = self.pulses[k+c,3]
                        tt = self.pulses[k+c,4]
                        height = height_kc
                # all pulses too small:
                if height &lt; 0.02:    # TODO parameter
                    self.pulses[k:k+c,0] = -1
                    k += c
                    continue
                # new label:
                l += 1
                # remove lost pulses:
                for j in range(c):
                    if (np.abs(self.pulses[k+j,3] - tp) &gt; max_di and
                        np.abs(self.pulses[k+j,3] - tt) &gt; max_di and
                        np.abs(self.pulses[k+j,4] - tp) &gt; max_di and
                        np.abs(self.pulses[k+j,4] - tt) &gt; max_di):
                        self.pulses[k+j,0] = -1
                        channel_counts[self.pulses[k+j,2]] -= 1
                    else:
                        self.pulses[k+j,0] = l
                        self.pulses[k+j,1] = l
                # keep only the largest pulse of each channel:
                pulses = self.pulses[k:k+c,:]
                for dc in np.where(channel_counts &gt; 1)[0]:
                    idx = np.where(self.pulses[k:k+c,2] == dc)[0]
                    heights = self.data[pulses[idx,3],dc] - \
                        self.data[pulses[idx,4],dc]
                    for i in range(len(idx)):
                        if i != np.argmax(heights):
                            channel_counts[self.pulses[k+idx[i],2]] -= 1
                            self.pulses[k+idx[i],0] = -1
                k += c
            self.pulses = self.pulses[self.pulses[:,0] &gt;= 0,:]

            # clustering:
            min_dists = []
            recent = []
            k = 0
            while k &lt; len(self.pulses):
                # select pulse group:
                j = k
                gid = self.pulses[j,1]
                for c in range(self.channels):
                    k += 1
                    if k &gt;= len(self.pulses) or \
                       self.pulses[k,1] != gid:
                        break
                heights = np.zeros(self.channels)
                heights[self.pulses[j:k,2]] = \
                    self.data[self.pulses[j:k,3],self.pulses[j:k,2]] - \
                    self.data[self.pulses[j:k,4],self.pulses[j:k,2]]
                # time of largest pulse:
                pulse_time = self.pulses[j+np.argmax(heights[self.pulses[j:k,2]]),3]
                # assign to cluster:
                if len(self.pulse_times) == 0:
                    label = len(self.pulse_times)
                    self.pulse_times.append([])
                    self.pulse_gids.append([])
                else:
                    # compute metrics of recent fishes:
                    # mean relative height difference:
                    dists = np.array([np.mean(np.abs(hh - heights)/np.max(hh))
                                        for ll, tt, hh in recent])
                    thresh = 0.1   # TODO: make parameter
                    # distance between pulses:
                    ipis = np.array([(pulse_time - tt)/self.rate
                                     for ll, tt, hh in recent])
                    ## how can ipis be 0, or just one sample?
                    ##if len(ipis[ipis&lt;0.001]) &gt; 0:
                    ##    print(ipis[ipis&lt;0.001])
                    # ensure minimum IP distance:
                    dists[1/ipis &gt; 300.0] = 2*np.max(dists)  # TODO: make parameter
                    # minimum ditance:
                    min_dist_idx = np.argmin(dists)
                    min_dists.append(dists[min_dist_idx])
                    if dists[min_dist_idx] &lt; thresh:
                        label = recent[min_dist_idx][0]
                    else:
                        label = len(self.pulse_times)
                        self.pulse_times.append([])
                        self.pulse_gids.append([])
                self.pulses[j:k,0] = label
                self.pulse_times[label].append(pulse_time)
                self.pulse_gids[label].append(gid)
                self.fishes.append([label, pulse_time, heights])
                recent.append([label, pulse_time, heights])
                # remove old fish:
                for i, (ll, tt, hh) in enumerate(recent):
                    # TODO: make parameter:
                    if (pulse_time - tt)/self.rate &lt;= 0.2:
                        recent = recent[i:]
                        break
                # only consider the n most recent pulses of a fish:
                n = 5    # TODO make parameter
                labels = np.array([ll for ll, tt, hh in recent])
                if np.sum(labels == label) &gt; n:
                    del recent[np.where(labels == label)[0][0]]
            # pulse times to arrays:
            for k in range(len(self.pulse_times)):
                self.pulse_times[k] = np.array(self.pulse_times[k])


                
            &#34;&#34;&#34;
            # find temporally missing pulses:
            npulses = np.array([len(pts) for pts in self.pulse_times],
                               dtype=int)
            idx = np.argsort(npulses)
            for i in range(len(idx)):
                li = idx[len(idx)-1-i]
                if len(self.pulse_times[li]) &lt; 10 or \
                   len(self.pulse_times[li])/npulses[li] &lt; 0.5:
                    continue
                ipis = np.diff(self.pulse_times[li])
                n = 4 # TODO: make parameter
                k = 0
                while k &lt; len(ipis)-n:
                    mipi = np.median(ipis[k:k+n])
                    if ipis[k+n-2] &gt; 1.8*mipi:
                        # search for pulse closest to pt:
                        pt = self.pulse_times[li][k+n-2] + mipi
                        mlj = -1
                        mpj = -1
                        mdj = 10*mipi
                        for lj in range(len(self.pulse_times)):
                            if lj == li or len(self.pulse_times[lj]) == 0:
                                continue
                            pj = np.argmin(np.abs(self.pulse_times[lj] - pt))
                            dj = np.abs(self.pulse_times[lj][pj] - pt)
                            if dj &lt; int(0.001*self.rate) and dj &lt; mdj:
                                mdj = dj
                                mpj = pj
                                mlj = lj
                        if mlj &gt;= 0:
                            # there is a pulse close to pt:
                            ptj = self.pulse_times[mlj][mpj]
                            pulses = self.pulses[self.pulses[:,0] == mlj,:]
                            gid = pulses[np.argmin(np.abs(pulses[:,3] - ptj)),1]
                            self.pulse_times[li] = np.insert(self.pulse_times[li], k+n-1, ptj)
                            self.pulse_gids[li].insert(k+n-1, gid)
                            # maybe don&#39;t delete but always duplicate and flag it:
                            if False:  # can be deleted
                                self.pulse_times[mlj] = np.delete(self.pulse_times[mlj], mpj)
                                self.pulse_gids[mlj].pop(mpj)
                                self.pulses[self.pulses[:,1] == gid,0] = li
                            else:     # pulse needs to be duplicated:
                                self.pulses[self.pulses[:,1] == gid,0] = li
                            ipis = np.diff(self.pulse_times[li])
                    k += 1


                    
            # clean up pulses:
            for l in range(len(self.pulse_times)):
                if len(self.pulse_times[l])/npulses[l] &lt; 0.5:
                    self.pulse_times[l] = np.array([])
                    self.pulse_gids[l] = []
                    self.pulses[self.pulses[:,0] == l,0] = -1
            self.pulses = self.pulses[self.pulses[:,0] &gt;= 0,:]
            &#34;&#34;&#34;
            
            &#34;&#34;&#34;
            # remove labels that are too close to others:
            widths = np.zeros(len(self.pulse_times), dtype=int)
            for k in range(len(self.pulse_times)):
                widths[k] = int(np.mean(np.abs(self.pulses[self.pulses[:,0] == k,3] - self.pulses[self.pulses[:,0] == k,4])))
            for k in range(len(self.pulse_times)):
                if len(self.pulse_times[k]) &gt; 1:
                    for j in range(k+1, len(self.pulse_times)):
                        if len(self.pulse_times[j]) &gt; 1:
                            di = 10*max(widths[k], widths[j])
                            dts = np.array([np.min(np.abs(self.pulse_times[k] - pt)) for pt in self.pulse_times[j]])
                            if k == 1 and j == 2:
                                print(di, np.sum(dts &lt; di), len(dts))
                                plt.hist(dts, 50)
                                plt.show()
                            if np.sum(dts &lt; 2*max_di)/len(dts) &gt; 0.6:
                                r = k
                                if np.sum(self.fishes[k][2]) &gt; np.sum(self.fishes[j][2]):
                                    r = j
                                self.pulse_times[r] = np.array([])
                                self.pulses[self.pulses[:,0] == r] = -1
                                self.fishes[r] = []
            self.pulses = self.pulses[self.pulses[:,0] &gt;= 0,:]
            &#34;&#34;&#34;
            # all labels:
            self.labels = np.unique(self.pulses[:,0])
            # report:
            print(f&#39;found {len(self.pulse_times)} fish:&#39;)
            for k in range(len(self.pulse_times)):
                print(f&#39;{k:3d}: {len(self.pulse_times[k]):5d} pulses&#39;)
            ## plot histogtram of distances:
            #plt.hist(min_dists, 100)
            #plt.show()
            ## plot features:
            &#34;&#34;&#34;
            nn = np.array([(k, len(self.pulse_times[k]))
                           for k in range(len(self.pulse_times))])
            fig, axs = plt.subplots(5, 5, figsize=(15, 9),
                                    constrained_layout=True)
            ni = np.argsort(nn[:,1])           # largest cluster ...
            ln = np.sort(nn[ni[-axs.size:],0]) # ... sort by label
            for l, ax in zip(ln, axs.flat):
                h = np.array([hh for ll, tt, hh in self.fishes if ll == l])
                ax.plot(h.T, &#39;o-&#39;, ms=2, lw=0.5,
                        color=self.pulse_colors[l%len(self.pulse_colors)])
                ax.text(0.05, 0.9, f&#39;label: {l}&#39;, transform=ax.transAxes)
            &#34;&#34;&#34;
        
        # set key bindings:
        plt.rcParams[&#39;keymap.fullscreen&#39;] = &#39;f&#39;
        plt.rcParams[&#39;keymap.pan&#39;] = &#39;ctrl+m&#39;
        plt.rcParams[&#39;keymap.quit&#39;] = &#39;ctrl+w, alt+q, q&#39;
        plt.rcParams[&#39;keymap.yscale&#39;] = &#39;&#39;
        plt.rcParams[&#39;keymap.xscale&#39;] = &#39;&#39;
        plt.rcParams[&#39;keymap.grid&#39;] = &#39;&#39;
        #plt.rcParams[&#39;keymap.all_axes&#39;] = &#39;&#39;

        # the figure:
        plt.ioff()
        splts = self.traces
        if len(self.pulses) &gt; 0:
            splts += 1
        self.fig, self.axs = plt.subplots(splts, 1, squeeze=False,
                                          figsize=(15, 9), sharex=True)
        self.axs = self.axs.flat
        if self.traces == self.channels:
            self.fig.canvas.manager.set_window_title(self.filename)
        else:
            cs = &#39; c%d&#39; % self.show_channels[0]
            self.fig.canvas.manager.set_window_title(self.filename + &#39; &#39; + cs)
        self.fig.canvas.mpl_connect(&#39;key_press_event&#39;, self.keypress)
        self.fig.canvas.mpl_connect(&#39;resize_event&#39;, self.resize)
        self.fig.canvas.mpl_connect(&#39;pick_event&#39;, self.on_pick)
        # trace plots:
        for t in range(self.traces):
            self.axs[t].set_ylabel(f&#39;C-{self.show_channels[t]+1} [{self.unit}]&#39;)
        #for t in range(self.traces-1):
        #    self.axs[t].xaxis.set_major_formatter(plt.NullFormatter())
        if len(self.pulses) &gt; 0:
            self.axs[-1].set_ylim(0, self.fmax)
            self.axs[-1].set_ylabel(&#39;IP freq [Hz]&#39;)
        self.axs[-1].set_xlabel(&#39;Time [s]&#39;)
        ht = self.axs[0].text(0.98, 0.05, &#39;(ctrl+) page and arrow up, down, home, end: scroll&#39;, ha=&#39;right&#39;,
                           transform=self.axs[0].transAxes)
        self.helptext.append(ht)
        ht = self.axs[0].text(0.98, 0.1, &#39;+, -, X, x: zoom time in/out&#39;, ha=&#39;right&#39;, transform=self.axs[0].transAxes)
        self.helptext.append(ht)
        ht = self.axs[0].text(0.98, 0.2, &#39;y, Y, v, V, ctrl+v, ctrl+V: zoom amplitudes out/in/max/default/max per trace/global max per trace&#39;, ha=&#39;right&#39;, transform=self.axs[0].transAxes)
        self.helptext.append(ht)
        ht = self.axs[0].text(0.98, 0.3, &#39;i, I: zoom IPI frequency in/out&#39;, ha=&#39;right&#39;, transform=self.axs[0].transAxes)
        self.helptext.append(ht)
        ht = self.axs[0].text(0.98, 0.4, &#39;p, P: play audio (display, all)&#39;, ha=&#39;right&#39;, transform=self.axs[0].transAxes)
        self.helptext.append(ht)
        ht = self.axs[0].text(0.98, 0.5, &#39;f: full screen&#39;, ha=&#39;right&#39;, transform=self.axs[0].transAxes)
        self.helptext.append(ht)
        ht = self.axs[0].text(0.98, 0.6, &#39;w: plot waveforms into png file&#39;, ha=&#39;right&#39;, transform=self.axs[0].transAxes)
        self.helptext.append(ht)
        ht = self.axs[0].text(0.98, 0.7, &#39;S: save audiosegment&#39;, ha=&#39;right&#39;, transform=self.axs[0].transAxes)
        self.helptext.append(ht)
        ht = self.axs[0].text(0.98, 0.8, &#39;q: quit&#39;, ha=&#39;right&#39;, transform=self.axs[0].transAxes)
        self.helptext.append(ht)
        ht = self.axs[0].text(0.98, 0.9, &#39;h: toggle this help&#39;, ha=&#39;right&#39;, transform=self.axs[0].transAxes)
        self.helptext.append(ht)
        # plot:
        for ht in self.helptext:
            ht.set_visible(self.help)
        self.update_plots()
        # feature plot:
        if len(self.labels) &gt; 0:
            self.figf, self.axf = plt.subplots()
        plt.show()

    def __del__(self):
        pass
        #self.audio.close()

    def plot_pulses(self, axs, plot=True, tfac=1.0):
        
        def plot_pulse_traces(pulses, i, pak):
            for t in range(self.traces):
                c = self.show_channels[t]
                p = pulses[pulses[:,2] == c,3]
                if len(p) == 0:
                    continue
                if plot or pak &gt;= len(self.pulse_artist):
                    pa, = axs[t].plot(tfac*p/self.rate,
                                      self.data[p,c], &#39;o&#39;, picker=5,
                                      color=self.pulse_colors[i%len(self.pulse_colors)])
                    if not plot:
                        self.pulse_artist.append(pa)
                else:
                    self.pulse_artist[pak].set_data(tfac*p/self.rate,
                                                    self.data[p,c])
                    self.pulse_artist[pak].set_color(self.pulse_colors[i%len(self.pulse_colors)])
                #if len(p) &gt; 1 and len(p) &lt;= 10:
                #    self.pulse_artist[pak].set_markersize(15)
                pak += 1
            return pak

        # pulses:
        pak = 0
        if self.show_gid:
            for g in range(len(self.pulse_colors)):
                pulses = self.pulses[self.pulses[:,1] % len(self.pulse_colors) == g,:]
                pak = plot_pulse_traces(pulses, g, pak)
        else:
            for l in self.labels:
                pulses = self.pulses[self.pulses[:,0] == l,:]
                pak = plot_pulse_traces(pulses, l, pak)
        while pak &lt; len(self.pulse_artist):
            self.pulse_artist[pak].set_data([], [])
            pak += 1
        # ipis:
        for l in self.labels:
            if l &lt; len(self.pulse_times):
                pt = self.pulse_times[l]/self.rate
                if len(pt) &gt; 10:
                    if plot or not l in self.ipis_labels:
                        pa, = axs[-1].plot(tfac*pt[:-1], 1.0/np.diff(pt),
                                           &#39;-o&#39;, picker=5,
                                           color=self.pulse_colors[l%len(self.pulse_colors)])
                        if not plot:
                            self.ipis_artist.append(pa)
                            self.ipis_labels.append(l)
                    else:
                        iak = self.ipis_labels.index(l)
                        self.ipis_artist[iak].set_data(tfac*pt[:-1],
                                                       1.0/np.diff(pt))

    def update_plots(self):
        t0 = int(np.round(self.toffset * self.rate))
        t1 = int(np.round((self.toffset + self.twindow) * self.rate))
        if t1 &gt; len(self.data):
            t1 = len(self.data)
        time = np.arange(t0, t1) / self.rate
        for t in range(self.traces):
            c = self.show_channels[t]
            self.axs[t].set_xlim(self.toffset, self.toffset + self.twindow)
            if self.trace_artist[t] == None:
                self.trace_artist[t], = self.axs[t].plot(time, self.data[t0:t1,c])
            else:
                self.trace_artist[t].set_data(time, self.data[t0:t1,c])
            if t1 - t0 &lt; 200:
                self.trace_artist[t].set_marker(&#39;o&#39;)
                self.trace_artist[t].set_markersize(3)
            else:
                self.trace_artist[t].set_marker(&#39;None&#39;)
            self.axs[t].set_ylim(self.ymin[t], self.ymax[t])
        self.plot_pulses(self.axs, False)
        self.fig.canvas.draw()

    def on_pick(self, event):
        # index of pulse artist:
        pk = -1
        for k, pa in enumerate(self.pulse_artist):
            if event.artist == pa:
                pk = k
                break
        li = -1
        pi = -1
        if pk &gt;= 0:
            # find label and pulses of pulse artist:
            ll = self.labels[pk//self.traces]
            cc = self.show_channels[pk % self.traces]
            pulses = self.pulses[self.pulses[:,0] == ll,:]
            gid = pulses[pulses[:,2] == cc,1][event.ind[0]]
            if ll in self.ipis_labels:
                li = self.ipis_labels.index(ll)
                pi = self.pulse_gids[ll].index(gid)
        else:
            ik = -1
            for k, ia in enumerate(self.ipis_artist):
                if event.artist == ia:
                    ik = k
                    break
            if ik &lt; 0:
                return
            li = ik
            ll = self.ipis_labels[li]
            pi = event.ind[0]
            gid = self.pulse_gids[ll][pi]
        # mark pulses:
        pulses = self.pulses[self.pulses[:,0] == ll,:]
        pulses = pulses[pulses[:,1] == gid,:]
        for t in range(self.traces):
            c = self.show_channels[t]
            pt = pulses[pulses[:,2] == c,3]
            if len(pt) &gt; 0:
                if self.marker_artist[t] is None:
                    pa, = self.axs[t].plot(pt[0]/self.rate,
                                           self.data[pt[0],c], &#39;o&#39;, ms=10,
                                           color=self.pulse_colors[ll%len(self.pulse_colors)])
                    self.marker_artist[t] = pa
                else:
                    self.marker_artist[t].set_data(pt[0]/self.rate,
                                                   self.data[pt[0],c])
                    self.marker_artist[t].set_color(self.pulse_colors[ll%len(self.pulse_colors)])
            elif self.marker_artist[t] is not None:
                self.marker_artist[t].set_data([], [])
        # mark ipi:
        pt0 = -1.0
        pt1 = -1.0
        pf = -1.0
        if pi &gt;= 0:
            pt0 = self.pulse_times[ll][pi]/self.rate
            pt1 = self.pulse_times[ll][pi+1]/self.rate
            pf = 1.0/(pt1-pt0)
            if self.marker_artist[self.traces] is None:
                pa, = self.axs[self.traces].plot(pt0, pf, &#39;o&#39;, ms=10,
                                                 color=self.pulse_colors[ll%len(self.pulse_colors)])
                self.marker_artist[self.traces] = pa
            else:
                self.marker_artist[self.traces].set_data(pt0, pf)
                self.marker_artist[self.traces].set_color(self.pulse_colors[ll%len(self.pulse_colors)])
        elif not self.marker_artist[self.traces] is None:
            self.marker_artist[self.traces].set_data([], [])
        self.fig.canvas.draw()
        # show features:
        if not self.axf is None and not self.fig is None:
            heights = np.zeros(self.channels)
            heights[pulses[:,2]] = \
                self.data[pulses[:,3],pulses[:,2]] - \
                self.data[pulses[:,4],pulses[:,2]]
            self.axf.plot(heights, color=self.pulse_colors[ll%len(self.pulse_colors)])
            print(f&#39;label={ll:4d} gid={gid:5d} t={pt0:8.4f}s&#39;)
            self.figf.canvas.draw()

    def resize(self, event):
        # print(&#39;resized&#39;, event.width, event.height)
        leftpixel = 80.0
        rightpixel = 20.0
        bottompixel = 50.0
        toppixel = 20.0
        x0 = leftpixel / event.width
        x1 = 1.0 - rightpixel / event.width
        y0 = bottompixel / event.height
        y1 = 1.0 - toppixel / event.height
        self.fig.subplots_adjust(left=x0, right=x1, bottom=y0, top=y1,
                                 hspace=0)

    def keypress(self, event):
        # print(&#39;pressed&#39;, event.key)
        if event.key in &#39;+=X&#39;:
            if self.twindow * self.rate &gt; 20:
                self.twindow *= 0.5
                self.update_plots()
        elif event.key in &#39;-x&#39;:
            if self.twindow &lt; self.tmax:
                self.twindow *= 2.0
                self.update_plots()
        elif event.key == &#39;pagedown&#39;:
            if self.toffset + 0.5 * self.twindow &lt; self.tmax:
                self.toffset += 0.5 * self.twindow
                self.update_plots()
        elif event.key == &#39;pageup&#39;:
            if self.toffset &gt; 0:
                self.toffset -= 0.5 * self.twindow
                if self.toffset &lt; 0.0:
                    self.toffset = 0.0
                self.update_plots()
        elif event.key == &#39;ctrl+pagedown&#39;:
            if self.toffset + 5.0 * self.twindow &lt; self.tmax:
                self.toffset += 5.0 * self.twindow
                self.update_plots()
        elif event.key == &#39;ctrl+pageup&#39;:
            if self.toffset &gt; 0:
                self.toffset -= 5.0 * self.twindow
                if self.toffset &lt; 0.0:
                    self.toffset = 0.0
                self.update_plots()
        elif event.key == &#39;down&#39;:
            if self.toffset + self.twindow &lt; self.tmax:
                self.toffset += 0.05 * self.twindow
                self.update_plots()
        elif event.key == &#39;up&#39;:
            if self.toffset &gt; 0.0:
                self.toffset -= 0.05 * self.twindow
                if self.toffset &lt; 0.0:
                    self.toffset = 0.0
                self.update_plots()
        elif event.key == &#39;home&#39;:
            if self.toffset &gt; 0.0:
                self.toffset = 0.0
                self.update_plots()
        elif event.key == &#39;end&#39;:
            toffs = np.floor(self.tmax / self.twindow) * self.twindow
            if self.tmax - toffs &lt;= 0.0:
                toffs -= self.twindow
            if self.tmax - toffs &lt; self.twindow/2:
                toffs -= self.twindow/2
            if self.toffset &lt; toffs:
                self.toffset = toffs
                self.update_plots()
        elif event.key == &#39;y&#39;:
            for t in range(self.traces):
                h = self.ymax[t] - self.ymin[t]
                c = 0.5 * (self.ymax[t] + self.ymin[t])
                self.ymin[t] = c - h
                self.ymax[t] = c + h
                self.axs[t].set_ylim(self.ymin[t], self.ymax[t])
            self.fig.canvas.draw()
        elif event.key == &#39;Y&#39;:
            for t in range(self.traces):
                h = 0.25 * (self.ymax[t] - self.ymin[t])
                c = 0.5 * (self.ymax[t] + self.ymin[t])
                self.ymin[t] = c - h
                self.ymax[t] = c + h
                self.axs[t].set_ylim(self.ymin[t], self.ymax[t])
            self.fig.canvas.draw()
        elif event.key == &#39;v&#39;:
            t0 = int(np.round(self.toffset * self.rate))
            t1 = int(np.round((self.toffset + self.twindow) * self.rate))
            min = np.min(self.data[t0:t1,self.show_channels])
            max = np.max(self.data[t0:t1,self.show_channels])
            h = 0.53 * (max - min)
            c = 0.5 * (max + min)
            self.ymin[:] = c - h
            self.ymax[:] = c + h
            for t in range(self.traces):
                self.axs[t].set_ylim(self.ymin[t], self.ymax[t])
            self.fig.canvas.draw()
        elif event.key == &#39;ctrl+v&#39;:
            t0 = int(np.round(self.toffset * self.rate))
            t1 = int(np.round((self.toffset + self.twindow) * self.rate))
            for t in range(self.traces):
                min = np.min(self.data[t0:t1,self.show_channels[t]])
                max = np.max(self.data[t0:t1,self.show_channels[t]])
                h = 0.53 * (max - min)
                c = 0.5 * (max + min)
                self.ymin[t] = c - h
                self.ymax[t] = c + h
                self.axs[t].set_ylim(self.ymin[t], self.ymax[t])
            self.fig.canvas.draw()
        elif event.key == &#39;ctrl+V&#39;:
            for t in range(self.traces):
                min = np.min(self.data[:,self.show_channels[t]])
                max = np.max(self.data[:,self.show_channels[t]])
                h = 0.53 * (max - min)
                c = 0.5 * (max + min)
                self.ymin[t] = c - h
                self.ymax[t] = c + h
                self.axs[t].set_ylim(self.ymin[t], self.ymax[t])
            self.fig.canvas.draw()
        elif event.key == &#39;V&#39;:
            self.ymin[:] = -1.0
            self.ymax[:] = +1.0
            for t in range(self.traces):
                self.axs[t].set_ylim(self.ymin[t], self.ymax[t])
            self.fig.canvas.draw()
        elif event.key == &#39;c&#39;:
            for t in range(self.traces):
                dy = self.ymax[t] - self.ymin[t]
                self.ymin[t] = -dy/2
                self.ymax[t] = +dy/2
                self.axs[t].set_ylim(self.ymin[t], self.ymax[t])
            self.fig.canvas.draw()
        elif event.key == &#39;g&#39;:
            self.show_gid = not self.show_gid
            self.plot_pulses(self.axs, False)
            self.fig.canvas.draw()
        elif event.key == &#39;i&#39;:
            if len(self.pulses) &gt; 0:
                self.fmax *= 2
                self.axs[-1].set_ylim(0.0, self.fmax)
                self.fig.canvas.draw()
        elif event.key == &#39;I&#39;:
            if len(self.pulses) &gt; 0:
                self.fmax /= 2
                self.axs[-1].set_ylim(0.0, self.fmax)
                self.fig.canvas.draw()
        elif event.key in [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;]:
            cc = int(event.key)
            # TODO: this is not yet what we want:
            &#34;&#34;&#34;
            if cc &lt; self.channels:
                self.axs[cc].set_visible(not self.axs[cc].get_visible())
            self.fig.canvas.draw()
            &#34;&#34;&#34;
        elif event.key in &#39;h&#39;:
            self.help = not self.help
            for ht in self.helptext:
                ht.set_visible(self.help)
            self.fig.canvas.draw()
        elif event.key in &#39;p&#39;:
            self.play_segment()
        elif event.key in &#39;P&#39;:
            self.play_all()
        elif event.key in &#39;S&#39;:
            self.save_segment()
        elif event.key in &#39;w&#39;:
            self.plot_traces()

    def play_segment(self):
        t0 = int(np.round(self.toffset * self.rate))
        t1 = int(np.round((self.toffset + self.twindow) * self.rate))
        playdata = 1.0 * np.mean(self.data[t0:t1,self.show_channels], 1)
        f = 0.1 if self.twindow &gt; 0.5 else 0.1*self.twindow
        fade(playdata, self.rate, f)
        self.audio.play(playdata, self.rate, blocking=False)
        
    def play_all(self):
        self.audio.play(np.mean(self.data[:,self.show_channels], 1),
                        self.rate, blocking=False)

    def save_segment(self):
        t0s = int(np.round(self.toffset))
        t1s = int(np.round(self.toffset + self.twindow))
        t0 = int(np.round(self.toffset * self.rate))
        t1 = int(np.round((self.toffset + self.twindow) * self.rate))
        filename = self.filename.split(&#39;.&#39;)[0]
        if self.traces == self.channels:
            segment_filename = f&#39;{filename}-{t0s:.4g}s-{t1s:.4g}s.wav&#39;
            write_audio(segment_filename, self.data[t0:t1,:], self.rate)
        else:
            segment_filename = f&#39;{filename}-{t0s:.4g}s-{t1s:.4g}s-c{self.show_channels[0]}.wav&#39;
            write_audio(segment_filename,
                        self.data[t0:t1,self.show_channels], self.rate)
        print(&#39;saved segment to: &#39; , segment_filename)

    def plot_traces(self):
        splts = self.traces
        if len(self.pulses) &gt; 0:
            splts += 1
        fig, axs = plt.subplots(splts, 1, squeeze=False, sharex=True,
                                figsize=(15, 9))
        axs = axs.flat
        fig.subplots_adjust(left=0.06, right=0.99, bottom=0.05, top=0.97,
                            hspace=0)
        name = self.filename.split(&#39;.&#39;)[0]
        figfile = f&#39;{name}-{self.toffset:.4g}s-traces.png&#39;
        if self.traces &lt; self.channels:
            figfile = f&#39;{name}-{self.toffset:.4g}s-c{self.show_channels[0]}-traces.png&#39;
        axs[0].set_title(self.filename)
        t0 = int(np.round(self.toffset * self.rate))
        t1 = int(np.round((self.toffset + self.twindow) * self.rate))
        if t1&gt;len(self.data):
            t1 = len(self.data)
        time = np.arange(t0, t1)/self.rate
        if self.toffset &lt; 1.0 and self.twindow &lt; 1.0:
            axs[-1].set_xlabel(&#39;Time [ms]&#39;)
            for t in range(self.traces):
                c = self.show_channels[t]
                axs[t].set_xlim(1000.0 * self.toffset,
                                1000.0 * (self.toffset + self.twindow))
                axs[t].plot(1000.0 * time, self.data[t0:t1,c])
            self.plot_pulses(axs, True, 1000.0)
        else:
            axs[-1].set_xlabel(&#39;Time [s]&#39;)
            for t in range(self.traces):
                c = self.show_channels[t]
                axs[t].set_xlim(self.toffset, self.toffset + self.twindow)
                axs[t].plot(time, self.data[t0:t1,c])
            self.plot_pulses(axs, True, 1.0)
        for t in range(self.traces):
            c = self.show_channels[t]
            axs[t].set_ylim(self.ymin[t], self.ymax[t])
            axs[t].set_ylabel(f&#39;C-{c+1} [{self.unit}]&#39;)
        if len(self.pulses) &gt; 0:
            axs[-1].set_ylabel(&#39;IP freq [Hz]&#39;)
            axs[-1].set_ylim(0.0, self.fmax)
        #for t in range(self.traces-1):
        #    axs[t].xaxis.set_major_formatter(plt.NullFormatter())
        fig.savefig(figfile, dpi=200)
        plt.close(fig)
        print(&#39;saved waveform figure to&#39;, figfile)</code></pre>
</details>
<div class="desc"></div>
<h3>Methods</h3>
<dl>
<dt id="thunderfish.thunderbrowse.SignalPlot.plot_pulses"><code class="name flex">
<span>def <span class="ident">plot_pulses</span></span>(<span>self, axs, plot=True, tfac=1.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_pulses(self, axs, plot=True, tfac=1.0):
    
    def plot_pulse_traces(pulses, i, pak):
        for t in range(self.traces):
            c = self.show_channels[t]
            p = pulses[pulses[:,2] == c,3]
            if len(p) == 0:
                continue
            if plot or pak &gt;= len(self.pulse_artist):
                pa, = axs[t].plot(tfac*p/self.rate,
                                  self.data[p,c], &#39;o&#39;, picker=5,
                                  color=self.pulse_colors[i%len(self.pulse_colors)])
                if not plot:
                    self.pulse_artist.append(pa)
            else:
                self.pulse_artist[pak].set_data(tfac*p/self.rate,
                                                self.data[p,c])
                self.pulse_artist[pak].set_color(self.pulse_colors[i%len(self.pulse_colors)])
            #if len(p) &gt; 1 and len(p) &lt;= 10:
            #    self.pulse_artist[pak].set_markersize(15)
            pak += 1
        return pak

    # pulses:
    pak = 0
    if self.show_gid:
        for g in range(len(self.pulse_colors)):
            pulses = self.pulses[self.pulses[:,1] % len(self.pulse_colors) == g,:]
            pak = plot_pulse_traces(pulses, g, pak)
    else:
        for l in self.labels:
            pulses = self.pulses[self.pulses[:,0] == l,:]
            pak = plot_pulse_traces(pulses, l, pak)
    while pak &lt; len(self.pulse_artist):
        self.pulse_artist[pak].set_data([], [])
        pak += 1
    # ipis:
    for l in self.labels:
        if l &lt; len(self.pulse_times):
            pt = self.pulse_times[l]/self.rate
            if len(pt) &gt; 10:
                if plot or not l in self.ipis_labels:
                    pa, = axs[-1].plot(tfac*pt[:-1], 1.0/np.diff(pt),
                                       &#39;-o&#39;, picker=5,
                                       color=self.pulse_colors[l%len(self.pulse_colors)])
                    if not plot:
                        self.ipis_artist.append(pa)
                        self.ipis_labels.append(l)
                else:
                    iak = self.ipis_labels.index(l)
                    self.ipis_artist[iak].set_data(tfac*pt[:-1],
                                                   1.0/np.diff(pt))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="thunderfish.thunderbrowse.SignalPlot.update_plots"><code class="name flex">
<span>def <span class="ident">update_plots</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_plots(self):
    t0 = int(np.round(self.toffset * self.rate))
    t1 = int(np.round((self.toffset + self.twindow) * self.rate))
    if t1 &gt; len(self.data):
        t1 = len(self.data)
    time = np.arange(t0, t1) / self.rate
    for t in range(self.traces):
        c = self.show_channels[t]
        self.axs[t].set_xlim(self.toffset, self.toffset + self.twindow)
        if self.trace_artist[t] == None:
            self.trace_artist[t], = self.axs[t].plot(time, self.data[t0:t1,c])
        else:
            self.trace_artist[t].set_data(time, self.data[t0:t1,c])
        if t1 - t0 &lt; 200:
            self.trace_artist[t].set_marker(&#39;o&#39;)
            self.trace_artist[t].set_markersize(3)
        else:
            self.trace_artist[t].set_marker(&#39;None&#39;)
        self.axs[t].set_ylim(self.ymin[t], self.ymax[t])
    self.plot_pulses(self.axs, False)
    self.fig.canvas.draw()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="thunderfish.thunderbrowse.SignalPlot.on_pick"><code class="name flex">
<span>def <span class="ident">on_pick</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_pick(self, event):
    # index of pulse artist:
    pk = -1
    for k, pa in enumerate(self.pulse_artist):
        if event.artist == pa:
            pk = k
            break
    li = -1
    pi = -1
    if pk &gt;= 0:
        # find label and pulses of pulse artist:
        ll = self.labels[pk//self.traces]
        cc = self.show_channels[pk % self.traces]
        pulses = self.pulses[self.pulses[:,0] == ll,:]
        gid = pulses[pulses[:,2] == cc,1][event.ind[0]]
        if ll in self.ipis_labels:
            li = self.ipis_labels.index(ll)
            pi = self.pulse_gids[ll].index(gid)
    else:
        ik = -1
        for k, ia in enumerate(self.ipis_artist):
            if event.artist == ia:
                ik = k
                break
        if ik &lt; 0:
            return
        li = ik
        ll = self.ipis_labels[li]
        pi = event.ind[0]
        gid = self.pulse_gids[ll][pi]
    # mark pulses:
    pulses = self.pulses[self.pulses[:,0] == ll,:]
    pulses = pulses[pulses[:,1] == gid,:]
    for t in range(self.traces):
        c = self.show_channels[t]
        pt = pulses[pulses[:,2] == c,3]
        if len(pt) &gt; 0:
            if self.marker_artist[t] is None:
                pa, = self.axs[t].plot(pt[0]/self.rate,
                                       self.data[pt[0],c], &#39;o&#39;, ms=10,
                                       color=self.pulse_colors[ll%len(self.pulse_colors)])
                self.marker_artist[t] = pa
            else:
                self.marker_artist[t].set_data(pt[0]/self.rate,
                                               self.data[pt[0],c])
                self.marker_artist[t].set_color(self.pulse_colors[ll%len(self.pulse_colors)])
        elif self.marker_artist[t] is not None:
            self.marker_artist[t].set_data([], [])
    # mark ipi:
    pt0 = -1.0
    pt1 = -1.0
    pf = -1.0
    if pi &gt;= 0:
        pt0 = self.pulse_times[ll][pi]/self.rate
        pt1 = self.pulse_times[ll][pi+1]/self.rate
        pf = 1.0/(pt1-pt0)
        if self.marker_artist[self.traces] is None:
            pa, = self.axs[self.traces].plot(pt0, pf, &#39;o&#39;, ms=10,
                                             color=self.pulse_colors[ll%len(self.pulse_colors)])
            self.marker_artist[self.traces] = pa
        else:
            self.marker_artist[self.traces].set_data(pt0, pf)
            self.marker_artist[self.traces].set_color(self.pulse_colors[ll%len(self.pulse_colors)])
    elif not self.marker_artist[self.traces] is None:
        self.marker_artist[self.traces].set_data([], [])
    self.fig.canvas.draw()
    # show features:
    if not self.axf is None and not self.fig is None:
        heights = np.zeros(self.channels)
        heights[pulses[:,2]] = \
            self.data[pulses[:,3],pulses[:,2]] - \
            self.data[pulses[:,4],pulses[:,2]]
        self.axf.plot(heights, color=self.pulse_colors[ll%len(self.pulse_colors)])
        print(f&#39;label={ll:4d} gid={gid:5d} t={pt0:8.4f}s&#39;)
        self.figf.canvas.draw()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="thunderfish.thunderbrowse.SignalPlot.resize"><code class="name flex">
<span>def <span class="ident">resize</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resize(self, event):
    # print(&#39;resized&#39;, event.width, event.height)
    leftpixel = 80.0
    rightpixel = 20.0
    bottompixel = 50.0
    toppixel = 20.0
    x0 = leftpixel / event.width
    x1 = 1.0 - rightpixel / event.width
    y0 = bottompixel / event.height
    y1 = 1.0 - toppixel / event.height
    self.fig.subplots_adjust(left=x0, right=x1, bottom=y0, top=y1,
                             hspace=0)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="thunderfish.thunderbrowse.SignalPlot.keypress"><code class="name flex">
<span>def <span class="ident">keypress</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keypress(self, event):
    # print(&#39;pressed&#39;, event.key)
    if event.key in &#39;+=X&#39;:
        if self.twindow * self.rate &gt; 20:
            self.twindow *= 0.5
            self.update_plots()
    elif event.key in &#39;-x&#39;:
        if self.twindow &lt; self.tmax:
            self.twindow *= 2.0
            self.update_plots()
    elif event.key == &#39;pagedown&#39;:
        if self.toffset + 0.5 * self.twindow &lt; self.tmax:
            self.toffset += 0.5 * self.twindow
            self.update_plots()
    elif event.key == &#39;pageup&#39;:
        if self.toffset &gt; 0:
            self.toffset -= 0.5 * self.twindow
            if self.toffset &lt; 0.0:
                self.toffset = 0.0
            self.update_plots()
    elif event.key == &#39;ctrl+pagedown&#39;:
        if self.toffset + 5.0 * self.twindow &lt; self.tmax:
            self.toffset += 5.0 * self.twindow
            self.update_plots()
    elif event.key == &#39;ctrl+pageup&#39;:
        if self.toffset &gt; 0:
            self.toffset -= 5.0 * self.twindow
            if self.toffset &lt; 0.0:
                self.toffset = 0.0
            self.update_plots()
    elif event.key == &#39;down&#39;:
        if self.toffset + self.twindow &lt; self.tmax:
            self.toffset += 0.05 * self.twindow
            self.update_plots()
    elif event.key == &#39;up&#39;:
        if self.toffset &gt; 0.0:
            self.toffset -= 0.05 * self.twindow
            if self.toffset &lt; 0.0:
                self.toffset = 0.0
            self.update_plots()
    elif event.key == &#39;home&#39;:
        if self.toffset &gt; 0.0:
            self.toffset = 0.0
            self.update_plots()
    elif event.key == &#39;end&#39;:
        toffs = np.floor(self.tmax / self.twindow) * self.twindow
        if self.tmax - toffs &lt;= 0.0:
            toffs -= self.twindow
        if self.tmax - toffs &lt; self.twindow/2:
            toffs -= self.twindow/2
        if self.toffset &lt; toffs:
            self.toffset = toffs
            self.update_plots()
    elif event.key == &#39;y&#39;:
        for t in range(self.traces):
            h = self.ymax[t] - self.ymin[t]
            c = 0.5 * (self.ymax[t] + self.ymin[t])
            self.ymin[t] = c - h
            self.ymax[t] = c + h
            self.axs[t].set_ylim(self.ymin[t], self.ymax[t])
        self.fig.canvas.draw()
    elif event.key == &#39;Y&#39;:
        for t in range(self.traces):
            h = 0.25 * (self.ymax[t] - self.ymin[t])
            c = 0.5 * (self.ymax[t] + self.ymin[t])
            self.ymin[t] = c - h
            self.ymax[t] = c + h
            self.axs[t].set_ylim(self.ymin[t], self.ymax[t])
        self.fig.canvas.draw()
    elif event.key == &#39;v&#39;:
        t0 = int(np.round(self.toffset * self.rate))
        t1 = int(np.round((self.toffset + self.twindow) * self.rate))
        min = np.min(self.data[t0:t1,self.show_channels])
        max = np.max(self.data[t0:t1,self.show_channels])
        h = 0.53 * (max - min)
        c = 0.5 * (max + min)
        self.ymin[:] = c - h
        self.ymax[:] = c + h
        for t in range(self.traces):
            self.axs[t].set_ylim(self.ymin[t], self.ymax[t])
        self.fig.canvas.draw()
    elif event.key == &#39;ctrl+v&#39;:
        t0 = int(np.round(self.toffset * self.rate))
        t1 = int(np.round((self.toffset + self.twindow) * self.rate))
        for t in range(self.traces):
            min = np.min(self.data[t0:t1,self.show_channels[t]])
            max = np.max(self.data[t0:t1,self.show_channels[t]])
            h = 0.53 * (max - min)
            c = 0.5 * (max + min)
            self.ymin[t] = c - h
            self.ymax[t] = c + h
            self.axs[t].set_ylim(self.ymin[t], self.ymax[t])
        self.fig.canvas.draw()
    elif event.key == &#39;ctrl+V&#39;:
        for t in range(self.traces):
            min = np.min(self.data[:,self.show_channels[t]])
            max = np.max(self.data[:,self.show_channels[t]])
            h = 0.53 * (max - min)
            c = 0.5 * (max + min)
            self.ymin[t] = c - h
            self.ymax[t] = c + h
            self.axs[t].set_ylim(self.ymin[t], self.ymax[t])
        self.fig.canvas.draw()
    elif event.key == &#39;V&#39;:
        self.ymin[:] = -1.0
        self.ymax[:] = +1.0
        for t in range(self.traces):
            self.axs[t].set_ylim(self.ymin[t], self.ymax[t])
        self.fig.canvas.draw()
    elif event.key == &#39;c&#39;:
        for t in range(self.traces):
            dy = self.ymax[t] - self.ymin[t]
            self.ymin[t] = -dy/2
            self.ymax[t] = +dy/2
            self.axs[t].set_ylim(self.ymin[t], self.ymax[t])
        self.fig.canvas.draw()
    elif event.key == &#39;g&#39;:
        self.show_gid = not self.show_gid
        self.plot_pulses(self.axs, False)
        self.fig.canvas.draw()
    elif event.key == &#39;i&#39;:
        if len(self.pulses) &gt; 0:
            self.fmax *= 2
            self.axs[-1].set_ylim(0.0, self.fmax)
            self.fig.canvas.draw()
    elif event.key == &#39;I&#39;:
        if len(self.pulses) &gt; 0:
            self.fmax /= 2
            self.axs[-1].set_ylim(0.0, self.fmax)
            self.fig.canvas.draw()
    elif event.key in [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;]:
        cc = int(event.key)
        # TODO: this is not yet what we want:
        &#34;&#34;&#34;
        if cc &lt; self.channels:
            self.axs[cc].set_visible(not self.axs[cc].get_visible())
        self.fig.canvas.draw()
        &#34;&#34;&#34;
    elif event.key in &#39;h&#39;:
        self.help = not self.help
        for ht in self.helptext:
            ht.set_visible(self.help)
        self.fig.canvas.draw()
    elif event.key in &#39;p&#39;:
        self.play_segment()
    elif event.key in &#39;P&#39;:
        self.play_all()
    elif event.key in &#39;S&#39;:
        self.save_segment()
    elif event.key in &#39;w&#39;:
        self.plot_traces()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="thunderfish.thunderbrowse.SignalPlot.play_segment"><code class="name flex">
<span>def <span class="ident">play_segment</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def play_segment(self):
    t0 = int(np.round(self.toffset * self.rate))
    t1 = int(np.round((self.toffset + self.twindow) * self.rate))
    playdata = 1.0 * np.mean(self.data[t0:t1,self.show_channels], 1)
    f = 0.1 if self.twindow &gt; 0.5 else 0.1*self.twindow
    fade(playdata, self.rate, f)
    self.audio.play(playdata, self.rate, blocking=False)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="thunderfish.thunderbrowse.SignalPlot.play_all"><code class="name flex">
<span>def <span class="ident">play_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def play_all(self):
    self.audio.play(np.mean(self.data[:,self.show_channels], 1),
                    self.rate, blocking=False)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="thunderfish.thunderbrowse.SignalPlot.save_segment"><code class="name flex">
<span>def <span class="ident">save_segment</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_segment(self):
    t0s = int(np.round(self.toffset))
    t1s = int(np.round(self.toffset + self.twindow))
    t0 = int(np.round(self.toffset * self.rate))
    t1 = int(np.round((self.toffset + self.twindow) * self.rate))
    filename = self.filename.split(&#39;.&#39;)[0]
    if self.traces == self.channels:
        segment_filename = f&#39;{filename}-{t0s:.4g}s-{t1s:.4g}s.wav&#39;
        write_audio(segment_filename, self.data[t0:t1,:], self.rate)
    else:
        segment_filename = f&#39;{filename}-{t0s:.4g}s-{t1s:.4g}s-c{self.show_channels[0]}.wav&#39;
        write_audio(segment_filename,
                    self.data[t0:t1,self.show_channels], self.rate)
    print(&#39;saved segment to: &#39; , segment_filename)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="thunderfish.thunderbrowse.SignalPlot.plot_traces"><code class="name flex">
<span>def <span class="ident">plot_traces</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_traces(self):
    splts = self.traces
    if len(self.pulses) &gt; 0:
        splts += 1
    fig, axs = plt.subplots(splts, 1, squeeze=False, sharex=True,
                            figsize=(15, 9))
    axs = axs.flat
    fig.subplots_adjust(left=0.06, right=0.99, bottom=0.05, top=0.97,
                        hspace=0)
    name = self.filename.split(&#39;.&#39;)[0]
    figfile = f&#39;{name}-{self.toffset:.4g}s-traces.png&#39;
    if self.traces &lt; self.channels:
        figfile = f&#39;{name}-{self.toffset:.4g}s-c{self.show_channels[0]}-traces.png&#39;
    axs[0].set_title(self.filename)
    t0 = int(np.round(self.toffset * self.rate))
    t1 = int(np.round((self.toffset + self.twindow) * self.rate))
    if t1&gt;len(self.data):
        t1 = len(self.data)
    time = np.arange(t0, t1)/self.rate
    if self.toffset &lt; 1.0 and self.twindow &lt; 1.0:
        axs[-1].set_xlabel(&#39;Time [ms]&#39;)
        for t in range(self.traces):
            c = self.show_channels[t]
            axs[t].set_xlim(1000.0 * self.toffset,
                            1000.0 * (self.toffset + self.twindow))
            axs[t].plot(1000.0 * time, self.data[t0:t1,c])
        self.plot_pulses(axs, True, 1000.0)
    else:
        axs[-1].set_xlabel(&#39;Time [s]&#39;)
        for t in range(self.traces):
            c = self.show_channels[t]
            axs[t].set_xlim(self.toffset, self.toffset + self.twindow)
            axs[t].plot(time, self.data[t0:t1,c])
        self.plot_pulses(axs, True, 1.0)
    for t in range(self.traces):
        c = self.show_channels[t]
        axs[t].set_ylim(self.ymin[t], self.ymax[t])
        axs[t].set_ylabel(f&#39;C-{c+1} [{self.unit}]&#39;)
    if len(self.pulses) &gt; 0:
        axs[-1].set_ylabel(&#39;IP freq [Hz]&#39;)
        axs[-1].set_ylim(0.0, self.fmax)
    #for t in range(self.traces-1):
    #    axs[t].xaxis.set_major_formatter(plt.NullFormatter())
    fig.savefig(figfile, dpi=200)
    plt.close(fig)
    print(&#39;saved waveform figure to&#39;, figfile)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="thunderfish" href="index.html">thunderfish</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="thunderfish.thunderbrowse.short_user_warning" href="#thunderfish.thunderbrowse.short_user_warning">short_user_warning</a></code></li>
<li><code><a title="thunderfish.thunderbrowse.main" href="#thunderfish.thunderbrowse.main">main</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="thunderfish.thunderbrowse.SignalPlot" href="#thunderfish.thunderbrowse.SignalPlot">SignalPlot</a></code></h4>
<ul class="two-column">
<li><code><a title="thunderfish.thunderbrowse.SignalPlot.plot_pulses" href="#thunderfish.thunderbrowse.SignalPlot.plot_pulses">plot_pulses</a></code></li>
<li><code><a title="thunderfish.thunderbrowse.SignalPlot.update_plots" href="#thunderfish.thunderbrowse.SignalPlot.update_plots">update_plots</a></code></li>
<li><code><a title="thunderfish.thunderbrowse.SignalPlot.on_pick" href="#thunderfish.thunderbrowse.SignalPlot.on_pick">on_pick</a></code></li>
<li><code><a title="thunderfish.thunderbrowse.SignalPlot.resize" href="#thunderfish.thunderbrowse.SignalPlot.resize">resize</a></code></li>
<li><code><a title="thunderfish.thunderbrowse.SignalPlot.keypress" href="#thunderfish.thunderbrowse.SignalPlot.keypress">keypress</a></code></li>
<li><code><a title="thunderfish.thunderbrowse.SignalPlot.play_segment" href="#thunderfish.thunderbrowse.SignalPlot.play_segment">play_segment</a></code></li>
<li><code><a title="thunderfish.thunderbrowse.SignalPlot.play_all" href="#thunderfish.thunderbrowse.SignalPlot.play_all">play_all</a></code></li>
<li><code><a title="thunderfish.thunderbrowse.SignalPlot.save_segment" href="#thunderfish.thunderbrowse.SignalPlot.save_segment">save_segment</a></code></li>
<li><code><a title="thunderfish.thunderbrowse.SignalPlot.plot_traces" href="#thunderfish.thunderbrowse.SignalPlot.plot_traces">plot_traces</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
