<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>thunderfish.thunderfish API documentation</title>
<meta name="description" content="thunderfish â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>thunderfish.thunderfish</code></h1>
</header>
<section id="section-intro">
<h1 id="thunderfish">thunderfish</h1>
<p>Automatically detect and analyze all EOD waveforms in short recordings
and generated summary plots and data tables.</p>
<p>Run it from the thunderfish development directory as:</p>
<pre><code class="language-sh">&gt; python3 -m thunderfish.thunderfish audiofile.wav
</code></pre>
<p>Or install thunderfish</p>
<pre><code class="language-sh">&gt; sudo pip3 install .
</code></pre>
<p>Then you can run it directly from every directory:</p>
<pre><code class="language-sh">&gt; thunderfish audiofile.wav
</code></pre>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="thunderfish.thunderfish.trace_color"><code class="name">var <span class="ident">trace_color</span></code></dt>
<dd>
<div class="desc"><p>Default color for traces.</p></div>
</dd>
<dt id="thunderfish.thunderfish.data_color"><code class="name">var <span class="ident">data_color</span></code></dt>
<dd>
<div class="desc"><p>Default color for the full data trace.</p></div>
</dd>
<dt id="thunderfish.thunderfish.fit_color"><code class="name">var <span class="ident">fit_color</span></code></dt>
<dd>
<div class="desc"><p>Default color for fits.</p></div>
</dd>
<dt id="thunderfish.thunderfish.spectrum_color"><code class="name">var <span class="ident">spectrum_color</span></code></dt>
<dd>
<div class="desc"><p>Default color for power spectra.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="thunderfish.thunderfish.configuration"><code class="name flex">
<span>def <span class="ident">configuration</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configuration():
    &#34;&#34;&#34;Assemble configuration parameter for thunderfish.

    Returns
    -------
    cfg: ConfigFile
        Configuration parameters.
    &#34;&#34;&#34;
    cfg = ConfigFile()
    add_multi_psd_config(cfg)
    cfg.add(&#39;frequencyThreshold&#39;, 1.0, &#39;Hz&#39;,
            &#39;The fundamental frequency of each fish needs to be detected in each power spectrum within this threshold.&#39;)
    # TODO: make this threshold dependent on frequency resolution!
    cfg.add(&#39;minPSDAverages&#39;, 3, &#39;&#39;, &#39;Minimum number of fft averages for estimating the power spectrum.&#39;)  # needed by fishfinder
    add_psd_peak_detection_config(cfg)
    add_harmonic_groups_config(cfg)
    add_clip_config(cfg)
    cfg.add(&#39;unwrapData&#39;, False, &#39;&#39;, &#39;Unwrap clipped voltage traces.&#39;)
    add_best_window_config(cfg, win_size=8.0, w_cv_ampl=10.0)
    add_check_pulse_config(cfg)
    add_eod_analysis_config(cfg, min_pulse_win=0.004)
    del cfg[&#39;eodSnippetFac&#39;]
    del cfg[&#39;eodMinSnippet&#39;]
    del cfg[&#39;eodMinSem&#39;]
    add_eod_quality_config(cfg)
    add_species_config(cfg)
    add_write_table_config(cfg, table_format=&#39;csv&#39;, unit_style=&#39;row&#39;,
                           align_columns=True, shrink_width=False)
    return cfg</code></pre>
</details>
<div class="desc"><p>Assemble configuration parameter for thunderfish.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cfg</code></strong> :&ensp;<code>ConfigFile</code></dt>
<dd>Configuration parameters.</dd>
</dl></div>
</dd>
<dt id="thunderfish.thunderfish.save_configuration"><code class="name flex">
<span>def <span class="ident">save_configuration</span></span>(<span>cfg, config_file)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_configuration(cfg, config_file):
    &#34;&#34;&#34;Save configuration parameter for thunderfish to a file.

    Parameters
    ----------
    cfg: ConfigFile
        Configuration parameters and their values.
    config_file: string
        Name of the configuration file to be loaded.
    &#34;&#34;&#34;
    ext = os.path.splitext(config_file)[1]
    if ext != os.extsep + &#39;cfg&#39;:
        print(&#39;configuration file name must have .cfg as extension!&#39;)
    else:
        print(&#39;write configuration to %s ...&#39; % config_file)
        del cfg[&#39;fileColumnNumbers&#39;]
        del cfg[&#39;fileShrinkColumnWidth&#39;]
        del cfg[&#39;fileMissing&#39;]
        del cfg[&#39;fileLaTeXLabelCommand&#39;]
        del cfg[&#39;fileLaTeXMergeStd&#39;]
        cfg.dump(config_file)</code></pre>
</details>
<div class="desc"><p>Save configuration parameter for thunderfish to a file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cfg</code></strong> :&ensp;<code>ConfigFile</code></dt>
<dd>Configuration parameters and their values.</dd>
<dt><strong><code>config_file</code></strong> :&ensp;<code>string</code></dt>
<dd>Name of the configuration file to be loaded.</dd>
</dl></div>
</dd>
<dt id="thunderfish.thunderfish.detect_eods"><code class="name flex">
<span>def <span class="ident">detect_eods</span></span>(<span>data, rate, min_clip, max_clip, name, mode, verbose, plot_level, cfg)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detect_eods(data, rate, min_clip, max_clip, name, mode,
                verbose, plot_level, cfg):
    &#34;&#34;&#34;Detect EODs of all fish present in the data.

    Parameters
    ----------
    data: array of floats
        The recording in which to detect EODs.
    rate: float
        Sampling rate of the dataset.
    min_clip: float
        Minimum amplitude that is not clipped.
    max_clip: float
        Maximum amplitude that is not clipped.
    name: string
        Name of the recording (e.g. its filename).
    mode: string
        Characters in the string indicate what and how to analyze:
        - &#39;w&#39;: analyze wavefish
        - &#39;p&#39;: analyze pulsefish
        - &#39;P&#39;: analyze only the pulsefish with the largest amplitude (not implemented yet) 
    verbose: int
        Print out information about EOD detection if greater than zero.
    plot_level : int
        Similar to verbosity levels, but with plots. 
    cfg: ConfigFile
        Configuration parameters.

    Returns
    -------
    psd_data: list of 2D arrays
        List of power spectra (frequencies and power) of the analysed data
        for different frequency resolutions.
    wave_eodfs: list of 2D arrays
        Frequency and power of fundamental frequency/harmonics of all wave fish.
    wave_indices: array of int
        Indices of wave fish mapping from wave_eodfs to eod_props.
        If negative, then that EOD frequency has no waveform described in eod_props.
    eod_props: list of dict
        Lists of EOD properties as returned by analyze_pulse() and analyze_wave()
        for each waveform in mean_eods.
    mean_eods: list of 2-D arrays with time, mean, sem, and fit.
        Averaged EOD waveforms of pulse and wave fish.
    spec_data: list of 2_D arrays
        For each pulsefish a power spectrum of the single pulse and for
        each wavefish the relative amplitudes and phases of the harmonics.
    peak_data: list of 2_D arrays
        For each pulse fish a list of peak properties
        (index, time, and amplitude), empty array for wave fish.
    power_thresh:  2 D array or None
        Frequency (first column) and power (second column) of threshold
        derived from single pulse spectra to discard false wave fish.
        None if no pulse fish was detected.
    skip_reason: list of string
        Reasons, why an EOD was discarded.
    &#34;&#34;&#34;
    dfreq = np.nan
    nfft = 0
    psd_data = [[]]
    wave_eodfs = []
    wave_indices = []
    if &#39;w&#39; in mode:
        # detect wave fish:
        psd_data = multi_psd(data, rate, **multi_psd_args(cfg))
        dfreq = np.mean(np.diff(psd_data[0][:,0]))
        nfft = int(rate/dfreq)
        h_kwargs = psd_peak_detection_args(cfg)
        h_kwargs.update(harmonic_groups_args(cfg))
        wave_eodfs_list = []
        for i, psd in enumerate(psd_data):
            wave_eodfs = harmonic_groups(psd[:,0], psd[:,1], verbose-1, **h_kwargs)[0]
            if verbose &gt; 0 and len(psd_data) &gt; 1:
                numpsdresolutions = cfg.value(&#39;numberPSDResolutions&#39;)
                print(&#39;fundamental frequencies detected in power spectrum of window %d at resolution %d:&#39;
                      % (i//numpsdresolutions, i%numpsdresolutions))
                if len(wave_eodfs) &gt; 0:
                    print(&#39;  &#39; + &#39; &#39;.join([&#39;%.1f&#39; % freq[0, 0] for freq in wave_eodfs]))
                else:
                    print(&#39;  none&#39;)
            wave_eodfs_list.append(wave_eodfs)
        wave_eodfs = consistent_fishes(wave_eodfs_list,
                                       df_th=cfg.value(&#39;frequencyThreshold&#39;))
        if verbose &gt; 0:
            if len(wave_eodfs) &gt; 0:
                print(&#39;found %2d EOD frequencies consistent in all power spectra:&#39; % len(wave_eodfs))
                print(&#39;  &#39; + &#39; &#39;.join([&#39;%.1f&#39; % freq[0, 0] for freq in wave_eodfs]))
            else:
                print(&#39;no fundamental frequencies are consistent in all power spectra&#39;)

    # analysis results:
    eod_props = []
    mean_eods = []
    spec_data = []
    peak_data = []
    power_thresh = None
    skip_reason = []
    max_pulse_amplitude = 0.0
    zoom_window = []

    if &#39;p&#39; in mode:
        # detect pulse fish:
        _, eod_times, eod_peaktimes, zoom_window, _ = \
            extract_pulsefish(data, rate, max_clip, verbose=verbose-1,
                              plot_level=plot_level,
                              save_path=os.path.splitext(os.path.basename(name))[0])

        #eod_times = []
        #eod_peaktimes = []
        if verbose &gt; 0:
            if len(eod_times) &gt; 0:
                print(&#39;found %2d pulsefish EODs&#39; % len(eod_times))
            else:
                print(&#39;no pulsefish EODs found&#39;)

        # analyse eod waveform of pulse-fish:
        min_freq_res = cfg.value(&#39;frequencyResolution&#39;)
        for k, (eod_ts, eod_pts) in enumerate(zip(eod_times, eod_peaktimes)):
            mean_eod, eod_times0 = \
                eod_waveform(data, rate, eod_ts, win_fac=0.8,
                             min_win=cfg.value(&#39;eodMinPulseSnippet&#39;),
                             min_sem=False, **eod_waveform_args(cfg))
            mean_eod, props, peaks, power = analyze_pulse(mean_eod, eod_times0,
                                                          freq_resolution=min_freq_res,
                                                          **analyze_pulse_args(cfg))
            if len(peaks) == 0:
                print(&#39;error: no peaks in pulse EOD detected&#39;)
                continue
            clipped_frac = clipped_fraction(data, rate, eod_times0,
                                            mean_eod, min_clip, max_clip)
            props[&#39;peaktimes&#39;] = eod_pts  # XXX that should go into analyze pulse
            props[&#39;index&#39;] = len(eod_props)
            props[&#39;clipped&#39;] = clipped_frac
            props[&#39;samplerate&#39;] = rate
            props[&#39;nfft&#39;] = nfft
            props[&#39;dfreq&#39;] = dfreq

            # add good waveforms only:
            skips, msg, skipped_clipped = pulse_quality(props, **pulse_quality_args(cfg))

            if len(skips) == 0:
                eod_props.append(props)
                mean_eods.append(mean_eod)
                spec_data.append(power)
                peak_data.append(peaks)
                if verbose &gt; 0:
                    print(&#39;take %6.1fHz pulse fish: %s&#39; % (props[&#39;EODf&#39;], msg))
            else:
                skip_reason += [&#39;%.1fHz pulse fish %s&#39; % (props[&#39;EODf&#39;], skips)]
                if verbose &gt; 0:
                    print(&#39;skip %6.1fHz pulse fish: %s (%s)&#39; %
                          (props[&#39;EODf&#39;], skips, msg))

            # threshold for wave fish peaks based on single pulse spectra:
            if len(skips) == 0 or skipped_clipped:
                if max_pulse_amplitude &lt; props[&#39;p-p-amplitude&#39;]:
                    max_pulse_amplitude = props[&#39;p-p-amplitude&#39;]
                i0 = np.argmin(np.abs(mean_eod[:,0]))
                i1 = len(mean_eod) - i0
                pulse_data = np.zeros(len(data))
                for t in props[&#39;peaktimes&#39;]:
                    idx = int(t*rate)
                    ii0 = i0 if idx-i0 &gt;= 0 else idx
                    ii1 = i1 if idx+i1 &lt; len(pulse_data) else len(pulse_data)-1-idx
                    pulse_data[idx-ii0:idx+ii1] = mean_eod[i0-ii0:i0+ii1,1]
                pulse_psd = multi_psd(pulse_data, rate, **multi_psd_args(cfg))
                pulse_power = pulse_psd[0][:,1]
                pulse_power *= len(data)/rate/props[&#39;period&#39;]/len(props[&#39;peaktimes&#39;])
                pulse_power *= 5.0
                if power_thresh is None:
                    power_thresh = pulse_psd[0]
                    power_thresh[:,1] = pulse_power
                else:
                    power_thresh[:,1] += pulse_power

        # remove wavefish below pulse fish power:
        if &#39;w&#39; in mode and power_thresh is not None:
            n = len(wave_eodfs)
            maxh = 3  # XXX make parameter
            df = power_thresh[1,0] - power_thresh[0,0]
            for k, fish in enumerate(reversed(wave_eodfs)):
                idx = np.array(fish[:maxh,0]//df, dtype=int)
                for offs in range(-2, 3):
                    nbelow = np.sum(fish[:maxh,1] &lt; power_thresh[idx+offs,1])
                    if nbelow &gt; 0:
                        wave_eodfs.pop(n-1-k)
                        if verbose &gt; 0:
                            print(&#39;skip %6.1fHz wave  fish: %2d harmonics are below pulsefish threshold&#39; % (fish[0,0], nbelow))
                        break

    if &#39;w&#39; in mode:
        # analyse EOD waveform of all wavefish:
        powers = np.array([np.sum(fish[:,1]) for fish in wave_eodfs])
        power_indices = np.argsort(-powers)
        wave_indices = np.zeros(len(wave_eodfs), dtype=int) - 3
        for k, idx in enumerate(power_indices):
            fish = wave_eodfs[idx]
            &#34;&#34;&#34;
            eod_times = np.arange(0.0, len(data)/rate, 1.0/fish[0,0])
            mean_eod, eod_times = \
                eod_waveform(data, rate, eod_times, win_fac=3.0, min_win=0.0,
                             min_sem=(k==0), **eod_waveform_args(cfg))
            &#34;&#34;&#34;
            mean_eod, eod_times = \
                waveeod_waveform(data, rate, fish[0, 0], win_fac=3.0,
                                 unfilter_cutoff=cfg.value(&#39;unfilterCutoff&#39;))
            if len(mean_eod) == 0:
                continue
            mean_eod, props, sdata, error_str = \
                analyze_wave(mean_eod, fish, **analyze_wave_args(cfg))
            if error_str:
                print(name + &#39;: &#39; + error_str)
            clipped_frac = clipped_fraction(data, rate, eod_times,
                                            mean_eod, min_clip, max_clip)
            props[&#39;n&#39;] = len(eod_times)
            props[&#39;index&#39;] = len(eod_props)
            props[&#39;clipped&#39;] = clipped_frac
            props[&#39;samplerate&#39;] = rate
            props[&#39;nfft&#39;] = nfft
            props[&#39;dfreq&#39;] = dfreq
            # remove wave fish that are smaller than the largest pulse fish:
            if props[&#39;p-p-amplitude&#39;] &lt; 0.01*max_pulse_amplitude:
                rm_indices = power_indices[k:]
                if verbose &gt; 0:
                    print(&#39;skip %6.1fHz wave  fish: power=%5.1fdB, p-p amplitude=%5.1fdB smaller than pulse fish=%5.1dB - 20dB&#39; %
                          (props[&#39;EODf&#39;], decibel(powers[idx]),
                           decibel(props[&#39;p-p-amplitude&#39;]), decibel(max_pulse_amplitude)))
                    for idx in rm_indices[1:]:
                        print(&#39;skip %6.1fHz wave  fish: power=%5.1fdB even smaller&#39; %
                              (wave_eodfs[idx][0,0], decibel(powers[idx])))
                wave_eodfs = [eodfs for idx, eodfs in enumerate(wave_eodfs)
                              if idx not in rm_indices]
                wave_indices = np.array([idcs for idx, idcs in enumerate(wave_indices)
                                        if idx not in rm_indices], dtype=int)
                break
            # add good waveforms only:
            remove, skips, msg = wave_quality(props, sdata[1:,3], **wave_quality_args(cfg))
            if len(skips) == 0:
                wave_indices[idx] = props[&#39;index&#39;]
                eod_props.append(props)
                mean_eods.append(mean_eod)
                spec_data.append(sdata)
                peak_data.append([])
                if verbose &gt; 0:
                    print(&#39;take   %6.1fHz wave  fish: %s&#39; % (props[&#39;EODf&#39;], msg))
            else:
                wave_indices[idx] = -2 if remove else -1
                skip_reason += [&#39;%.1fHz wave fish %s&#39; % (props[&#39;EODf&#39;], skips)]
                if verbose &gt; 0:
                    print(&#39;%-6s %6.1fHz wave  fish: %s (%s)&#39; %
                          (&#39;remove&#39; if remove else &#39;skip&#39;, props[&#39;EODf&#39;], skips, msg))
        wave_eodfs = [eodfs for idx, eodfs in zip(wave_indices, wave_eodfs) if idx &gt; -2]
        wave_indices = np.array([idx for idx in wave_indices if idx &gt; -2], dtype=int)
    return (psd_data, wave_eodfs, wave_indices, eod_props, mean_eods,
            spec_data, peak_data, power_thresh, skip_reason, zoom_window)</code></pre>
</details>
<div class="desc"><p>Detect EODs of all fish present in the data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>array</code> of <code>floats</code></dt>
<dd>The recording in which to detect EODs.</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Sampling rate of the dataset.</dd>
<dt><strong><code>min_clip</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum amplitude that is not clipped.</dd>
<dt><strong><code>max_clip</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum amplitude that is not clipped.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code></dt>
<dd>Name of the recording (e.g. its filename).</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>string</code></dt>
<dd>Characters in the string indicate what and how to analyze:
- 'w': analyze wavefish
- 'p': analyze pulsefish
- 'P': analyze only the pulsefish with the largest amplitude (not implemented yet)</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>int</code></dt>
<dd>Print out information about EOD detection if greater than zero.</dd>
<dt><strong><code>plot_level</code></strong> :&ensp;<code>int</code></dt>
<dd>Similar to verbosity levels, but with plots.</dd>
<dt><strong><code>cfg</code></strong> :&ensp;<code>ConfigFile</code></dt>
<dd>Configuration parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>psd_data</code></strong> :&ensp;<code>list</code> of <code>2D arrays</code></dt>
<dd>List of power spectra (frequencies and power) of the analysed data
for different frequency resolutions.</dd>
<dt><strong><code>wave_eodfs</code></strong> :&ensp;<code>list</code> of <code>2D arrays</code></dt>
<dd>Frequency and power of fundamental frequency/harmonics of all wave fish.</dd>
<dt><strong><code>wave_indices</code></strong> :&ensp;<code>array</code> of <code>int</code></dt>
<dd>Indices of wave fish mapping from wave_eodfs to eod_props.
If negative, then that EOD frequency has no waveform described in eod_props.</dd>
<dt><strong><code>eod_props</code></strong> :&ensp;<code>list</code> of <code>dict</code></dt>
<dd>Lists of EOD properties as returned by analyze_pulse() and analyze_wave()
for each waveform in mean_eods.</dd>
<dt>mean_eods: list of 2-D arrays with time, mean, sem, and fit.</dt>
<dt>Averaged EOD waveforms of pulse and wave fish.</dt>
<dt><strong><code>spec_data</code></strong> :&ensp;<code>list</code> of <code>2_D arrays</code></dt>
<dd>For each pulsefish a power spectrum of the single pulse and for
each wavefish the relative amplitudes and phases of the harmonics.</dd>
<dt><strong><code>peak_data</code></strong> :&ensp;<code>list</code> of <code>2_D arrays</code></dt>
<dd>For each pulse fish a list of peak properties
(index, time, and amplitude), empty array for wave fish.</dd>
<dt><strong><code>power_thresh</code></strong> :&ensp;<code> 2 D array</code> or <code>None</code></dt>
<dd>Frequency (first column) and power (second column) of threshold
derived from single pulse spectra to discard false wave fish.
None if no pulse fish was detected.</dd>
<dt><strong><code>skip_reason</code></strong> :&ensp;<code>list</code> of <code>string</code></dt>
<dd>Reasons, why an EOD was discarded.</dd>
</dl></div>
</dd>
<dt id="thunderfish.thunderfish.remove_eod_files"><code class="name flex">
<span>def <span class="ident">remove_eod_files</span></span>(<span>output_basename, verbose, cfg)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_eod_files(output_basename, verbose, cfg):
    &#34;&#34;&#34;Remove all files from previous runs of thunderfish
    &#34;&#34;&#34;
    ff = cfg.value(&#39;fileFormat&#39;)
    if ff == &#39;py&#39;:
        fext = &#39;py&#39;
    else:
        fext = TableData.extensions[ff]
    # remove all files from previous runs of thunderfish:
    for fn in glob.glob(&#39;%s*.%s&#39; % (output_basename, fext)):
        os.remove(fn)
        if verbose &gt; 0:
            print(&#39;removed file %s&#39; % fn)</code></pre>
</details>
<div class="desc"><p>Remove all files from previous runs of thunderfish</p></div>
</dd>
<dt id="thunderfish.thunderfish.plot_style"><code class="name flex">
<span>def <span class="ident">plot_style</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_style():
    &#34;&#34;&#34;Set style of plots.
    &#34;&#34;&#34;
    plt.rcParams[&#39;figure.facecolor&#39;] = &#39;white&#39;
    plt.rcParams[&#39;axes.facecolor&#39;] = &#39;none&#39;
    plt.rcParams[&#39;xtick.direction&#39;] = &#39;out&#39;
    plt.rcParams[&#39;ytick.direction&#39;] = &#39;out&#39;</code></pre>
</details>
<div class="desc"><p>Set style of plots.</p></div>
</dd>
<dt id="thunderfish.thunderfish.axes_style"><code class="name flex">
<span>def <span class="ident">axes_style</span></span>(<span>ax)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def axes_style(ax):
    &#34;&#34;&#34;Fix style of axes.

    Parameters
    ----------
    ax: matplotlib axes
    &#34;&#34;&#34;
    ax.spines[&#39;top&#39;].set_visible(False)
    ax.spines[&#39;right&#39;].set_visible(False)
    ax.get_xaxis().tick_bottom()
    ax.get_yaxis().tick_left()</code></pre>
</details>
<div class="desc"><p>Fix style of axes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib axes</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="thunderfish.thunderfish.plot_eods"><code class="name flex">
<span>def <span class="ident">plot_eods</span></span>(<span>base_name,<br>message_filename,<br>raw_data,<br>rate,<br>channel,<br>idx0,<br>idx1,<br>clipped,<br>psd_data,<br>wave_eodfs,<br>wave_indices,<br>mean_eods,<br>eod_props,<br>peak_data,<br>spec_data,<br>indices,<br>unit,<br>zoom_window,<br>n_snippets=10,<br>power_thresh=None,<br>label_power=True,<br>all_eods=False,<br>spec_plots='auto',<br>skip_bad=True,<br>log_freq=False,<br>min_freq=0.0,<br>max_freq=3000.0,<br>interactive=True,<br>verbose=0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_eods(base_name, message_filename,
              raw_data, rate, channel, idx0, idx1, clipped,
              psd_data, wave_eodfs, wave_indices, mean_eods, eod_props,
              peak_data, spec_data, indices, unit, zoom_window,
              n_snippets=10, power_thresh=None, label_power=True,
              all_eods=False, spec_plots=&#39;auto&#39;, skip_bad=True,
              log_freq=False, min_freq=0.0, max_freq=3000.0,
              interactive=True, verbose=0):
    &#34;&#34;&#34;Creates an output plot for the thunderfish program.

    This output contains the raw trace where the analysis window is
    marked, the power-spectrum of this analysis window where the
    detected fish are marked, plots of averaged EOD plots, and
    spectra of the EOD waveforms.

    Parameters
    ----------
    base_name: string
        Basename of audio_file.
    message_filename: string or None
        Path to meta-data message.
    raw_data: array
        Dataset.
    rate: float
        Sampling rate of the dataset.
    channel: int or None
        Channel of the recording to be put into the plot title.
        If None, do not write the channel into the title.
    idx0: float
        Index of the beginning of the analysis window in the dataset.
    idx1: float
        Index of the end of the analysis window in the dataset.
    clipped: float
        Fraction of clipped amplitudes.
    psd_data: 2D array
        Power spectrum (frequencies and power) of the analysed data.
    wave_eodfs: array
        Frequency and power of fundamental frequency/harmonics of several fish.
    wave_indices: array of int
        Indices of wave fish mapping from wave_eodfs to eod_props.
        If negative, then that EOD frequency has no waveform described in eod_props.
    mean_eods: list of 2-D arrays with time, mean and std.
        Mean trace for the mean EOD plot.
    eod_props: list of dict
        Properties for each waveform in mean_eods.
    peak_data: list of 2_D arrays
        For each pulsefish a list of peak properties
        (index, time, and amplitude).
    spec_data: list of 2_D arrays
        For each pulsefish a power spectrum of the single pulse and for
        each wavefish the relative amplitudes and phases of the harmonics.
    indices: list of int or None
        Indices of the fish in eod_props to be plotted.
        If None try to plot all.
    unit: string
        Unit of the trace and the mean EOD.
    n_snippets: int
        Number of EOD waveform snippets to be plotted. If zero do not plot any.
    power_thresh:  2 D array or None
        Frequency (first column) and power (second column) of threshold
        derived from single pulse spectra to discard false wave fish.
    label_power: boolean
        If `True` put the power in decibel in addition to the frequency
        into the legend.
    all_eods: bool
        Plot all EOD waveforms.
    spec_plots: bool or &#39;auto&#39;
        Plot amplitude spectra of EOD waveforms.
        If &#39;auto&#39;, plot them if there is a singel waveform only.
    skip_bad: bool
        Skip harmonic groups without index (entry in indices is negative).
    log_freq: boolean
        Logarithmic (True) or linear (False) frequency axis of power spectrum of recording.
    min_freq: float
        Limits of frequency axis of power spectrum of recording
        are set to `(min_freq, max_freq)` if `max_freq` is greater than zero
    max_freq: float
        Limits of frequency axis of power spectrum of recording
        are set to `(min_freq, max_freq)` and limits of power axis are computed
        from powers below max_freq if `max_freq` is greater than zero
    interactive: bool
        If True install some keyboard interaction.
    verbose: int
        Print out information about data to be plotted if greater than zero.

    Returns
    -------
    fig: plt.figure
        Figure with the plots.
    &#34;&#34;&#34;

    def keypress(event):
        if event.key in &#39;pP&#39;:
            if idx1 &gt; idx0:
                playdata = 1.0 * raw_data[idx0:idx1]
            else:
                playdata = 1.0 * raw_data[:]
            fade(playdata, rate, 0.1)
            play(playdata, rate, blocking=False)
        if event.key in &#39;mM&#39; and message_filename:
            # play voice message:
            msg, msg_rate = load_audio(message_filename)
            play(msg, msg_rate, blocking=False)

    def recording_format_coord(x, y):
        return &#39;full recording: x=%.3f s, y=%.3f&#39; % (x, y)

    def recordingzoom_format_coord(x, y):
        return &#39;recording zoom-in: x=%.3f s, y=%.3f&#39; % (x, y)
            
    def psd_format_coord(x, y):
        return &#39;power spectrum: x=%.1f Hz, y=%.1f dB&#39; % (x, y)

    def meaneod_format_coord(x, y):
        return &#39;mean EOD waveform: x=%.2f ms, y=%.3f&#39; % (x, y)

    def ampl_format_coord(x, y):
        return u&#39;amplitude spectrum: x=%.0f, y=%.2f&#39; % (x, y)

    def phase_format_coord(x, y):
        return u&#39;phase spectrum: x=%.0f, y=%.2f \u03c0&#39; % (x, y/np.pi)
            
    def pulsepsd_format_coord(x, y):
        return &#39;single pulse power spectrum: x=%.1f Hz, y=%.1f dB&#39; % (x, y)

    # count number of fish types to be plotted:
    if indices is None:
        indices = np.arange(len(eod_props))
    else:
        indices = np.array(indices, dtype=int)
    nwave = 0
    npulse = 0
    for idx in indices:
        if eod_props[idx][&#39;type&#39;] == &#39;pulse&#39;:
            npulse += 1
        elif eod_props[idx][&#39;type&#39;] == &#39;wave&#39;:
            nwave += 1
    neods = nwave + npulse

    if verbose &gt; 0:
        print(&#39;plot: %2d waveforms: %2d wave fish, %2d pulse fish and %2d EOD frequencies.&#39;
              % (len(indices), nwave, npulse, len(wave_eodfs)))

    # size and positions:
    if spec_plots == &#39;auto&#39;:
        spec_plots = len(indices) == 1
    large_plots = spec_plots or len(indices) &lt;= 2
    width = 14.0
    height = 10.0
    if all_eods and len(indices) &gt; 0:
        nrows = len(indices) if spec_plots else (len(indices)+1)//2
        if large_plots:
            height = 6.0 + 4.0*nrows
        else:
            height = 6.4 + 1.9*nrows
    leftx = 1.0/width
    midx = 0.5 + leftx
    fullwidth = 1.0-1.4/width
    halfwidth = 0.5-1.4/width
    pheight = 3.0/height
    
    # figure:
    plot_style()
    fig = plt.figure(figsize=(width, height))
    if interactive:
        fig.canvas.mpl_connect(&#39;key_press_event&#39;, keypress)
    
    # plot title:
    title = base_name
    if channel is not None:
        title += &#39; c%d&#39; % channel
    ax = fig.add_axes([0.2/width, 1.0-0.6/height, 1.0-0.4/width, 0.55/height])
    ax.text(0.0, 1.0, title, fontsize=22, va=&#39;top&#39;)
    ax.text(1.0, 1.0, &#39;thunderfish by Benda-Lab&#39;, fontsize=16, ha=&#39;right&#39;, va=&#39;top&#39;)
    ax.text(1.0, 0.0, &#39;version %s&#39; % __version__, fontsize=16, ha=&#39;right&#39;, va=&#39;bottom&#39;)
    ax.set_frame_on(False)
    ax.set_axis_off()
    ax.set_navigate(False)

    # layout of recording and psd plots:
    #force_both = True  # set to True for debugging pulse and wave detection
    force_both = False
    posy = 1.0 - 4.0/height
    axr = None
    axp = None
    legend_inside = True
    legendwidth = 2.2/width if label_power else 1.7/width
    if neods == 0:
        axr = fig.add_axes([leftx, posy, fullwidth, pheight])                    # top, wide
        if len(psd_data) &gt; 0:
            axp = fig.add_axes([leftx, 2.0/height, fullwidth, pheight])              # bottom, wide
    else:
        if npulse == 0 and nwave &gt; 2 and psd_data is not None and \
           len(psd_data) &gt; 0 and not force_both:
            axp = fig.add_axes([leftx, posy, fullwidth-legendwidth, pheight])    # top, wide
            legend_inside = False
        elif (npulse &gt; 0 or psd_data is None or len(psd_data) == 0) \
             and len(wave_eodfs) == 0 and not force_both:
            axr = fig.add_axes([leftx, posy, fullwidth, pheight])                # top, wide
        else:
            axr = fig.add_axes([leftx, posy, halfwidth, pheight])                # top left
            label_power = False
            legendwidth = 2.2/width
            axp = fig.add_axes([midx, posy, halfwidth, pheight])                 # top, right
        
    # best window data:
    data = raw_data[idx0:idx1] if idx1 &gt; idx0 else raw_data

    # plot recording
    pulse_colors, pulse_markers = colors_markers()
    pulse_colors = pulse_colors[3:]
    pulse_markers = pulse_markers[3:]
    if axr is not None:
        axes_style(axr)
        twidth = 0.1
        if len(indices) &gt; 0:
            if eod_props[indices[0]][&#39;type&#39;] == &#39;wave&#39;:
                twidth = 5.0/eod_props[indices[0]][&#39;EODf&#39;]
            else:
                if len(wave_eodfs) &gt; 0:
                    twidth = 3.0/eod_props[indices[0]][&#39;EODf&#39;]
                else:
                    twidth = 10.0/eod_props[indices[0]][&#39;EODf&#39;]
            twidth = (1+twidth//0.005)*0.005
        if data is not None and len(data) &gt; 0:
            plot_eod_recording(axr, data, rate, unit, twidth,
                               idx0/rate, trace_style)
            plot_pulse_eods(axr, data, rate,
                            zoom_window, twidth, eod_props,
                            idx0/rate, colors=pulse_colors,
                            markers=pulse_markers, frameon=True,
                            loc=&#39;upper right&#39;)
        if axr.get_legend() is not None:
            axr.get_legend().get_frame().set_color(&#39;white&#39;)
        axr.set_title(&#39;Recording&#39;, fontsize=14, y=1.05)
        axr.format_coord = recordingzoom_format_coord
    
    # plot psd
    wave_colors, wave_markers = colors_markers()
    if axp is not None:
        axes_style(axp)
        if power_thresh is not None:
            axp.plot(power_thresh[:,0], decibel(power_thresh[:,1]), &#39;#CCCCCC&#39;, lw=1)
        if len(wave_eodfs) &gt; 0:
            kwargs = {}
            if len(wave_eodfs) &gt; 1:
                title = &#39;%d EOD frequencies&#39; % len(wave_eodfs)
                kwargs = {&#39;title&#39;: title if len(wave_eodfs) &gt; 2 else None }
                if legend_inside:
                    kwargs.update({&#39;bbox_to_anchor&#39;: (1.05, 1.1),
                                   &#39;loc&#39;: &#39;upper right&#39;, &#39;legend_rows&#39;: 10,
                                   &#39;frameon&#39;: True})
                else:
                    kwargs.update({&#39;bbox_to_anchor&#39;: (1.02, 1.1),
                                   &#39;loc&#39;: &#39;upper left&#39;, &#39;legend_rows&#39;: 14,
                                   &#39;labelspacing&#39;: 0.6, &#39;frameon&#39;: False})
            plot_harmonic_groups(axp, wave_eodfs, wave_indices, max_groups=0,
                                 skip_bad=skip_bad,
                                 sort_by_freq=True, label_power=label_power,
                                 colors=wave_colors, markers=wave_markers,
                                 **kwargs)
            if legend_inside:
                axp.get_legend().get_frame().set_color(&#39;white&#39;)
        if psd_data is not None and len(psd_data) &gt; 0:
            plot_decibel_psd(axp, psd_data[:,0], psd_data[:,1],
                             log_freq=log_freq, min_freq=min_freq,
                             max_freq=max_freq, ymarg=5.0,
                             sstyle=spectrum_style)
        axp.yaxis.set_major_locator(ticker.MaxNLocator(6))
        if len(wave_eodfs) == 1:
            axp.get_legend().set_visible(False)
            label = &#39;%6.1f Hz&#39; % wave_eodfs[0][0, 0]
            axp.set_title(&#39;Powerspectrum: %s&#39; % label, y=1.05, fontsize=14)
        else:
            axp.set_title(&#39;Powerspectrum&#39;, y=1.05, fontsize=14)
        axp.format_coord = psd_format_coord

    # get fish labels from legends:
    if axp is not None:
        w, _ = axp.get_legend_handles_labels()
        eodf_labels = [wi.get_label().split()[0] for wi in w]
        legend_wave_eodfs = np.array([float(f) if f[0] != &#39;(&#39; else np.nan for f in eodf_labels])
    if axr is not None:
        p, _ = axr.get_legend_handles_labels()
        eodf_labels = [pi.get_label().split()[0] for pi in p]
        legend_pulse_eodfs = np.array([float(f) if f[0] != &#39;(&#39; else np.nan for f in eodf_labels])

    # layout:
    sheight = 1.4/height
    sstep = 1.6/height
    max_plots = len(indices)
    if not all_eods:
        if large_plots:
            max_plots = 1 if spec_plots else 2
        else:
            max_plots = 4
    if large_plots:
        pstep = pheight + 1.0/height
        ty = 1.08
        my = 1.10
        ny = 6
    else:
        posy -= 0.2/height
        pheight = 1.3/height
        pstep = 1.9/height
        ty = 1.10
        my = 1.16
        ny = 4
    posy -= pstep
            
    # sort indices by p-p amplitude:
    pp_ampls = [eod_props[idx][&#39;p-p-amplitude&#39;] for idx in indices]
    pp_indices = np.argsort(pp_ampls)[::-1]
        
    # plot EOD waveform and spectra:
    for k, idx in enumerate(indices[pp_indices]):
        if k &gt;= max_plots:
            break
        # plot EOD waveform:
        mean_eod = mean_eods[idx]
        props = eod_props[idx]
        peaks = peak_data[idx]
        lx = leftx if spec_plots or k%2 == 0 else midx
        ax = fig.add_axes([lx, posy, halfwidth, pheight])
        axes_style(ax)
        ax.yaxis.set_major_locator(ticker.MaxNLocator(ny))
        if len(indices) &gt; 1:
            ax.text(0.3, ty, &#39;{EODf:.1f} Hz {type} fish&#39;.format(**props),
                       transform=ax.transAxes, fontsize=14, zorder=20)
            mx = 0.25
        else:
            ax.text(-0.1, ty, &#39;{EODf:.1f} Hz {type} fish&#39;.format(**props),
                       transform=ax.transAxes, fontsize=14, zorder=20)
            ax.text(0.5, ty, &#39;Averaged EOD&#39;, ha=&#39;center&#39;,
                       transform=ax.transAxes, fontsize=14, zorder=20)
            mx = -0.14
        eodf = props[&#39;EODf&#39;]
        if props[&#39;type&#39;] == &#39;wave&#39;:
            if axp is not None:
                wk = np.nanargmin(np.abs(legend_wave_eodfs - eodf))
                ma = ml.Line2D([mx], [my], color=w[wk].get_color(), marker=w[wk].get_marker(),
                               markersize=w[wk].get_markersize(), mec=&#39;none&#39;, clip_on=False,
                               label=w[wk].get_label(), transform=ax.transAxes)
                ax.add_line(ma)
        else:
            if axr is not None and len(legend_pulse_eodfs) &gt; 0:
                pk = np.argmin(np.abs(legend_pulse_eodfs - eodf))
                ma = ml.Line2D([mx], [my], color=p[pk].get_color(), marker=p[pk].get_marker(),
                               markersize=p[pk].get_markersize(), mec=&#39;none&#39;, clip_on=False,
                               label=p[pk].get_label(), transform=ax.transAxes)
                ax.add_line(ma)
        plot_eod_waveform(ax, mean_eod, props, peaks, unit, **eod_styles)
        if props[&#39;type&#39;] == &#39;pulse&#39; and &#39;times&#39; in props:
            plot_eod_snippets(ax, data, rate, mean_eod[0,0], mean_eod[-1,0],
                              props[&#39;times&#39;], n_snippets, props[&#39;flipped&#39;],
                              snippet_style)
        if not large_plots and k &lt; max_plots-2:
            ax.set_xlabel(&#39;&#39;)
        ax.format_coord = meaneod_format_coord

        # plot spectra:
        if spec_plots:
            spec = spec_data[idx]
            if  props[&#39;type&#39;] == &#39;pulse&#39;:
                ax = fig.add_axes([midx, posy, halfwidth, pheight])
                axes_style(ax)
                plot_pulse_spectrum(ax, spec, props, **pulse_spec_styles)
                ax.set_title(&#39;Single pulse spectrum&#39;, fontsize=14, y=1.05)
                ax.format_coord = pulsepsd_format_coord
            else:
                axa = fig.add_axes([midx, posy+sstep, halfwidth, sheight])
                axes_style(axa)
                axp = fig.add_axes([midx, posy, halfwidth, sheight])
                axes_style(axp)
                plot_wave_spectrum(axa, axp, spec, props, unit,
                                   **wave_spec_styles)
                axa.set_title(&#39;Amplitude and phase spectrum&#39;, fontsize=14, y=1.05)
                axa.set_xticklabels([])
                axa.yaxis.set_major_locator(ticker.MaxNLocator(4))
                axa.format_coord = ampl_format_coord
                axp.format_coord = phase_format_coord

        if spec_plots or k%2 == 1:
            posy -= pstep

    # whole trace:
    ax = fig.add_axes([leftx, 0.6/height, fullwidth, 0.9/height])
    axes_style(ax)
    if raw_data is not None and len(raw_data) &gt; 0:
        plot_data_window(ax, raw_data, rate, unit, idx0, idx1, clipped,
                         **data_styles)
    ax.format_coord = recording_format_coord

    return fig</code></pre>
</details>
<div class="desc"><p>Creates an output plot for the thunderfish program.</p>
<p>This output contains the raw trace where the analysis window is
marked, the power-spectrum of this analysis window where the
detected fish are marked, plots of averaged EOD plots, and
spectra of the EOD waveforms.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>base_name</code></strong> :&ensp;<code>string</code></dt>
<dd>Basename of audio_file.</dd>
<dt><strong><code>message_filename</code></strong> :&ensp;<code>string</code> or <code>None</code></dt>
<dd>Path to meta-data message.</dd>
<dt><strong><code>raw_data</code></strong> :&ensp;<code>array</code></dt>
<dd>Dataset.</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Sampling rate of the dataset.</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>Channel of the recording to be put into the plot title.
If None, do not write the channel into the title.</dd>
<dt><strong><code>idx0</code></strong> :&ensp;<code>float</code></dt>
<dd>Index of the beginning of the analysis window in the dataset.</dd>
<dt><strong><code>idx1</code></strong> :&ensp;<code>float</code></dt>
<dd>Index of the end of the analysis window in the dataset.</dd>
<dt><strong><code>clipped</code></strong> :&ensp;<code>float</code></dt>
<dd>Fraction of clipped amplitudes.</dd>
<dt><strong><code>psd_data</code></strong> :&ensp;<code>2D array</code></dt>
<dd>Power spectrum (frequencies and power) of the analysed data.</dd>
<dt><strong><code>wave_eodfs</code></strong> :&ensp;<code>array</code></dt>
<dd>Frequency and power of fundamental frequency/harmonics of several fish.</dd>
<dt><strong><code>wave_indices</code></strong> :&ensp;<code>array</code> of <code>int</code></dt>
<dd>Indices of wave fish mapping from wave_eodfs to eod_props.
If negative, then that EOD frequency has no waveform described in eod_props.</dd>
<dt>mean_eods: list of 2-D arrays with time, mean and std.</dt>
<dt>Mean trace for the mean EOD plot.</dt>
<dt><strong><code>eod_props</code></strong> :&ensp;<code>list</code> of <code>dict</code></dt>
<dd>Properties for each waveform in mean_eods.</dd>
<dt><strong><code>peak_data</code></strong> :&ensp;<code>list</code> of <code>2_D arrays</code></dt>
<dd>For each pulsefish a list of peak properties
(index, time, and amplitude).</dd>
<dt><strong><code>spec_data</code></strong> :&ensp;<code>list</code> of <code>2_D arrays</code></dt>
<dd>For each pulsefish a power spectrum of the single pulse and for
each wavefish the relative amplitudes and phases of the harmonics.</dd>
<dt><strong><code>indices</code></strong> :&ensp;<code>list</code> of <code>int</code> or <code>None</code></dt>
<dd>Indices of the fish in eod_props to be plotted.
If None try to plot all.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>string</code></dt>
<dd>Unit of the trace and the mean EOD.</dd>
<dt><strong><code>n_snippets</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of EOD waveform snippets to be plotted. If zero do not plot any.</dd>
<dt><strong><code>power_thresh</code></strong> :&ensp;<code> 2 D array</code> or <code>None</code></dt>
<dd>Frequency (first column) and power (second column) of threshold
derived from single pulse spectra to discard false wave fish.</dd>
<dt><strong><code>label_power</code></strong> :&ensp;<code>boolean</code></dt>
<dd>If <code>True</code> put the power in decibel in addition to the frequency
into the legend.</dd>
<dt><strong><code>all_eods</code></strong> :&ensp;<code>bool</code></dt>
<dd>Plot all EOD waveforms.</dd>
<dt><strong><code>spec_plots</code></strong> :&ensp;<code>bool</code> or <code>'auto'</code></dt>
<dd>Plot amplitude spectra of EOD waveforms.
If 'auto', plot them if there is a singel waveform only.</dd>
<dt><strong><code>skip_bad</code></strong> :&ensp;<code>bool</code></dt>
<dd>Skip harmonic groups without index (entry in indices is negative).</dd>
<dt><strong><code>log_freq</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Logarithmic (True) or linear (False) frequency axis of power spectrum of recording.</dd>
<dt><strong><code>min_freq</code></strong> :&ensp;<code>float</code></dt>
<dd>Limits of frequency axis of power spectrum of recording
are set to <code>(min_freq, max_freq)</code> if <code>max_freq</code> is greater than zero</dd>
<dt><strong><code>max_freq</code></strong> :&ensp;<code>float</code></dt>
<dd>Limits of frequency axis of power spectrum of recording
are set to <code>(min_freq, max_freq)</code> and limits of power axis are computed
from powers below max_freq if <code>max_freq</code> is greater than zero</dd>
<dt><strong><code>interactive</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True install some keyboard interaction.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>int</code></dt>
<dd>Print out information about data to be plotted if greater than zero.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>plt.figure</code></dt>
<dd>Figure with the plots.</dd>
</dl></div>
</dd>
<dt id="thunderfish.thunderfish.plot_eod_subplots"><code class="name flex">
<span>def <span class="ident">plot_eod_subplots</span></span>(<span>base_name,<br>subplots,<br>raw_data,<br>rate,<br>idx0,<br>idx1,<br>clipped,<br>psd_data,<br>wave_eodfs,<br>wave_indices,<br>mean_eods,<br>eod_props,<br>peak_data,<br>spec_data,<br>unit,<br>zoom_window,<br>n_snippets=10,<br>power_thresh=None,<br>label_power=True,<br>skip_bad=True,<br>log_freq=False,<br>min_freq=0.0,<br>max_freq=3000.0,<br>save=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_eod_subplots(base_name, subplots, raw_data, rate, idx0, idx1,
                      clipped, psd_data, wave_eodfs, wave_indices, mean_eods,
                      eod_props, peak_data, spec_data, unit, zoom_window,
                      n_snippets=10, power_thresh=None, label_power=True,
                      skip_bad=True, log_freq=False,
                      min_freq=0.0, max_freq=3000.0, save=True):
    &#34;&#34;&#34;Plot time traces and spectra into separate windows or files.

    Parameters
    ----------
    base_name: string
        Basename of audio_file.
    subplots: string
        Specifies which subplots to plot:
        r) recording with best window, t) data trace with detected pulse fish,
        p) power spectrum with detected wave fish, w/W) mean EOD waveform,
        s/S) EOD spectrum, e/E) EOD waveform and spectra. With capital letters
        all fish are saved into a single pdf file, with small letters each fish
        is saved into a separate file.
    raw_data: array
        Dataset.
    rate: float
        Sampling rate of the dataset.
    idx0: float
        Index of the beginning of the analysis window in the dataset.
    idx1: float
        Index of the end of the analysis window in the dataset.
    clipped: float
        Fraction of clipped amplitudes.
    psd_data: 2D array
        Power spectrum (frequencies and power) of the analysed data.
    wave_eodfs: array
        Frequency and power of fundamental frequency/harmonics of several fish.
    wave_indices: array of int
        Indices of wave fish mapping from wave_eodfs to eod_props.
        If negative, then that EOD frequency has no waveform described in eod_props.
    mean_eods: list of 2-D arrays with time, mean and std.
        Mean trace for the mean EOD plot.
    eod_props: list of dict
        Properties for each waveform in mean_eods.
    peak_data: list of 2_D arrays
        For each pulsefish a list of peak properties
        (index, time, and amplitude).
    spec_data: list of 2_D arrays
        For each pulsefish a power spectrum of the single pulse and for
        each wavefish the relative amplitudes and phases of the harmonics.
    unit: string
        Unit of the trace and the mean EOD.
    n_snippets: int
        Number of EOD waveform snippets to be plotted. If zero do not plot any.
    power_thresh:  2 D array or None
        Frequency (first column) and power (second column) of threshold
        derived from single pulse spectra to discard false wave fish.
    label_power: boolean
        If `True` put the power in decibel in addition to the frequency
        into the legend.
    skip_bad: bool
        Skip harmonic groups without index (entry in indices is negative).
    log_freq: boolean
        Logarithmic (True) or linear (False) frequency axis of power spectrum of recording.
    min_freq: float
        Limits of frequency axis of power spectrum of recording
        are set to `(min_freq, max_freq)` if `max_freq` is greater than zero
    max_freq: float
        Limits of frequency axis of power spectrum of recording
        are set to `(min_freq, max_freq)` and limits of power axis are computed
        from powers below max_freq if `max_freq` is greater than zero
    save: bool
        If True save plots to files instead of showing them.
    &#34;&#34;&#34;
    plot_style()
    if &#39;r&#39; in subplots:
        fig, ax = plt.subplots(figsize=(10, 2))
        fig.subplots_adjust(left=0.07, right=0.99, bottom=0.22, top=0.95)
        plot_data_window(ax, raw_data, rate, unit, idx0, idx1, clipped,
                         **data_styles)
        ax.yaxis.set_major_locator(ticker.MaxNLocator(5))
        axes_style(ax)
        if save:
            fig.savefig(base_name + &#39;-recording.pdf&#39;)
    if &#39;t&#39; in subplots:
        fig, ax = plt.subplots(figsize=(10, 6))
        twidth = 0.1
        if len(eod_props) &gt; 0:
            if eod_props[0][&#39;type&#39;] == &#39;wave&#39;:
                twidth = 5.0/eod_props[0][&#39;EODf&#39;]
            else:
                if len(wave_eodfs) &gt; 0:
                    twidth = 3.0/eod_props[0][&#39;EODf&#39;]
                else:
                    twidth = 10.0/eod_props[0][&#39;EODf&#39;]
        twidth = (1+twidth//0.005)*0.005
        pulse_colors, pulse_markers = colors_markers()
        pulse_colors = pulse_colors[3:]
        pulse_markers = pulse_markers[3:]
        plot_eod_recording(ax, raw_data[idx0:idx1], rate, unit,
                           twidth, idx0/rate, trace_style)
        plot_pulse_eods(ax, raw_data[idx0:idx1], rate, zoom_window,
                        twidth, eod_props, idx0/rate,
                        colors=pulse_colors, markers=pulse_markers,
                        frameon=True, loc=&#39;upper right&#39;)
        if ax.get_legend() is not None:
            ax.get_legend().get_frame().set_color(&#39;white&#39;)
        axes_style(ax)
        if save:
            fig.savefig(base_name + &#39;-trace.pdf&#39;)
    if &#39;p&#39; in subplots:
        fig, ax = plt.subplots(figsize=(10, 5))
        fig.subplots_adjust(left=0.08, right=0.975, bottom=0.11, top=0.9)
        axes_style(ax)
        if power_thresh is not None:
            ax.plot(power_thresh[:,0], decibel(power_thresh[:,1]), &#39;#CCCCCC&#39;, lw=1)
        if len(wave_eodfs) &gt; 0:
            kwargs = {}
            if len(wave_eodfs) &gt; 1:
                title = &#39;%d EOD frequencies&#39; % len(wave_eodfs)
                kwargs = {&#39;title&#39;: title if len(wave_eodfs) &gt; 2 else None }
                if len(wave_eodfs) &gt; 2:
                    fig.subplots_adjust(left=0.08, right=0.78, bottom=0.11, top=0.9)
                    kwargs.update({&#39;bbox_to_anchor&#39;: (1.01, 1.1),
                                   &#39;loc&#39;: &#39;upper left&#39;, &#39;legend_rows&#39;: 14,
                                   &#39;labelspacing&#39;: 0.6})
                else:
                    kwargs.update({&#39;bbox_to_anchor&#39;: (1.05, 1.1),
                                   &#39;loc&#39;: &#39;upper right&#39;, &#39;legend_rows&#39;: 10})
            wave_colors, wave_markers = colors_markers()
            plot_harmonic_groups(ax, wave_eodfs, wave_indices, max_groups=0,
                                 skip_bad=skip_bad,
                                 sort_by_freq=True, label_power=label_power,
                                 colors=wave_colors, markers=wave_markers,
                                 frameon=False, **kwargs)
        plot_decibel_psd(ax, psd_data[:,0], psd_data[:,1], log_freq=log_freq,
                         min_freq=min_freq, max_freq=max_freq, ymarg=5.0,
                         sstyle=spectrum_style)
        ax.yaxis.set_major_locator(ticker.MaxNLocator(6))
        if len(wave_eodfs) == 1:
            ax.get_legend().set_visible(False)
            label = &#39;%6.1f Hz&#39; % wave_eodfs[0][0, 0]
            ax.set_title(&#39;Powerspectrum: %s&#39; % label, y=1.05)
        else:
            ax.set_title(&#39;Powerspectrum&#39;, y=1.05)
        if save:
            fig.savefig(base_name + &#39;-psd.pdf&#39;)
    if &#39;w&#39; in subplots or &#39;W&#39; in subplots:
        mpdf = None
        if &#39;W&#39; in subplots:
            mpdf = PdfPages(base_name + &#39;-waveforms.pdf&#39;)
        for meod, props, peaks in zip(mean_eods, eod_props, peak_data):
            if meod is None:
                continue
            fig, ax = plt.subplots(figsize=(5, 3))
            fig.subplots_adjust(left=0.18, right=0.98, bottom=0.15, top=0.9)
            if not props is None:
                ax.set_title(&#39;{index:d}: {EODf:.1f} Hz {type} fish&#39;.format(**props))
            plot_eod_waveform(ax, meod, props, peaks, unit, **eod_styles)
            data = raw_data[idx0:idx1] if idx1 &gt; idx0 else raw_data
            if not props is None and props[&#39;type&#39;] == &#39;pulse&#39; and \
               &#39;times&#39; in props:
                plot_eod_snippets(ax, data, rate, meod[0,0],
                                  meod[-1,0], props[&#39;times&#39;],
                                  n_snippets, False, snippet_style)
            ax.yaxis.set_major_locator(ticker.MaxNLocator(6))
            axes_style(ax)
            if mpdf is None:
                if save:
                    fig.savefig(base_name + &#39;-waveform-%d.pdf&#39; % props[&#39;index&#39;])
            else:
                mpdf.savefig(fig)
        if mpdf is not None:
            mpdf.close()
    if &#39;s&#39; in subplots or &#39;S&#39; in subplots:
        mpdf = None
        if &#39;S&#39; in subplots:
            mpdf = PdfPages(base_name + &#39;-spectrum.pdf&#39;)
        for props, peaks, spec in zip(eod_props, peak_data, spec_data):
            if spec is None:
                continue
            if props is not None and props[&#39;type&#39;] == &#39;pulse&#39;:
                fig, ax = plt.subplots(figsize=(5, 3.5))
                fig.subplots_adjust(left=0.15, right=0.967, bottom=0.16, top=0.88)
                axes_style(ax)
                ax.set_title(&#39;{index:d}: {EODf:.1f} Hz {type} fish&#39;.format(**props), y=1.07)
                plot_pulse_spectrum(ax, spec, props, **pulse_spec_styles)
            else:
                fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(5, 3.5))
                fig.subplots_adjust(left=0.15, right=0.97, bottom=0.16, top=0.88, hspace=0.4)
                axes_style(ax1)
                axes_style(ax2)
                if not props is None:
                    ax1.set_title(&#39;{index:d}: {EODf:.1f} Hz {type} fish&#39;.format(**props), y=1.15)
                plot_wave_spectrum(ax1, ax2, spec, props, unit,
                                   **wave_spec_styles)
                ax1.set_xticklabels([])
                ax1.yaxis.set_major_locator(ticker.MaxNLocator(4))
            if mpdf is None:
                if save:
                    fig.savefig(base_name + &#39;-spectrum-%d.pdf&#39; % props[&#39;index&#39;])
            else:
                mpdf.savefig(fig)
        if mpdf is not None:
            mpdf.close()
    if &#39;e&#39; in subplots or &#39;E&#39; in subplots:
        mpdf = None
        if &#39;E&#39; in subplots:
            mpdf = PdfPages(base_name + &#39;-eods.pdf&#39;)
        for meod, props, peaks, spec in zip(mean_eods, eod_props, peak_data, spec_data):
            if meod is None or spec is None:
                continue
            fig = plt.figure(figsize=(10, 3.5))
            gs = gridspec.GridSpec(nrows=2, ncols=2, left=0.09, right=0.98,
                                   bottom=0.16, top=0.88, wspace=0.4, hspace=0.4)
            ax1 = fig.add_subplot(gs[:,0])
            if not props is None:
                ax1.set_title(&#39;{index:d}: {EODf:.1f} Hz {type} fish&#39;.format(**props), y=1.07)
            plot_eod_waveform(ax1, meod, props, peaks, unit, **eod_styles)
            data = raw_data[idx0:idx1] if idx1 &gt; idx0 else raw_data
            if not props is None and props[&#39;type&#39;] == &#39;pulse&#39; and &#39;times&#39; in props:
                plot_eod_snippets(ax1, data, rate, meod[0,0],
                                  meod[-1,0], props[&#39;times&#39;],
                                  n_snippets, False, snippet_style)
            ax1.yaxis.set_major_locator(ticker.MaxNLocator(6))
            axes_style(ax1)
            if not props is None and props[&#39;type&#39;] == &#39;pulse&#39;:
                ax2 = fig.add_subplot(gs[:,1])
                axes_style(ax2)
                plot_pulse_spectrum(ax2, spec, props, **pulse_spec_styles)
                ax2.set_title(&#39;Single pulse spectrum&#39;, y=1.07)
            else:
                ax2 = fig.add_subplot(gs[0,1])
                ax3 = fig.add_subplot(gs[1,1])
                axes_style(ax2)
                axes_style(ax3)
                plot_wave_spectrum(ax2, ax3, spec, props, unit,
                                   **wave_spec_styles)
                ax2.set_title(&#39;Amplitude and phase spectrum&#39;, y=1.15)
                ax2.set_xticklabels([])
                ax2.yaxis.set_major_locator(ticker.MaxNLocator(4))
            if mpdf is None:
                if save:
                    fig.savefig(base_name + &#39;-eod-%d.pdf&#39; % props[&#39;index&#39;])
            else:
                mpdf.savefig(fig)
        if mpdf is not None:
            mpdf.close()
    if not save:
        plt.show()
    plt.close(&#39;all&#39;)</code></pre>
</details>
<div class="desc"><p>Plot time traces and spectra into separate windows or files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>base_name</code></strong> :&ensp;<code>string</code></dt>
<dd>Basename of audio_file.</dd>
<dt><strong><code>subplots</code></strong> :&ensp;<code>string</code></dt>
<dd>Specifies which subplots to plot:
r) recording with best window, t) data trace with detected pulse fish,
p) power spectrum with detected wave fish, w/W) mean EOD waveform,
s/S) EOD spectrum, e/E) EOD waveform and spectra. With capital letters
all fish are saved into a single pdf file, with small letters each fish
is saved into a separate file.</dd>
<dt><strong><code>raw_data</code></strong> :&ensp;<code>array</code></dt>
<dd>Dataset.</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Sampling rate of the dataset.</dd>
<dt><strong><code>idx0</code></strong> :&ensp;<code>float</code></dt>
<dd>Index of the beginning of the analysis window in the dataset.</dd>
<dt><strong><code>idx1</code></strong> :&ensp;<code>float</code></dt>
<dd>Index of the end of the analysis window in the dataset.</dd>
<dt><strong><code>clipped</code></strong> :&ensp;<code>float</code></dt>
<dd>Fraction of clipped amplitudes.</dd>
<dt><strong><code>psd_data</code></strong> :&ensp;<code>2D array</code></dt>
<dd>Power spectrum (frequencies and power) of the analysed data.</dd>
<dt><strong><code>wave_eodfs</code></strong> :&ensp;<code>array</code></dt>
<dd>Frequency and power of fundamental frequency/harmonics of several fish.</dd>
<dt><strong><code>wave_indices</code></strong> :&ensp;<code>array</code> of <code>int</code></dt>
<dd>Indices of wave fish mapping from wave_eodfs to eod_props.
If negative, then that EOD frequency has no waveform described in eod_props.</dd>
<dt>mean_eods: list of 2-D arrays with time, mean and std.</dt>
<dt>Mean trace for the mean EOD plot.</dt>
<dt><strong><code>eod_props</code></strong> :&ensp;<code>list</code> of <code>dict</code></dt>
<dd>Properties for each waveform in mean_eods.</dd>
<dt><strong><code>peak_data</code></strong> :&ensp;<code>list</code> of <code>2_D arrays</code></dt>
<dd>For each pulsefish a list of peak properties
(index, time, and amplitude).</dd>
<dt><strong><code>spec_data</code></strong> :&ensp;<code>list</code> of <code>2_D arrays</code></dt>
<dd>For each pulsefish a power spectrum of the single pulse and for
each wavefish the relative amplitudes and phases of the harmonics.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>string</code></dt>
<dd>Unit of the trace and the mean EOD.</dd>
<dt><strong><code>n_snippets</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of EOD waveform snippets to be plotted. If zero do not plot any.</dd>
<dt><strong><code>power_thresh</code></strong> :&ensp;<code> 2 D array</code> or <code>None</code></dt>
<dd>Frequency (first column) and power (second column) of threshold
derived from single pulse spectra to discard false wave fish.</dd>
<dt><strong><code>label_power</code></strong> :&ensp;<code>boolean</code></dt>
<dd>If <code>True</code> put the power in decibel in addition to the frequency
into the legend.</dd>
<dt><strong><code>skip_bad</code></strong> :&ensp;<code>bool</code></dt>
<dd>Skip harmonic groups without index (entry in indices is negative).</dd>
<dt><strong><code>log_freq</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Logarithmic (True) or linear (False) frequency axis of power spectrum of recording.</dd>
<dt><strong><code>min_freq</code></strong> :&ensp;<code>float</code></dt>
<dd>Limits of frequency axis of power spectrum of recording
are set to <code>(min_freq, max_freq)</code> if <code>max_freq</code> is greater than zero</dd>
<dt><strong><code>max_freq</code></strong> :&ensp;<code>float</code></dt>
<dd>Limits of frequency axis of power spectrum of recording
are set to <code>(min_freq, max_freq)</code> and limits of power axis are computed
from powers below max_freq if <code>max_freq</code> is greater than zero</dd>
<dt><strong><code>save</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True save plots to files instead of showing them.</dd>
</dl></div>
</dd>
<dt id="thunderfish.thunderfish.thunderfish_plot"><code class="name flex">
<span>def <span class="ident">thunderfish_plot</span></span>(<span>files,<br>data_path=None,<br>load_kwargs={},<br>all_eods=False,<br>spec_plots='auto',<br>skip_bad=True,<br>save_plot=False,<br>multi_pdf=None,<br>save_subplots='',<br>log_freq=False,<br>min_freq=0.0,<br>max_freq=3000.0,<br>output_folder='.',<br>keep_path=False,<br>verbose=0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def thunderfish_plot(files, data_path=None, load_kwargs={},
                     all_eods=False, spec_plots=&#39;auto&#39;, skip_bad=True,
                     save_plot=False, multi_pdf=None,
                     save_subplots=&#39;&#39;, log_freq=False, min_freq=0.0,
                     max_freq=3000.0, output_folder=&#39;.&#39;,
                     keep_path=False, verbose=0):
    &#34;&#34;&#34;Generate plots from saved analysis results.

    Parameters
    ----------
    files: list of str
        Analysis files from a single recording.
    data_path: str
        Path where to find the raw data.
    load_kwargs: dict
        Key-word arguments for the `load_data()` function.
    all_eods: bool
        If True, plot all EOD waveforms.
    spec_plots: bool or &#39;auto&#39;
        Plot amplitude spectra of EOD waveforms.
        If &#39;auto&#39;, plot them if there is a singel waveform only.
    skip_bad: bool
        Skip harmonic groups without index in the spectrum plot.
    save_plot: bool
        If True, save plots as pdf file.
    multi_pdf: matplotlib.PdfPages or None
        PdfPages instance in which to save plots.
    save_subplots: string
        If not empty, specifies subplots to be saved as separate pdf
        files: r) recording with best window, t) data trace with
        detected pulse fish, p) power spectrum with detected wave
        fish, w/W) mean EOD waveform, s/S) EOD spectrum, e/E) EOD
        waveform and spectra. Capital letters produce a single
        multipage pdf containing plots of all detected fish.
    log_freq: boolean
        Logarithmic (True) or linear (False) frequency axis of
        power spectrum of recording.
    min_freq: float
        Limits of frequency axis of power spectrum of recording
        are set to `(min_freq, max_freq)`, if `max_freq` is greater than zero
    max_freq: float
        Limits of frequency axis of power spectrum of recording
        are set to `(min_freq, max_freq)` and limits of power axis are computed
        from powers below max_freq, if `max_freq` is greater than zero
    output_folder: string
        Folder where to save results.
    keep_path: bool
        Add relative path of data files to output path.
    verbose: int
       Verbosity level (for debugging).
    &#34;&#34;&#34;
    if len(save_subplots) == 0:
        save_subplots = &#39;rtpwsed&#39;  # plot everything
    # load analysis results:
    mean_eods, wave_eodfs, wave_indices, eod_props, spec_data, \
        peak_data, base_name, channel, unit = load_analysis(files)
    if len(mean_eods) == 0 or all(me is None for me in mean_eods):
        save_subplots = save_subplots.replace(&#39;w&#39;, &#39;&#39;)
        save_subplots = save_subplots.replace(&#39;W&#39;, &#39;&#39;)
        save_subplots = save_subplots.replace(&#39;e&#39;, &#39;&#39;)
        save_subplots = save_subplots.replace(&#39;E&#39;, &#39;&#39;)
        save_subplots = save_subplots.replace(&#39;d&#39;, &#39;&#39;)
    if len(spec_data) == 0 or all(sd is None for sd in spec_data):
        save_subplots = save_subplots.replace(&#39;s&#39;, &#39;&#39;)
        save_subplots = save_subplots.replace(&#39;S&#39;, &#39;&#39;)
        save_subplots = save_subplots.replace(&#39;e&#39;, &#39;&#39;)
        save_subplots = save_subplots.replace(&#39;E&#39;, &#39;&#39;)
        save_subplots = save_subplots.replace(&#39;d&#39;, &#39;&#39;)
    clipped = 0.0
    if len(eod_props) &gt; 0 and not eod_props[0] is None and \
       &#39;winclipped&#39; in eod_props[0]:
        clipped = eod_props[0][&#39;winclipped&#39;]
    zoom_window = [1.2, 1.3]
    # load recording:
    psd_data = None
    if base_name:
        name = os.path.basename(base_name) if data_path and data_path != &#39;.&#39; else base_name
        data_path = os.path.join(data_path, name)
    data, rate, idx0, idx1, data_path = \
        load_recording(data_path, channel, load_kwargs,
                       eod_props, verbose-1)
    if data is None:
        save_subplots = save_subplots.replace(&#39;r&#39;, &#39;&#39;)
        save_subplots = save_subplots.replace(&#39;t&#39;, &#39;&#39;)
        save_subplots = save_subplots.replace(&#39;d&#39;, &#39;&#39;)
    if verbose &gt; 0:
        print(&#39;loaded&#39;, data_path)
    if len(eod_props) &gt; 0 and not eod_props[0] is None and \
       &#39;dfreq&#39; in eod_props[0] and data is not None and len(data) &gt; 0:
        psd_data = multi_psd(data[idx0:idx1], rate,
                             1.1*eod_props[0][&#39;dfreq&#39;])[0]
    if psd_data is not None and len(psd_data) &gt; 0:
        for idx, fish in zip(wave_indices, wave_eodfs):
            if idx &lt; 0:
                for k in range(len(fish)):
                    fish[k,1] = psd_data[np.argmin(np.abs(psd_data[:,0] - fish[k,0])),1]
    if psd_data is None:
        save_subplots = save_subplots.replace(&#39;p&#39;, &#39;&#39;)
        save_subplots = save_subplots.replace(&#39;d&#39;, &#39;&#39;)
    # file name for output files:
    fn = base_name if keep_path else os.path.basename(base_name)
    output_basename = os.path.join(output_folder, fn)
    if channel &gt;= 0:
        output_basename += f&#39;-c{channel}&#39;
    # make directory if necessary:
    if keep_path:
        outpath = os.path.dirname(output_basename)
        if not os.path.exists(outpath):
            if verbose &gt; 0:
                print(&#39;mkdir %s&#39; % outpath)
            os.makedirs(outpath)
    # plot:
    if len(save_subplots) == 0 or &#39;d&#39; in save_subplots:
        fig = plot_eods(os.path.basename(base_name), None, data, rate,
                        channel, idx0, idx1, clipped, psd_data,
                        wave_eodfs, wave_indices, mean_eods,
                        eod_props, peak_data, spec_data, None, unit,
                        zoom_window, 10, None, True, all_eods,
                        spec_plots, skip_bad, log_freq, min_freq,
                        max_freq, interactive=not save_plot,
                        verbose=verbose-1)
        if save_plot:
            if multi_pdf is not None:
                multi_pdf.savefig(fig)
            else:
                fig.savefig(output_basename + &#39;.pdf&#39;)
        else:
            fig.canvas.manager.set_window_title(&#39;thunderfish&#39;)
            plt.show()
        plt.close()
        save_subplots = save_subplots.replace(&#39;d&#39;, &#39;&#39;)
    if len(save_subplots) &gt; 0:
        plot_eod_subplots(output_basename, save_subplots, data, rate,
                          idx0, idx1, clipped, psd_data, wave_eodfs,
                          wave_indices, mean_eods, eod_props,
                          peak_data, spec_data, unit, zoom_window, 10,
                          None, True, skip_bad, log_freq, min_freq,
                          max_freq, save_plot)
    return None</code></pre>
</details>
<div class="desc"><p>Generate plots from saved analysis results.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>files</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>Analysis files from a single recording.</dd>
<dt><strong><code>data_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path where to find the raw data.</dd>
<dt><strong><code>load_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Key-word arguments for the <code>load_data()</code> function.</dd>
<dt><strong><code>all_eods</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, plot all EOD waveforms.</dd>
<dt><strong><code>spec_plots</code></strong> :&ensp;<code>bool</code> or <code>'auto'</code></dt>
<dd>Plot amplitude spectra of EOD waveforms.
If 'auto', plot them if there is a singel waveform only.</dd>
<dt><strong><code>skip_bad</code></strong> :&ensp;<code>bool</code></dt>
<dd>Skip harmonic groups without index in the spectrum plot.</dd>
<dt><strong><code>save_plot</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, save plots as pdf file.</dd>
<dt><strong><code>multi_pdf</code></strong> :&ensp;<code>matplotlib.PdfPages</code> or <code>None</code></dt>
<dd>PdfPages instance in which to save plots.</dd>
<dt><strong><code>save_subplots</code></strong> :&ensp;<code>string</code></dt>
<dd>If not empty, specifies subplots to be saved as separate pdf
files: r) recording with best window, t) data trace with
detected pulse fish, p) power spectrum with detected wave
fish, w/W) mean EOD waveform, s/S) EOD spectrum, e/E) EOD
waveform and spectra. Capital letters produce a single
multipage pdf containing plots of all detected fish.</dd>
<dt><strong><code>log_freq</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Logarithmic (True) or linear (False) frequency axis of
power spectrum of recording.</dd>
<dt><strong><code>min_freq</code></strong> :&ensp;<code>float</code></dt>
<dd>Limits of frequency axis of power spectrum of recording
are set to <code>(min_freq, max_freq)</code>, if <code>max_freq</code> is greater than zero</dd>
<dt><strong><code>max_freq</code></strong> :&ensp;<code>float</code></dt>
<dd>Limits of frequency axis of power spectrum of recording
are set to <code>(min_freq, max_freq)</code> and limits of power axis are computed
from powers below max_freq, if <code>max_freq</code> is greater than zero</dd>
<dt><strong><code>output_folder</code></strong> :&ensp;<code>string</code></dt>
<dd>Folder where to save results.</dd>
<dt><strong><code>keep_path</code></strong> :&ensp;<code>bool</code></dt>
<dd>Add relative path of data files to output path.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>Verbosity level (for debugging).</p></div>
</dd>
<dt id="thunderfish.thunderfish.thunderfish"><code class="name flex">
<span>def <span class="ident">thunderfish</span></span>(<span>filename,<br>load_kwargs,<br>cfg,<br>channel=0,<br>time=None,<br>time_file=False,<br>mode='wp',<br>log_freq=False,<br>min_freq=0.0,<br>max_freq=3000,<br>save_data=False,<br>zip_file=False,<br>all_eods=False,<br>spec_plots='auto',<br>skip_bad=True,<br>save_plot=False,<br>multi_pdf=None,<br>save_subplots='',<br>output_folder='.',<br>keep_path=False,<br>verbose=0,<br>plot_level=0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def thunderfish(filename, load_kwargs, cfg, channel=0,
                time=None, time_file=False,
                mode=&#39;wp&#39;, log_freq=False, min_freq=0.0, max_freq=3000,
                save_data=False, zip_file=False,
                all_eods=False, spec_plots=&#39;auto&#39;, skip_bad=True,
                save_plot=False, multi_pdf=None, save_subplots=&#39;&#39;,
                output_folder=&#39;.&#39;, keep_path=False,
                verbose=0, plot_level=0):
    &#34;&#34;&#34;Automatically detect and analyze all EOD waveforms in a short recording.

    Parameters
    ----------
    filename: string
        Path of the data file to be analyzed.
    load_kwargs: dict
        Key-word arguments for the `load_data()` function.
    cfg: dict
    channel: int
        Channel to be analyzed.
    time: string, float, or None
        Start time of analysis window: &#34;beginning&#34;, &#34;center&#34;, &#34;end&#34;,
        &#34;best&#34;, or time in seconds (as float or string). If not None
        overwrites &#34;windowPosition&#34; in cofiguration file.
    time_file: bool
        If `True` add time of analysis window to output file names.
    mode: &#39;w&#39;, &#39;p&#39;, &#39;P&#39;, &#39;wp&#39;, or &#39;wP&#39;
        Analyze wavefish (&#39;w&#39;), all pulse fish (&#39;p&#39;), or largest pulse
        fish only (&#39;P&#39;).
    log_freq: boolean
        Logarithmic (True) or linear (False) frequency axis of
        power spectrum of recording.
    min_freq: float
        Limits of frequency axis of power spectrum of recording
        are set to `(min_freq, max_freq)`, if `max_freq` is greater than zero
    max_freq: float
        Limits of frequency axis of power spectrum of recording
        are set to `(min_freq, max_freq)` and limits of power axis are computed
        from powers below max_freq, if `max_freq` is greater than zero
    save_data: bool
        If True save analysis results in files. If False, just plot the data.
    zip_data: bool
        If True, store all analysis results in a single zip file.
    all_eods: bool
        If True, plot all EOD waveforms.
    spec_plots: bool or &#39;auto&#39;
        Plot amplitude spectra of EOD waveforms.
        If &#39;auto&#39;, plot them if there is a singel waveform only.
    skip_bad: bool
        Skip harmonic groups without index in the spectrum plot.
    save_plot: bool
        If True, save plots as pdf file.
    multi_pdf: matplotlib.PdfPages or None
        PdfPages instance in which to save plots.
    save_subplots: string
        If not empty, specifies subplots to be saved as separate pdf
        files: r) recording with best window, t) data trace with
        detected pulse fish, p) power spectrum with detected wave
        fish, w/W) mean EOD waveform, s/S) EOD spectrum, e/E) EOD
        waveform and spectra. Capital letters produce a single
        multipage pdf containing plots of all detected fish.
    output_folder: string
        Folder where to save results.
    keep_path: bool
        Add relative path of data files to output path.
    verbose: int
       Verbosity level (for debugging).
    plot_level: int
       Plot intermediate results.

    Returns
    -------
    msg: string or None
        In case of errors, an error message.
    &#34;&#34;&#34;
    # check data file:
    if len(filename) == 0:
        return &#39;you need to specify a file containing some data&#39;

    # file names:
    fn = filename if keep_path else os.path.basename(filename)
    outfilename = os.path.splitext(fn)[0]
    messagefilename = os.path.splitext(fn)[0] + &#39;-message.wav&#39;
    if not os.path.isfile(messagefilename):
        messagefilename = None

    # load data:
    try:
        all_data, rate, unit, ampl_max = load_data(filename,
                                                   verbose=verbose,
                                                   **load_kwargs)
    except IOError as e:
        return &#39;%s: failed to open file: %s&#39; % (filename, str(e))
    # select channel:
    channels = all_data.shape[1]
    chan_list = [channel]
    if channel &lt; 0:
        chan_list = range(channels)
    elif channel &gt;= channels:
        return &#39;%s: invalid channel %d (%d channels)&#39; % (filename, channel, channels)
    # process all channels:
    for chan in chan_list:
        raw_data = all_data[:,chan]
        if len(raw_data) &lt;= 1:
            return &#39;%s: empty data file&#39; % filename
        if verbose &gt;= 0 and len(chan_list) &gt; 1:
            print(&#39;  channel %d&#39; % chan)

        # analysis window:
        win_pos = cfg.value(&#39;windowPosition&#39;)
        if time is not None:
            win_pos = time
        data, idx0, idx1, clipped, min_clip, max_clip = \
            analysis_window(raw_data, rate, ampl_max, win_pos, cfg,
                            plot_level&gt;0)
        found_bestwindow = idx1 &gt; 0
        if not found_bestwindow:
            return &#39;%s: not enough data for requested window length. You may want to adjust the windowSize parameter in the configuration file.&#39; % filename

        # detect EODs in the data:
        psd_data, wave_eodfs, wave_indices, eod_props, \
        mean_eods, spec_data, peak_data, power_thresh, skip_reason, zoom_window = \
          detect_eods(data, rate, min_clip, max_clip, filename, mode,
                      verbose, plot_level, cfg)
        if not found_bestwindow:
            wave_eodfs = []
            wave_indices = []
            eod_props = []
            mean_eods = []

        # add analysis window to EOD properties:
        for props in eod_props:
            props[&#39;twin&#39;] = idx0/rate
            props[&#39;window&#39;] = (idx1 - idx0)/rate
            props[&#39;winclipped&#39;] = clipped

        # warning message in case no fish has been found:
        if found_bestwindow and not eod_props :
            msg = &#39;, &#39;.join(skip_reason)
            if msg:
                print(filename + &#39;: no fish found: %s&#39; % msg)
            else:
                print(filename + &#39;: no fish found.&#39;)

        # file name for output files:
        output_basename = os.path.join(output_folder, outfilename)
        if channels &gt; 1:
            if channels &gt; 100:
                output_basename += &#39;-c%03d&#39; % chan
            elif channels &gt; 10:
                output_basename += &#39;-c%02d&#39; % chan
            else:
                output_basename += &#39;-c%d&#39; % chan
        if time_file:
            output_basename += &#39;-t%.0fs&#39; % (idx0/rate)
        # make directory if necessary:
        if keep_path and found_bestwindow:
            outpath = os.path.dirname(output_basename)
            if not os.path.exists(outpath):
                if verbose &gt; 0:
                    print(&#39;mkdir %s&#39; % outpath)
                os.makedirs(outpath)
        # save results to files:
        if save_data:
            remove_eod_files(output_basename, verbose, cfg)
            if found_bestwindow:
                save_analysis(output_basename, zip_file, eod_props,
                              mean_eods, spec_data, peak_data,
                              wave_eodfs, wave_indices, unit, verbose,
                              **write_table_args(cfg))
        # summary plots:
        if save_plot or not save_data:
            n_snippets = 10
            if len(save_subplots) == 0 or &#39;d&#39; in save_subplots:
                chl = chan if channels &gt; 1 else None
                fig = plot_eods(outfilename, messagefilename,
                                raw_data, rate, chl, idx0, idx1,
                                clipped, psd_data[0], wave_eodfs,
                                wave_indices, mean_eods, eod_props,
                                peak_data, spec_data, None, unit,
                                zoom_window, n_snippets, power_thresh,
                                True, all_eods, spec_plots, skip_bad,
                                log_freq, min_freq, max_freq,
                                interactive=not save_plot,
                                verbose=verbose)
                if save_plot:
                    if multi_pdf is not None:
                        multi_pdf.savefig(fig)
                    else:
                        fig.savefig(output_basename + &#39;.pdf&#39;)
                else:
                    fig.canvas.manager.set_window_title(&#39;thunderfish&#39;)
                    plt.show()
                plt.close()
                save_subplots = save_subplots.replace(&#39;d&#39;, &#39;&#39;)
            if len(save_subplots) &gt; 0:
                plot_eod_subplots(output_basename, save_subplots,
                                  raw_data, rate, idx0, idx1, clipped,
                                  psd_data[0], wave_eodfs,
                                  wave_indices, mean_eods, eod_props,
                                  peak_data, spec_data, unit,
                                  zoom_window, n_snippets,
                                  power_thresh, True, skip_bad,
                                  log_freq, min_freq, max_freq,
                                  save_plot)
    return None</code></pre>
</details>
<div class="desc"><p>Automatically detect and analyze all EOD waveforms in a short recording.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>string</code></dt>
<dd>Path of the data file to be analyzed.</dd>
<dt><strong><code>load_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Key-word arguments for the <code>load_data()</code> function.</dd>
<dt><strong><code>cfg</code></strong> :&ensp;<code>dict</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code>int</code></dt>
<dd>Channel to be analyzed.</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>string, float,</code> or <code>None</code></dt>
<dd>Start time of analysis window: "beginning", "center", "end",
"best", or time in seconds (as float or string). If not None
overwrites "windowPosition" in cofiguration file.</dd>
<dt><strong><code>time_file</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code> add time of analysis window to output file names.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>'w', 'p', 'P', 'wp',</code> or <code>'wP'</code></dt>
<dd>Analyze wavefish ('w'), all pulse fish ('p'), or largest pulse
fish only ('P').</dd>
<dt><strong><code>log_freq</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Logarithmic (True) or linear (False) frequency axis of
power spectrum of recording.</dd>
<dt><strong><code>min_freq</code></strong> :&ensp;<code>float</code></dt>
<dd>Limits of frequency axis of power spectrum of recording
are set to <code>(min_freq, max_freq)</code>, if <code>max_freq</code> is greater than zero</dd>
<dt><strong><code>max_freq</code></strong> :&ensp;<code>float</code></dt>
<dd>Limits of frequency axis of power spectrum of recording
are set to <code>(min_freq, max_freq)</code> and limits of power axis are computed
from powers below max_freq, if <code>max_freq</code> is greater than zero</dd>
<dt><strong><code>save_data</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True save analysis results in files. If False, just plot the data.</dd>
<dt><strong><code>zip_data</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, store all analysis results in a single zip file.</dd>
<dt><strong><code>all_eods</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, plot all EOD waveforms.</dd>
<dt><strong><code>spec_plots</code></strong> :&ensp;<code>bool</code> or <code>'auto'</code></dt>
<dd>Plot amplitude spectra of EOD waveforms.
If 'auto', plot them if there is a singel waveform only.</dd>
<dt><strong><code>skip_bad</code></strong> :&ensp;<code>bool</code></dt>
<dd>Skip harmonic groups without index in the spectrum plot.</dd>
<dt><strong><code>save_plot</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, save plots as pdf file.</dd>
<dt><strong><code>multi_pdf</code></strong> :&ensp;<code>matplotlib.PdfPages</code> or <code>None</code></dt>
<dd>PdfPages instance in which to save plots.</dd>
<dt><strong><code>save_subplots</code></strong> :&ensp;<code>string</code></dt>
<dd>If not empty, specifies subplots to be saved as separate pdf
files: r) recording with best window, t) data trace with
detected pulse fish, p) power spectrum with detected wave
fish, w/W) mean EOD waveform, s/S) EOD spectrum, e/E) EOD
waveform and spectra. Capital letters produce a single
multipage pdf containing plots of all detected fish.</dd>
<dt><strong><code>output_folder</code></strong> :&ensp;<code>string</code></dt>
<dd>Folder where to save results.</dd>
<dt><strong><code>keep_path</code></strong> :&ensp;<code>bool</code></dt>
<dd>Add relative path of data files to output path.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
<dt>Verbosity level (for debugging).</dt>
<dt><strong><code>plot_level</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>Plot intermediate results.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>msg</code></strong> :&ensp;<code>string</code> or <code>None</code></dt>
<dd>In case of errors, an error message.</dd>
</dl></div>
</dd>
<dt id="thunderfish.thunderfish.run_thunderfish"><code class="name flex">
<span>def <span class="ident">run_thunderfish</span></span>(<span>file_args)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_thunderfish(file_args):
    &#34;&#34;&#34;Helper function for mutlithreading Pool().map().
    &#34;&#34;&#34;
    results = file_args[1][0]
    verbose = file_args[1][-1] if results else file_args[1][-2]+1
    if verbose &gt; 1:
        print(&#39;=&#39;*70)
    try:
        if results:
            thunderfish_plot(file_args[0], *file_args[1][1:])
        else:
            if verbose &gt; 0:
                print(&#39;analyze recording %s ...&#39; % file_args[0])
            msg = thunderfish(file_args[0], *file_args[1][1:])
            if msg:
                print(msg)
    except (KeyboardInterrupt, SystemExit):
        print(&#39;\nthunderfish interrupted by user... exit now.&#39;)
        sys.exit(0)
    except:
        print(traceback.format_exc())</code></pre>
</details>
<div class="desc"><p>Helper function for mutlithreading Pool().map().</p></div>
</dd>
<dt id="thunderfish.thunderfish.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>cargs=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(cargs=None):
    # config file name:
    cfgfile = __package__ + &#39;.cfg&#39;

    # command line arguments:
    if cargs is None:
        cargs = sys.argv[1:]
    parser = argparse.ArgumentParser(add_help=False,
        description=&#39;Analyze EOD waveforms of weakly electric fish.&#39;,
        epilog=&#39;version %s by Benda-Lab (2015-%s)&#39; % (__version__, __year__))
    parser.add_argument(&#39;-h&#39;, &#39;--help&#39;, action=&#39;store_true&#39;,
                        help=&#39;show this help message and exit&#39;)
    parser.add_argument(&#39;--version&#39;, action=&#39;version&#39;, version=__version__)
    parser.add_argument(&#39;-v&#39;, action=&#39;count&#39;, dest=&#39;verbose&#39;, default=0,
                        help=&#39;verbosity level. Increase by specifying -v multiple times, or like -vvv&#39;)
    parser.add_argument(&#39;-V&#39;, action=&#39;count&#39;, dest=&#39;plot_level&#39;, default=0,
                        help=&#39;level for debugging plots. Increase by specifying -V multiple times, or like -VVV&#39;)
    parser.add_argument(&#39;-c&#39;, dest=&#39;save_config&#39;, action=&#39;store_true&#39;,
                        help=&#39;save configuration to file {0} after reading all configuration files&#39;.format(cfgfile))
    parser.add_argument(&#39;--channel&#39;, default=0, type=int,
                        help=&#39;channel to be analyzed (defaults to first channel, negative channel selects all channels)&#39;)
    parser.add_argument(&#39;-t&#39;, dest=&#39;time&#39;, default=None, type=str, metavar=&#39;TIME&#39;,
                        help=&#39;start time of analysis window in recording: &#34;beginning&#34;, &#34;center&#34;, &#34;end&#34;, &#34;best&#34;, or time in seconds (overwrites &#34;windowPosition&#34; in cofiguration file)&#39;)
    parser.add_argument(&#39;-u&#39;, dest=&#39;unwrap&#39;, action=&#39;store_true&#39;,
                        help=&#39;unwrap clipped files, toggles unwrap setting of config file.&#39;)
    parser.add_argument(&#39;-T&#39;, dest=&#39;time_file&#39;, action=&#39;store_true&#39;,
                        help=&#39;add start time of analysis file to output file names&#39;)
    parser.add_argument(&#39;-m&#39;, dest=&#39;mode&#39;, default=&#39;wp&#39;, type=str,
                        choices=[&#39;w&#39;, &#39;p&#39;, &#39;wp&#39;],
                        help=&#39;extract wave &#34;w&#34; and/or pulse &#34;p&#34; fish EODs&#39;)
    parser.add_argument(&#39;-a&#39;, dest=&#39;all_eods&#39;, action=&#39;store_true&#39;,
                        help=&#39;show all EOD waveforms in the summary plot&#39;)
    parser.add_argument(&#39;-S&#39;, dest=&#39;spec_plots&#39;, action=&#39;store_true&#39;,
                        help=&#39;plot spectra for all EOD waveforms in the summary plot&#39;)
    parser.add_argument(&#39;-b&#39;, dest=&#39;skip_bad&#39;, action=&#39;store_false&#39;,
                        help=&#39;indicate bad EODs in legend of power spectrum&#39;)
    parser.add_argument(&#39;-l&#39;, dest=&#39;log_freq&#39;, type=float, metavar=&#39;MINFREQ&#39;,
                        nargs=&#39;?&#39;, const=100.0, default=0.0,
                        help=&#39;logarithmic frequency axis in  power spectrum with optional minimum frequency (defaults to 100 Hz)&#39;)
    parser.add_argument(&#39;-p&#39;, dest=&#39;save_plot&#39;, action=&#39;store_true&#39;,
                        help=&#39;save output plots as pdf files&#39;)
    parser.add_argument(&#39;-M&#39;, dest=&#39;multi_pdf&#39;, default=&#39;&#39;, type=str, metavar=&#39;PDFFILE&#39;,
                        help=&#39;save all summary plots of all recordings in a multi page pdf file. Disables parallel jobs.&#39;)
    parser.add_argument(&#39;-P&#39;, dest=&#39;save_subplots&#39;, default=&#39;&#39;, type=str, metavar=&#39;rtpwsed&#39;,
                        help=&#39;save subplots as separate pdf files: r) recording with analysis window, t) data trace with detected pulse fish, p) power spectrum with detected wave fish, w/W) mean EOD waveform, s/S) EOD spectrum, e/E) EOD waveform and spectra, d) the default summary plot. Capital letters produce a single multipage pdf containing plots of all detected fish&#39;)
    parser.add_argument(&#39;-d&#39;, dest=&#39;rawdata_path&#39;, default=&#39;.&#39;, type=str, metavar=&#39;PATH&#39;,
                        help=&#39;path to raw EOD recordings needed for plotting based on analysis results&#39;)
    parser.add_argument(&#39;-j&#39;, dest=&#39;jobs&#39;, nargs=&#39;?&#39;, type=int, default=None, const=0,
                        help=&#39;number of jobs run in parallel. Without argument use all CPU cores.&#39;)
    parser.add_argument(&#39;-s&#39;, dest=&#39;save_data&#39;, action=&#39;store_true&#39;,
                        help=&#39;save analysis results to files&#39;)
    parser.add_argument(&#39;-z&#39;, dest=&#39;zip_file&#39;, action=&#39;store_true&#39;,
                        help=&#39;save analysis results in a single zip file&#39;)
    parser.add_argument(&#39;-f&#39;, dest=&#39;format&#39;, default=&#39;auto&#39;, type=str,
                        choices=TableData.formats + [&#39;py&#39;],
                        help=&#39;file format used for saving analysis results, defaults to the format specified in the configuration file or &#34;csv&#34;&#39;)
    parser.add_argument(&#39;-o&#39;, dest=&#39;outpath&#39;, default=&#39;.&#39;, type=str,
                        help=&#39;path where to store results and figures (defaults to current working directory)&#39;)
    parser.add_argument(&#39;-k&#39;, dest=&#39;keep_path&#39;, action=&#39;store_true&#39;,
                        help=&#39;keep path of input file when saving analysis files, i.e. append path of input file to OUTPATH&#39;)
    parser.add_argument(&#39;-i&#39;, dest=&#39;load_kwargs&#39;, default=[],
                        action=&#39;append&#39;, metavar=&#39;KWARGS&#39;,
                        help=&#39;key-word arguments for the data loader function&#39;)
    parser.add_argument(&#39;file&#39;, nargs=&#39;*&#39;, default=&#39;&#39;, type=str,
                        help=&#39;name of a file with time series data of an EOD recording, may include wildcards&#39;)
    args = parser.parse_args(cargs)

    # help:
    if args.help:
        parser.print_help()
        print(&#39;&#39;)
        print(&#39;examples:&#39;)
        print(&#39;- analyze the single file data.wav interactively:&#39;)
        print(&#39;  &gt; thunderfish data.wav&#39;)
        print(&#39;- extract wavefish only:&#39;)
        print(&#39;  &gt; thunderfish -m w data.wav&#39;)
        print(&#39;- automatically analyze all wav files in the current working directory and save analysis results and plot to files:&#39;)
        print(&#39;  &gt; thunderfish -s -p *.wav&#39;)
        print(&#39;- analyze all wav files in the river1/ directory, use all CPUs, and write files directly to &#34;results/&#34;:&#39;)
        print(&#39;  &gt; thunderfish -j -s -p -o results/ river1/*.wav&#39;)
        print(&#39;- analyze all wav files in the river1/ directory and write files to &#34;results/river1/&#34;:&#39;)
        print(&#39;  &gt; thunderfish -s -p -o results/ -k river1/*.wav&#39;)
        print(&#39;- write configuration file:&#39;)
        print(&#39;  &gt; thunderfish -c&#39;)
        parser.exit()

    # set verbosity level from command line:
    verbose = args.verbose
    plot_level = args.plot_level
    if verbose &lt; plot_level:
        verbose = plot_level

    # interactive plot:
    plt.rcParams[&#39;keymap.quit&#39;] = &#39;ctrl+w, alt+q, q&#39;
    plt.ioff()

    # expand wildcard patterns:
    files = []
    if os.name == &#39;nt&#39;:
        for fn in args.file:
            files.extend(glob.glob(fn))
    else:
        files = [f for f in args.file if &#39;-message&#39; not in f]

    # save configuration:
    if args.save_config:
        file_name = files[0] if len(files) else &#39;&#39;
        cfg = configuration()
        cfg.load_files(cfgfile, file_name, 4, verbose)
        save_configuration(cfg, cfgfile)
        exit()
    elif len(files) == 0:
        parser.error(&#39;you need to specify at least one file for the analysis&#39;)

    # configure:
    cfg = configuration()
    cfg.load_files(cfgfile, files[0], 4, verbose)
    if args.format != &#39;auto&#39;:
        cfg.set(&#39;fileFormat&#39;, args.format)
    if args.unwrap:
        cfg.set(&#39;unwrapData&#39;, not cfg.value(&#39;unwrapData&#39;))
        
    # plot parameter:
    spec_plots = &#39;auto&#39;
    if args.spec_plots:
        spec_plots = True

    # multi-page pdfs:
    multi_pdf = None
    if len(args.multi_pdf) &gt; 0:
        args.save_plot = True
        args.jobs = None  # PdfPages does not work yet with mutliprocessing
        ext = os.path.splitext(args.multi_pdf)[1]
        if ext != os.extsep + &#39;pdf&#39;:
            args.multi_pdf += os.extsep + &#39;pdf&#39;
        multi_pdf = PdfPages(args.multi_pdf)
        
    # create output folder:
    if args.save_data or args.save_plot:
        if not os.path.exists(args.outpath):
            if verbose &gt; 1:
                print(&#39;mkdir %s&#39; % args.outpath)
            os.makedirs(args.outpath)

    # kwargs for data loader:
    load_kwargs = {}
    for s in args.load_kwargs:
        for kw in s.split(&#39;,&#39;):
            kws = kw.split(&#39;:&#39;)
            if len(kws) == 2:
                load_kwargs[kws[0].strip()] = kws[1].strip()

    # frequency limits for power spectrum:
    min_freq = 0.0
    max_freq = 3000.0
    log_freq = args.log_freq
    if log_freq &gt; 0.0:
        min_freq = log_freq
        max_freq = min_freq*20
        if max_freq &lt; 2000:
            max_freq = 2000
        log_freq = True
    else:
        log_freq = False

    # check if all input files are results:
    exts = TableData.ext_formats.values()
    results = True
    # check and group by recording:
    result_files = []
    for f in sorted(files):
        _, base_name, _, _, ftype, _, ext = parse_filename(f)
        if ext == &#39;zip&#39; or (ext in exts and ftype in file_types):
            if len(result_files) == 0 or \
               not result_files[-1][-1].startswith(base_name):
                result_files.append([f])
            else:
                result_files[-1].append(f)
        else:
            results = False
            break
    if results:
        files = result_files

    # adjust verbosity:
    v = verbose
    if len(files) &gt; 1:
        v += 1
    
    # run on pool:
    pool_args = (results, load_kwargs, cfg, args.channel, args.time,
                 args.time_file, args.mode, log_freq, min_freq,
                 max_freq, args.save_data, args.zip_file,
                 args.all_eods, spec_plots, args.skip_bad,
                 args.save_plot, multi_pdf, args.save_subplots,
                 args.outpath, args.keep_path, v-1, plot_level)
    if results:
        pool_args = (results, args.rawdata_path, load_kwargs,
                     args.all_eods, spec_plots, args.skip_bad,
                     args.save_plot, multi_pdf, args.save_subplots,
                     log_freq, min_freq, max_freq, args.outpath,
                     args.keep_path, v)
    if args.jobs is not None and (args.save_data or args.save_plot) and len(files) &gt; 1:
        cpus = cpu_count() if args.jobs == 0 else args.jobs
        if verbose &gt; 1:
            print(&#39;run on %d cpus&#39; % cpus)
        p = Pool(cpus)
        p.map(run_thunderfish, zip(files, [pool_args]*len(files)))
    else:
        list(map(run_thunderfish, zip(files, [pool_args]*len(files))))
    if multi_pdf is not None:
        multi_pdf.close()</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul>
<li><a href="#thunderfish">thunderfish</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="thunderfish" href="index.html">thunderfish</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="thunderfish.thunderfish.trace_color" href="#thunderfish.thunderfish.trace_color">trace_color</a></code></li>
<li><code><a title="thunderfish.thunderfish.data_color" href="#thunderfish.thunderfish.data_color">data_color</a></code></li>
<li><code><a title="thunderfish.thunderfish.fit_color" href="#thunderfish.thunderfish.fit_color">fit_color</a></code></li>
<li><code><a title="thunderfish.thunderfish.spectrum_color" href="#thunderfish.thunderfish.spectrum_color">spectrum_color</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="thunderfish.thunderfish.configuration" href="#thunderfish.thunderfish.configuration">configuration</a></code></li>
<li><code><a title="thunderfish.thunderfish.save_configuration" href="#thunderfish.thunderfish.save_configuration">save_configuration</a></code></li>
<li><code><a title="thunderfish.thunderfish.detect_eods" href="#thunderfish.thunderfish.detect_eods">detect_eods</a></code></li>
<li><code><a title="thunderfish.thunderfish.remove_eod_files" href="#thunderfish.thunderfish.remove_eod_files">remove_eod_files</a></code></li>
<li><code><a title="thunderfish.thunderfish.plot_style" href="#thunderfish.thunderfish.plot_style">plot_style</a></code></li>
<li><code><a title="thunderfish.thunderfish.axes_style" href="#thunderfish.thunderfish.axes_style">axes_style</a></code></li>
<li><code><a title="thunderfish.thunderfish.plot_eods" href="#thunderfish.thunderfish.plot_eods">plot_eods</a></code></li>
<li><code><a title="thunderfish.thunderfish.plot_eod_subplots" href="#thunderfish.thunderfish.plot_eod_subplots">plot_eod_subplots</a></code></li>
<li><code><a title="thunderfish.thunderfish.thunderfish_plot" href="#thunderfish.thunderfish.thunderfish_plot">thunderfish_plot</a></code></li>
<li><code><a title="thunderfish.thunderfish.thunderfish" href="#thunderfish.thunderfish.thunderfish">thunderfish</a></code></li>
<li><code><a title="thunderfish.thunderfish.run_thunderfish" href="#thunderfish.thunderfish.run_thunderfish">run_thunderfish</a></code></li>
<li><code><a title="thunderfish.thunderfish.main" href="#thunderfish.thunderfish.main">main</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
