<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>thunderfish.eodanalysis API documentation</title>
<meta name="description" content="Analysis of EOD waveforms â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>thunderfish.eodanalysis</code></h1>
</header>
<section id="section-intro">
<p>Analysis of EOD waveforms.</p>
<h2 id="eod-waveform-analysis">EOD waveform analysis</h2>
<ul>
<li><code><a title="thunderfish.eodanalysis.eod_waveform" href="#thunderfish.eodanalysis.eod_waveform">eod_waveform()</a></code>: compute an averaged EOD waveform.</li>
<li><code><a title="thunderfish.eodanalysis.waveeod_waveform" href="#thunderfish.eodanalysis.waveeod_waveform">waveeod_waveform()</a></code>: retrieve average EOD waveform via Fourier transform.</li>
<li><code><a title="thunderfish.eodanalysis.analyze_wave" href="#thunderfish.eodanalysis.analyze_wave">analyze_wave()</a></code>: analyze the EOD waveform of a wave fish.</li>
<li><code><a title="thunderfish.eodanalysis.analyze_pulse" href="#thunderfish.eodanalysis.analyze_pulse">analyze_pulse()</a></code>: analyze the EOD waveform of a pulse fish.</li>
<li><code><a title="thunderfish.eodanalysis.adjust_eodf" href="#thunderfish.eodanalysis.adjust_eodf">adjust_eodf()</a></code>: adjust EOD frequencies to a standard temperature.</li>
</ul>
<h2 id="similarity-of-eod-waveforms">Similarity of EOD waveforms</h2>
<ul>
<li><code><a title="thunderfish.eodanalysis.wave_similarity" href="#thunderfish.eodanalysis.wave_similarity">wave_similarity()</a></code>: root-mean squared difference between two wave fish EODs.</li>
<li><code><a title="thunderfish.eodanalysis.pulse_similarity" href="#thunderfish.eodanalysis.pulse_similarity">pulse_similarity()</a></code>: root-mean squared difference between two pulse fish EODs.</li>
<li><code><a title="thunderfish.eodanalysis.load_species_waveforms" href="#thunderfish.eodanalysis.load_species_waveforms">load_species_waveforms()</a></code>: load template EOD waveforms for species matching.</li>
</ul>
<h2 id="quality-assessment">Quality assessment</h2>
<ul>
<li><code><a title="thunderfish.eodanalysis.clipped_fraction" href="#thunderfish.eodanalysis.clipped_fraction">clipped_fraction()</a></code>: compute fraction of clipped EOD waveform snippets.</li>
<li><code><a title="thunderfish.eodanalysis.wave_quality" href="#thunderfish.eodanalysis.wave_quality">wave_quality()</a></code>: asses quality of EOD waveform of a wave fish.</li>
<li><code><a title="thunderfish.eodanalysis.pulse_quality" href="#thunderfish.eodanalysis.pulse_quality">pulse_quality()</a></code>: asses quality of EOD waveform of a pulse fish.</li>
</ul>
<h2 id="visualization">Visualization</h2>
<ul>
<li><code><a title="thunderfish.eodanalysis.plot_eod_recording" href="#thunderfish.eodanalysis.plot_eod_recording">plot_eod_recording()</a></code>: plot a zoomed in range of the recorded trace.</li>
<li><code><a title="thunderfish.eodanalysis.plot_pulse_eods" href="#thunderfish.eodanalysis.plot_pulse_eods">plot_pulse_eods()</a></code>: mark pulse EODs in a plot of an EOD recording.</li>
<li><code><a title="thunderfish.eodanalysis.plot_eod_snippets" href="#thunderfish.eodanalysis.plot_eod_snippets">plot_eod_snippets()</a></code>: plot a few EOD waveform snippets.</li>
<li><code><a title="thunderfish.eodanalysis.plot_eod_waveform" href="#thunderfish.eodanalysis.plot_eod_waveform">plot_eod_waveform()</a></code>: plot and annotate the averaged EOD-waveform with standard error.</li>
<li><code><a title="thunderfish.eodanalysis.plot_wave_spectrum" href="#thunderfish.eodanalysis.plot_wave_spectrum">plot_wave_spectrum()</a></code>: plot and annotate spectrum of wave EODs.</li>
<li><code><a title="thunderfish.eodanalysis.plot_pulse_spectrum" href="#thunderfish.eodanalysis.plot_pulse_spectrum">plot_pulse_spectrum()</a></code>: plot and annotate spectrum of single pulse EOD.</li>
</ul>
<h2 id="storage">Storage</h2>
<ul>
<li><code><a title="thunderfish.eodanalysis.save_eod_waveform" href="#thunderfish.eodanalysis.save_eod_waveform">save_eod_waveform()</a></code>: save mean EOD waveform to file.</li>
<li><code><a title="thunderfish.eodanalysis.load_eod_waveform" href="#thunderfish.eodanalysis.load_eod_waveform">load_eod_waveform()</a></code>: load EOD waveform from file.</li>
<li><code><a title="thunderfish.eodanalysis.save_wave_eodfs" href="#thunderfish.eodanalysis.save_wave_eodfs">save_wave_eodfs()</a></code>: save frequencies of wave EODs to file.</li>
<li><code><a title="thunderfish.eodanalysis.load_wave_eodfs" href="#thunderfish.eodanalysis.load_wave_eodfs">load_wave_eodfs()</a></code>: load frequencies of wave EODs from file.</li>
<li><code><a title="thunderfish.eodanalysis.save_wave_fish" href="#thunderfish.eodanalysis.save_wave_fish">save_wave_fish()</a></code>: save properties of wave EODs to file.</li>
<li><code><a title="thunderfish.eodanalysis.load_wave_fish" href="#thunderfish.eodanalysis.load_wave_fish">load_wave_fish()</a></code>: load properties of wave EODs from file.</li>
<li><code><a title="thunderfish.eodanalysis.save_pulse_fish" href="#thunderfish.eodanalysis.save_pulse_fish">save_pulse_fish()</a></code>: save properties of pulse EODs to file.</li>
<li><code><a title="thunderfish.eodanalysis.load_pulse_fish" href="#thunderfish.eodanalysis.load_pulse_fish">load_pulse_fish()</a></code>: load properties of pulse EODs from file.</li>
<li><code><a title="thunderfish.eodanalysis.save_wave_spectrum" href="#thunderfish.eodanalysis.save_wave_spectrum">save_wave_spectrum()</a></code>: save amplitude and phase spectrum of wave EOD to file.</li>
<li><code><a title="thunderfish.eodanalysis.load_wave_spectrum" href="#thunderfish.eodanalysis.load_wave_spectrum">load_wave_spectrum()</a></code>: load amplitude and phase spectrum of wave EOD from file.</li>
<li><code><a title="thunderfish.eodanalysis.save_pulse_spectrum" href="#thunderfish.eodanalysis.save_pulse_spectrum">save_pulse_spectrum()</a></code>: save power spectrum of pulse EOD to file.</li>
<li><code><a title="thunderfish.eodanalysis.load_pulse_spectrum" href="#thunderfish.eodanalysis.load_pulse_spectrum">load_pulse_spectrum()</a></code>: load power spectrum of pulse EOD from file.</li>
<li><code><a title="thunderfish.eodanalysis.save_pulse_peaks" href="#thunderfish.eodanalysis.save_pulse_peaks">save_pulse_peaks()</a></code>: save peak properties of pulse EOD to file.</li>
<li><code><a title="thunderfish.eodanalysis.load_pulse_peaks" href="#thunderfish.eodanalysis.load_pulse_peaks">load_pulse_peaks()</a></code>: load peak properties of pulse EOD from file.</li>
<li><code><a title="thunderfish.eodanalysis.save_pulse_times" href="#thunderfish.eodanalysis.save_pulse_times">save_pulse_times()</a></code>: save times of pulse EOD to file.</li>
<li><code><a title="thunderfish.eodanalysis.load_pulse_times" href="#thunderfish.eodanalysis.load_pulse_times">load_pulse_times()</a></code>: load times of pulse EOD from file.</li>
<li><code><a title="thunderfish.eodanalysis.parse_filename" href="#thunderfish.eodanalysis.parse_filename">parse_filename()</a></code>: parse components of an EOD analysis file name.</li>
<li>`save_analysis(): save EOD analysis results to files.</li>
<li><code><a title="thunderfish.eodanalysis.load_analysis" href="#thunderfish.eodanalysis.load_analysis">load_analysis()</a></code>: load EOD analysis files.</li>
<li><code><a title="thunderfish.eodanalysis.load_recording" href="#thunderfish.eodanalysis.load_recording">load_recording()</a></code>: load recording.</li>
</ul>
<h2 id="fit-functions">Fit functions</h2>
<ul>
<li><code><a title="thunderfish.eodanalysis.fourier_series" href="#thunderfish.eodanalysis.fourier_series">fourier_series()</a></code>: Fourier series of sine waves with amplitudes and phases.</li>
<li><code><a title="thunderfish.eodanalysis.exp_decay" href="#thunderfish.eodanalysis.exp_decay">exp_decay()</a></code>: exponential decay.</li>
</ul>
<h2 id="filter-functions">Filter functions</h2>
<ul>
<li><code><a title="thunderfish.eodanalysis.unfilter" href="#thunderfish.eodanalysis.unfilter">unfilter()</a></code>: apply inverse low-pass filter on data.</li>
</ul>
<h2 id="configuration">Configuration</h2>
<ul>
<li><code><a title="thunderfish.eodanalysis.add_eod_analysis_config" href="#thunderfish.eodanalysis.add_eod_analysis_config">add_eod_analysis_config()</a></code>: add parameters for EOD analysis functions to configuration.</li>
<li><code><a title="thunderfish.eodanalysis.eod_waveform_args" href="#thunderfish.eodanalysis.eod_waveform_args">eod_waveform_args()</a></code>: retrieve parameters for <code><a title="thunderfish.eodanalysis.eod_waveform" href="#thunderfish.eodanalysis.eod_waveform">eod_waveform()</a></code> from configuration.</li>
<li><code><a title="thunderfish.eodanalysis.analyze_wave_args" href="#thunderfish.eodanalysis.analyze_wave_args">analyze_wave_args()</a></code>: retrieve parameters for <code><a title="thunderfish.eodanalysis.analyze_wave" href="#thunderfish.eodanalysis.analyze_wave">analyze_wave()</a></code> from configuration.</li>
<li><code><a title="thunderfish.eodanalysis.analyze_pulse_args" href="#thunderfish.eodanalysis.analyze_pulse_args">analyze_pulse_args()</a></code>: retrieve parameters for <code><a title="thunderfish.eodanalysis.analyze_pulse" href="#thunderfish.eodanalysis.analyze_pulse">analyze_pulse()</a></code> from configuration.</li>
<li><code><a title="thunderfish.eodanalysis.add_species_config" href="#thunderfish.eodanalysis.add_species_config">add_species_config()</a></code>: add parameters needed for assigning EOD waveforms to species.</li>
<li><code><a title="thunderfish.eodanalysis.add_eod_quality_config" href="#thunderfish.eodanalysis.add_eod_quality_config">add_eod_quality_config()</a></code>: add parameters needed for assesing the quality of an EOD waveform.</li>
<li><code><a title="thunderfish.eodanalysis.wave_quality_args" href="#thunderfish.eodanalysis.wave_quality_args">wave_quality_args()</a></code>: retrieve parameters for <code><a title="thunderfish.eodanalysis.wave_quality" href="#thunderfish.eodanalysis.wave_quality">wave_quality()</a></code> from configuration.</li>
<li><code><a title="thunderfish.eodanalysis.pulse_quality_args" href="#thunderfish.eodanalysis.pulse_quality_args">pulse_quality_args()</a></code>: retrieve parameters for <code><a title="thunderfish.eodanalysis.pulse_quality" href="#thunderfish.eodanalysis.pulse_quality">pulse_quality()</a></code> from configuration.</li>
</ul>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="thunderfish.eodanalysis.file_types"><code class="name">var <span class="ident">file_types</span></code></dt>
<dd>
<div class="desc"><p>List of all file types generated and supported by the <code>save_*</code> and <code>load_*</code> functions.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="thunderfish.eodanalysis.eod_waveform"><code class="name flex">
<span>def <span class="ident">eod_waveform</span></span>(<span>data,<br>rate,<br>eod_times,<br>win_fac=2.0,<br>min_win=0.01,<br>min_sem=False,<br>max_eods=None,<br>unfilter_cutoff=0.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eod_waveform(data, rate, eod_times, win_fac=2.0, min_win=0.01,
                 min_sem=False, max_eods=None, unfilter_cutoff=0.0):
    &#34;&#34;&#34;Extract data snippets around each EOD, and compute a mean waveform with standard error.

    Retrieving the EOD waveform of a wave fish works under the following
    conditions: (i) at a signal-to-noise ratio \\(SNR = P_s/P_n\\),
    i.e. the power \\(P_s\\) of the EOD of interest relative to the
    largest other EOD \\(P_n\\), we need to average over at least \\(n &gt;
    (SNR \\cdot c_s^2)^{-1}\\) snippets to bring the standard error of the
    averaged EOD waveform down to \\(c_s\\) relative to its
    amplitude. For a s.e.m. less than 5% ( \\(c_s=0.05\\) ) and an SNR of
    -10dB (the signal is 10 times smaller than the noise, \\(SNR=0.1\\) ) we
    get \\(n &gt; 0.00025^{-1} = 4000\\) data snippets - a recording a
    couple of seconds long.  (ii) Very important for wave fish is that
    they keep their frequency constant.  Slight changes in the EOD
    frequency will corrupt the average waveform.  If the period of the
    waveform changes by \\(c_f=\\Delta T/T\\), then after \\(n =
    1/c_f\\) periods moved the modified waveform through a whole period.
    This is in the range of hundreds or thousands waveforms.

    NOTE: we need to take into account a possible error in the estimate
    of the EOD period. This will limit the maximum number of snippets to
    be averaged.

    If `min_sem` is set, the algorithm checks for a global minimum of
    the s.e.m.  as a function of snippet number. If there is one then
    the average is computed for this number of snippets, otherwise all
    snippets are taken from the provided data segment. Note that this
    check only works for the strongest EOD in a recording.  For weaker
    EOD the s.e.m. always decays with snippet number (empirical
    observation).

    TODO: use power spectra to check for changes in EOD frequency!

    Parameters
    ----------
    data: 1-D array of float
        The data to be analysed.
    rate: float
        Sampling rate of the data in Hertz.
    eod_times: 1-D array of float
        Array of EOD times in seconds over which the waveform should be
        averaged.
        WARNING: The first data point must be at time zero!
    win_fac: float
        The snippet size is the EOD period times `win_fac`. The EOD period
        is determined as the minimum interval between EOD times.
    min_win: float
        The minimum size of the snippets in seconds.
    min_sem: bool
        If set, check for minimum in s.e.m. to set the maximum numbers
        of EODs to be used for computing the average waveform.
    max_eods: int or None
        Maximum number of EODs to be used for averaging.
    unfilter_cutoff: float
        If not zero, the cutoff frequency for an inverse high-pass filter
        applied to the mean EOD waveform.
    
    Returns
    -------
    mean_eod: 2-D array
        Average of the EOD snippets. First column is time in seconds,
        second column the mean eod, third column the standard error.
    eod_times: 1-D array
        Times of EOD peaks in seconds that have been actually used to calculate the
        averaged EOD waveform.
    &#34;&#34;&#34;
    # indices of EOD times:
    eod_idx = np.round(eod_times*rate).astype(int)
        
    # window size:
    period = np.min(np.diff(eod_times))
    win = 0.5*win_fac*period
    if 2*win &lt; min_win:
        win = 0.5*min_win
    win_inx = int(win*rate)

    # extract snippets:
    eod_times = eod_times[(eod_idx &gt;= win_inx) &amp; (eod_idx &lt; len(data)-win_inx)]
    eod_idx = eod_idx[(eod_idx &gt;= win_inx) &amp; (eod_idx &lt; len(data)-win_inx)]
    if max_eods and max_eods &gt; 0 and len(eod_idx) &gt; max_eods:
        dn = (len(eod_idx) - max_eods)//2
        eod_times = eod_times[dn:dn+max_eods]
        eod_idx = eod_idx[dn:dn+max_eods]
    eod_snippets = snippets(data, eod_idx, -win_inx, win_inx)
    if len(eod_snippets) == 0:
        return np.zeros((0, 3)), eod_times

    # optimal number of snippets:
    step = 10
    if min_sem and len(eod_snippets) &gt; step:
        sems = [np.mean(np.std(eod_snippets[:k], axis=0, ddof=1)/np.sqrt(k))
                for k in range(step, len(eod_snippets), step)]
        idx = np.argmin(sems)
        # there is a local minimum:
        if idx &gt; 0 and idx &lt; len(sems)-1:
            maxn = step*(idx+1)
            eod_snippets = eod_snippets[:maxn]
            eod_times = eod_times[:maxn]
    
    # mean and std of snippets:
    mean_eod = np.zeros((len(eod_snippets[0]), 3))
    mean_eod[:,1] = np.mean(eod_snippets, axis=0)
    if len(eod_snippets) &gt; 1:
        mean_eod[:,2] = np.std(eod_snippets, axis=0, ddof=1)/np.sqrt(len(eod_snippets))
        
    # apply inverse filter:
    if unfilter_cutoff and unfilter_cutoff &gt; 0.0:
        unfilter(mean_eod[:,1], rate, unfilter_cutoff)
        
    # time axis:
    mean_eod[:,0] = (np.arange(len(mean_eod)) - win_inx) / rate
    
    return mean_eod, eod_times</code></pre>
</details>
<div class="desc"><p>Extract data snippets around each EOD, and compute a mean waveform with standard error.</p>
<p>Retrieving the EOD waveform of a wave fish works under the following
conditions: (i) at a signal-to-noise ratio <span><span class="MathJax_Preview">SNR = P_s/P_n</span><script type="math/tex">SNR = P_s/P_n</script></span>,
i.e. the power <span><span class="MathJax_Preview">P_s</span><script type="math/tex">P_s</script></span> of the EOD of interest relative to the
largest other EOD <span><span class="MathJax_Preview">P_n</span><script type="math/tex">P_n</script></span>, we need to average over at least <span><span class="MathJax_Preview">n &gt;
(SNR \cdot c_s^2)^{-1}</span><script type="math/tex">n >
(SNR \cdot c_s^2)^{-1}</script></span> snippets to bring the standard error of the
averaged EOD waveform down to <span><span class="MathJax_Preview">c_s</span><script type="math/tex">c_s</script></span> relative to its
amplitude. For a s.e.m. less than 5% ( <span><span class="MathJax_Preview">c_s=0.05</span><script type="math/tex">c_s=0.05</script></span> ) and an SNR of
-10dB (the signal is 10 times smaller than the noise, <span><span class="MathJax_Preview">SNR=0.1</span><script type="math/tex">SNR=0.1</script></span> ) we
get <span><span class="MathJax_Preview">n &gt; 0.00025^{-1} = 4000</span><script type="math/tex">n > 0.00025^{-1} = 4000</script></span> data snippets - a recording a
couple of seconds long.
(ii) Very important for wave fish is that
they keep their frequency constant.
Slight changes in the EOD
frequency will corrupt the average waveform.
If the period of the
waveform changes by <span><span class="MathJax_Preview">c_f=\Delta T/T</span><script type="math/tex">c_f=\Delta T/T</script></span>, then after <span><span class="MathJax_Preview">n =
1/c_f</span><script type="math/tex">n =
1/c_f</script></span> periods moved the modified waveform through a whole period.
This is in the range of hundreds or thousands waveforms.</p>
<p>NOTE: we need to take into account a possible error in the estimate
of the EOD period. This will limit the maximum number of snippets to
be averaged.</p>
<p>If <code>min_sem</code> is set, the algorithm checks for a global minimum of
the s.e.m.
as a function of snippet number. If there is one then
the average is computed for this number of snippets, otherwise all
snippets are taken from the provided data segment. Note that this
check only works for the strongest EOD in a recording.
For weaker
EOD the s.e.m. always decays with snippet number (empirical
observation).</p>
<p>TODO: use power spectra to check for changes in EOD frequency!</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>1-D array</code> of <code>float</code></dt>
<dd>The data to be analysed.</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Sampling rate of the data in Hertz.</dd>
<dt><strong><code>eod_times</code></strong> :&ensp;<code>1-D array</code> of <code>float</code></dt>
<dd>Array of EOD times in seconds over which the waveform should be
averaged.
WARNING: The first data point must be at time zero!</dd>
<dt><strong><code>win_fac</code></strong> :&ensp;<code>float</code></dt>
<dd>The snippet size is the EOD period times <code>win_fac</code>. The EOD period
is determined as the minimum interval between EOD times.</dd>
<dt><strong><code>min_win</code></strong> :&ensp;<code>float</code></dt>
<dd>The minimum size of the snippets in seconds.</dd>
<dt><strong><code>min_sem</code></strong> :&ensp;<code>bool</code></dt>
<dd>If set, check for minimum in s.e.m. to set the maximum numbers
of EODs to be used for computing the average waveform.</dd>
<dt><strong><code>max_eods</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>Maximum number of EODs to be used for averaging.</dd>
<dt><strong><code>unfilter_cutoff</code></strong> :&ensp;<code>float</code></dt>
<dd>If not zero, the cutoff frequency for an inverse high-pass filter
applied to the mean EOD waveform.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mean_eod</code></strong> :&ensp;<code>2-D array</code></dt>
<dd>Average of the EOD snippets. First column is time in seconds,
second column the mean eod, third column the standard error.</dd>
<dt><strong><code>eod_times</code></strong> :&ensp;<code>1-D array</code></dt>
<dd>Times of EOD peaks in seconds that have been actually used to calculate the
averaged EOD waveform.</dd>
</dl></div>
</dd>
<dt id="thunderfish.eodanalysis.waveeod_waveform"><code class="name flex">
<span>def <span class="ident">waveeod_waveform</span></span>(<span>data, rate, freq, win_fac=2.0, unfilter_cutoff=0.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def waveeod_waveform(data, rate, freq, win_fac=2.0, unfilter_cutoff=0.0):
    &#34;&#34;&#34;Retrieve average EOD waveform via Fourier transform.

    TODO: use power spectra to check minimum data segment needed and
    check for changes in frequency over several segments!

    TODO: return waveform with higher samplign rate? (important for
    2kHz waves on 24kHz sampling). But this seems to render some EODs
    inacceptable in the further thunderfish processing pipeline.

    Parameters
    ----------
    data: 1-D array of float
        The data to be analysed.
    rate: float
        Sampling rate of the data in Hertz.
    freq: float
        EOD frequency.
    win_fac: float
        The snippet size is the EOD period times `win_fac`. The EOD period
        is determined as the minimum interval between EOD times.
    unfilter_cutoff: float
        If not zero, the cutoff frequency for an inverse high-pass filter
        applied to the mean EOD waveform.
    
    Returns
    -------
    mean_eod: 2-D array
        Average of the EOD snippets. First column is time in seconds,
        second column the mean eod, third column the standard error.
    eod_times: 1-D array
        Times of EOD peaks in seconds that have been actually used to
        calculate the averaged EOD waveform.

    &#34;&#34;&#34;

    @jit(nopython=True)
    def fourier_wave(data, rate, freq):
        &#34;&#34;&#34;
        extracting wave via fourier coefficients
        &#34;&#34;&#34;
        twave = np.arange(0, (1+win_fac)/freq, 1/rate)
        wave = np.zeros(len(twave))
        t = np.arange(len(data))/rate
        for k in range(0, 31):
            Xk = np.trapz(data*np.exp(-1j*2*np.pi*k*freq*t), t)*2/t[-1]
            wave += np.real(Xk*np.exp(1j*2*np.pi*k*freq*twave))
        return wave

    @jit(nopython=True)
    def fourier_range(data, rate, f0, f1, df):
        wave = np.zeros(1)
        freq = f0
        for f in np.arange(f0, f1, df):
            w = fourier_wave(data, rate, f)
            if np.max(w) - np.min(w) &gt; np.max(wave) - np.min(wave):
                wave = w
                freq = f
        return wave, freq

    # TODO: parameterize!
    tsnippet = 2
    min_corr = 0.98
    min_ampl_frac = 0.5
    frange = 0.1
    fstep = 0.1
    waves = []
    freqs = []
    times = []
    step = int(tsnippet*rate)
    for i in range(0, len(data) - step//2, step//2):
        w, f = fourier_range(data[i:i + step], rate, freq - frange,
                             freq + frange + fstep/2, fstep)
        waves.append(w)
        freqs.append(f)
        &#34;&#34;&#34;
        waves.append(np.zeros(1))
        freqs.append(freq)
        for f in np.arange(freq - frange, freq + frange + fstep/2, fstep):
            w = fourier_wave(data[i:i + step], rate, f)
            if np.max(w) - np.min(w) &gt; np.max(waves[-1]) - np.min(waves[-1]):
                waves[-1] = w
                freqs[-1] = f
        &#34;&#34;&#34;
        times.append(np.arange(i/rate, (i + step)/rate, 1/freqs[-1]))
    eod_freq = np.mean(freqs)
    mean_eod = np.zeros((0, 3))
    eod_times = np.zeros((0))
    if len(waves) == 0:
        return mean_eod, eod_times
    for k in range(len(waves)):
        period = int(np.ceil(rate/freqs[k]))
        i = np.argmax(waves[k][:period])
        waves[k] = waves[k][i:]
    n = np.min([len(w) for w in waves])
    waves = np.array([w[:n] for w in waves])
    # only snippets that are similar:
    if len(waves) &gt; 1:
        corr = np.corrcoef(waves)
        nmax = np.argmax(np.sum(corr &gt; min_corr, axis=1))
        if nmax &lt;= 1:
            nmax = 2
        select = np.sum(corr &gt; min_corr, axis=1) &gt;= nmax
        waves = waves[select]
        times = [times[k] for k in range(len(times)) if select[k]]
        if len(waves) == 0:
            return mean_eod, eod_times
    # only the largest snippets:
    ampls = np.std(waves, axis=1)
    select = ampls &gt;= min_ampl_frac*np.max(ampls)
    waves = waves[select]
    times = [times[k] for k in range(len(times)) if select[k]]
    if len(waves) == 0:
        return mean_eod, eod_times
    &#34;&#34;&#34;
    #plt.plot(freqs)
    plt.plot(waves.T)
    plt.show()
    &#34;&#34;&#34;
    mean_eod = np.zeros((n, 3))
    mean_eod[:, 0] = np.arange(len(mean_eod))/rate
    mean_eod[:, 1] = np.mean(waves, axis=0)
    mean_eod[:, 2] = np.std(waves, axis=0)
    eod_times = np.concatenate(times)

    # apply inverse filter:
    if unfilter_cutoff and unfilter_cutoff &gt; 0.0:
        unfilter(mean_eod[:, 1], rate, unfilter_cutoff)
    
    return mean_eod, eod_times</code></pre>
</details>
<div class="desc"><p>Retrieve average EOD waveform via Fourier transform.</p>
<p>TODO: use power spectra to check minimum data segment needed and
check for changes in frequency over several segments!</p>
<p>TODO: return waveform with higher samplign rate? (important for
2kHz waves on 24kHz sampling). But this seems to render some EODs
inacceptable in the further thunderfish processing pipeline.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>1-D array</code> of <code>float</code></dt>
<dd>The data to be analysed.</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Sampling rate of the data in Hertz.</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>float</code></dt>
<dd>EOD frequency.</dd>
<dt><strong><code>win_fac</code></strong> :&ensp;<code>float</code></dt>
<dd>The snippet size is the EOD period times <code>win_fac</code>. The EOD period
is determined as the minimum interval between EOD times.</dd>
<dt><strong><code>unfilter_cutoff</code></strong> :&ensp;<code>float</code></dt>
<dd>If not zero, the cutoff frequency for an inverse high-pass filter
applied to the mean EOD waveform.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mean_eod</code></strong> :&ensp;<code>2-D array</code></dt>
<dd>Average of the EOD snippets. First column is time in seconds,
second column the mean eod, third column the standard error.</dd>
<dt><strong><code>eod_times</code></strong> :&ensp;<code>1-D array</code></dt>
<dd>Times of EOD peaks in seconds that have been actually used to
calculate the averaged EOD waveform.</dd>
</dl></div>
</dd>
<dt id="thunderfish.eodanalysis.unfilter"><code class="name flex">
<span>def <span class="ident">unfilter</span></span>(<span>data, rate, cutoff)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unfilter(data, rate, cutoff):
    &#34;&#34;&#34;Apply inverse high-pass filter on data.

    Assumes high-pass filter
    \\[ \\tau \\dot y = -y + \\tau \\dot x \\]
    has been applied on the original data \\(x\\), where
    \\(\\tau=(2\\pi f_{cutoff})^{-1}\\) is the time constant of the
    filter. To recover \\(x\\) the ODE
    \\[ \\tau \\dot x = y + \\tau \\dot y \\]
    is applied on the filtered data \\(y\\).

    Parameters
    ----------
    data: ndarray
        High-pass filtered original data.
    rate: float
        Sampling rate of `data` in Hertz.
    cutoff: float
        Cutoff frequency \\(f_{cutoff}\\) of the high-pass filter in Hertz.

    Returns
    -------
    data: ndarray
        Recovered original data.
    &#34;&#34;&#34;
    tau = 0.5/np.pi/cutoff
    fac = tau*rate
    data -= np.mean(data)
    d0 = data[0]
    x = d0
    for k in range(len(data)):
        d1 = data[k]
        x += (d1 - d0) + d0/fac
        data[k] = x
        d0 = d1
    return data</code></pre>
</details>
<div class="desc"><p>Apply inverse high-pass filter on data.</p>
<p>Assumes high-pass filter
<span><span class="MathJax_Preview"> \tau \dot y = -y + \tau \dot x </span><script type="math/tex; mode=display"> \tau \dot y = -y + \tau \dot x </script></span>
has been applied on the original data <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>, where
<span><span class="MathJax_Preview">\tau=(2\pi f_{cutoff})^{-1}</span><script type="math/tex">\tau=(2\pi f_{cutoff})^{-1}</script></span> is the time constant of the
filter. To recover <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> the ODE
<span><span class="MathJax_Preview"> \tau \dot x = y + \tau \dot y </span><script type="math/tex; mode=display"> \tau \dot x = y + \tau \dot y </script></span>
is applied on the filtered data <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>High-pass filtered original data.</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Sampling rate of <code>data</code> in Hertz.</dd>
<dt><strong><code>cutoff</code></strong> :&ensp;<code>float</code></dt>
<dd>Cutoff frequency <span><span class="MathJax_Preview">f_{cutoff}</span><script type="math/tex">f_{cutoff}</script></span> of the high-pass filter in Hertz.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Recovered original data.</dd>
</dl></div>
</dd>
<dt id="thunderfish.eodanalysis.fourier_series"><code class="name flex">
<span>def <span class="ident">fourier_series</span></span>(<span>t, freq, *ap)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fourier_series(t, freq, *ap):
    &#34;&#34;&#34;Fourier series of sine waves with amplitudes and phases.

    x(t) = sum_{i=0}^n ap[2*i]*sin(2 pi (i+1) freq t + ap[2*i+1])
    
    Parameters
    ----------
    t: float or array
        Time.
    freq: float
        Fundamental frequency.
    *ap: list of floats
        The amplitudes and phases (in rad) of the fundamental and harmonics.
        
    Returns
    -------
    x: float or array
        The Fourier series evaluated at times `t`.
    &#34;&#34;&#34;
    omega = 2.0*np.pi*freq
    x = 0.0
    for i, (a, p) in enumerate(zip(ap[0:-1:2], ap[1::2])):
        x += a*np.sin((i+1)*omega*t+p)
    return x</code></pre>
</details>
<div class="desc"><p>Fourier series of sine waves with amplitudes and phases.</p>
<p>x(t) = sum_{i=0}^n ap[2<em>i]</em>sin(2 pi (i+1) freq t + ap[2*i+1])</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code> or <code>array</code></dt>
<dd>Time.</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>float</code></dt>
<dd>Fundamental frequency.</dd>
<dt><strong><code>*ap</code></strong> :&ensp;<code>list</code> of <code>floats</code></dt>
<dd>The amplitudes and phases (in rad) of the fundamental and harmonics.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code> or <code>array</code></dt>
<dd>The Fourier series evaluated at times <code>t</code>.</dd>
</dl></div>
</dd>
<dt id="thunderfish.eodanalysis.analyze_wave"><code class="name flex">
<span>def <span class="ident">analyze_wave</span></span>(<span>eod, freq, n_harm=10, power_n_harmonics=0, n_harmonics=3, flip_wave='none')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def analyze_wave(eod, freq, n_harm=10, power_n_harmonics=0,
                 n_harmonics=3, flip_wave=&#39;none&#39;):
    &#34;&#34;&#34;Analyze the EOD waveform of a wave fish.
    
    Parameters
    ----------
    eod: 2-D array
        The eod waveform. First column is time in seconds, second
        column the EOD waveform, third column, if present, is the
        standard error of the EOD waveform, Further columns are
        optional but not used.
    freq: float or 2-D array
        The frequency of the EOD or the list of harmonics (rows) with
        frequency and peak height (columns) as returned from
        `harmonics.harmonic_groups()`.
    n_harm: int
        Maximum number of harmonics used for the Fourier decomposition.
    power_n_harmonics: int
        Sum over the first `power_n_harmonics` harmonics for computing
        the total power.  If 0 sum over all harmonics.
    n_harmonics: int
        The maximum power of higher harmonics is computed from
        harmonics higher than the maximum harmonics within the first
        three harmonics plus `n_harmonics`.
    flip_wave: &#39;auto&#39;, &#39;none&#39;, &#39;flip&#39;
        - &#39;auto&#39; flip waveform such that the larger extremum is positive.
        - &#39;flip&#39; flip waveform.
        - &#39;none&#39; do not flip waveform.
    
    Returns
    -------
    meod: 2-D array of floats
        The eod waveform. First column is time in seconds, second
        column the eod waveform.  Further columns are kept from the
        input `eod`. And a column is added with the fit of the fourier
        series to the waveform.
    props: dict
        A dictionary with properties of the analyzed EOD waveform.

        - type: set to &#39;wave&#39;.
        - EODf: is set to the EOD fundamental frequency.
        - p-p-amplitude: peak-to-peak amplitude of the Fourier fit.
        - flipped: True if the waveform was flipped.
        - amplitude: amplitude factor of the Fourier fit.
        - noise: root-mean squared standard error mean of the averaged
          EOD waveform relative to the p-p amplitude.
        - rmserror: root-mean-square error between Fourier-fit and
          EOD waveform relative to the p-p amplitude. If larger than
          about 0.05 the data are bad.
        - ncrossings: number of zero crossings per period
        - peakwidth: width of the peak at the averaged amplitude relative
          to EOD period.
        - troughwidth: width of the trough at the averaged amplitude
          relative to EOD period.
        - minwidth: peakwidth or troughwidth, whichever is smaller.
        - leftpeak: time from positive zero crossing to peak relative
          to EOD period.
        - rightpeak: time from peak to negative zero crossing relative to
          EOD period.
        - lefttrough: time from negative zero crossing to trough relative to
          EOD period.
        - righttrough: time from trough to positive zero crossing relative to
          EOD period.
        - p-p-distance: time between peak and trough relative to EOD period.
        - min-p-p-distance: p-p-distance or EOD period minus p-p-distance,
          whichever is smaller, relative to EOD period.
        - relpeakampl: amplitude of peak or trough, whichever is larger,
          relative to p-p amplitude.
        - power: summed power of all harmonics of the extracted EOD waveform
          in decibel relative to one.
        - datapower: summed power of all harmonics of the original data in
          decibel relative to one. Only if `freq` is a list of harmonics.
        - thd: total harmonic distortion, i.e. square root of sum of
          amplitudes squared of harmonics relative to amplitude
          of fundamental.  
        - dbdiff: smoothness of power spectrum as standard deviation of
          differences in decibel power.
        - maxdb: maximum power of higher harmonics relative to peak power
          in decibel.

    spec_data: 2-D array of floats
        First six columns are from the spectrum of the extracted
        waveform.  First column is the index of the harmonics, second
        column its frequency, third column its amplitude, fourth
        column its amplitude relative to the fundamental, fifth column
        is power of harmonics relative to fundamental in decibel, and
        sixth column the phase shift relative to the fundamental.
        If `freq` is a list of harmonics, a seventh column is added to
        `spec_data` that contains the powers of the harmonics from the
        original power spectrum of the raw data.  Rows are the
        harmonics, first row is the fundamental frequency with index
        0, relative amplitude of one, relative power of 0dB, and phase
        shift of zero.
    error_str: string
        If fitting of the fourier series failed,
        this is reported in this string.

    Raises
    ------
    IndexError:
        EOD data is less than one period long.
    &#34;&#34;&#34;
    error_str = &#39;&#39;
    
    freq0 = freq
    if hasattr(freq, &#39;shape&#39;):
        freq0 = freq[0][0]
        
    # storage:
    meod = np.zeros((eod.shape[0], eod.shape[1]+1))
    meod[:,:-1] = eod

    # subtract mean and flip:
    period = 1.0/freq0
    pinx = int(np.ceil(period/(meod[1,0]-meod[0,0])))
    maxn = (len(meod)//pinx)*pinx
    if maxn &lt; pinx: maxn = len(meod)
    offs = (len(meod) - maxn)//2
    meod[:,1] -= np.mean(meod[offs:offs+pinx,1])
    flipped = False
    if &#39;flip&#39; in flip_wave or (&#39;auto&#39; in flip_wave and -np.min(meod[:,1]) &gt; np.max(meod[:,1])):
        meod[:,1] = -meod[:,1]
        flipped = True
    
    # move peak of waveform to zero:
    offs = len(meod)//4
    maxinx = offs+np.argmax(meod[offs:3*offs,1])
    meod[:,0] -= meod[maxinx,0]
    
    # indices of exactly one or two periods around peak:
    if len(meod) &lt; pinx:
        raise IndexError(&#39;data need to contain at least one EOD period&#39;)
    if len(meod) &gt;= 2*pinx:
        i0 = maxinx - pinx if maxinx &gt;= pinx else 0
        i1 = i0 + 2*pinx
        if i1 &gt; len(meod):
            i1 = len(meod)
            i0 = i1 - 2*pinx
    else:
        i0 = maxinx - pinx//2 if maxinx &gt;= pinx//2 else 0
        i1 = i0 + pinx

    # subtract mean:
    meod[:,1] -= np.mean(meod[i0:i1,1])

    # zero crossings:
    ui, di = threshold_crossings(meod[:,1], 0.0)
    ut, dt = threshold_crossing_times(meod[:,0], meod[:,1], 0.0, ui, di)
    ut, dt = merge_events(ut, dt, 0.02/freq0)
    ncrossings = int(np.round((len(ut) + len(dt))/(meod[-1,0]-meod[0,0])/freq0))
    if np.any(ut&lt;0.0):    
        up_time = ut[ut&lt;0.0][-1]
    else:
        up_time = 0.0 
        error_str += &#39;%.1f Hz wave fish: no upward zero crossing. &#39; % freq0
    if np.any(dt&gt;0.0):
        down_time = dt[dt&gt;0.0][0]
    else:
        down_time = 0.0
        error_str += &#39;%.1f Hz wave fish: no downward zero crossing. &#39; % freq0
    peak_width = down_time - up_time
    trough_width = period - peak_width
    peak_time = 0.0
    trough_time = meod[maxinx+np.argmin(meod[maxinx:maxinx+pinx,1]),0]
    phase1 = peak_time - up_time
    phase2 = down_time - peak_time
    phase3 = trough_time - down_time
    phase4 = up_time + period - trough_time
    distance = trough_time - peak_time
    min_distance = distance
    if distance &gt; period/2:
        min_distance = period - distance
    
    # fit fourier series:
    ampl = 0.5*(np.max(meod[:,1])-np.min(meod[:,1]))
    while n_harm &gt; 1:
        params = [freq0]
        for i in range(1, n_harm+1):
            params.extend([ampl/i, 0.0])
        try:
            popt, pcov = curve_fit(fourier_series, meod[i0:i1,0],
                                   meod[i0:i1,1], params, maxfev=2000)
            break
        except (RuntimeError, TypeError):
            error_str += &#39;%.1f Hz wave fish: fit of fourier series failed for %d harmonics. &#39; % (freq0, n_harm)
            n_harm //= 2
    # store fourier fit:
    meod[:,-1] = fourier_series(meod[:,0], *popt)
    # make all amplitudes positive:
    for i in range(n_harm):
        if popt[i*2+1] &lt; 0.0:
            popt[i*2+1] *= -1.0
            popt[i*2+2] += np.pi
    # phases relative to fundamental:
    # phi0 = 2*pi*f0*dt &lt;=&gt; dt = phi0/(2*pi*f0)
    # phik = 2*pi*i*f0*dt = i*phi0
    phi0 = popt[2]
    for i in range(n_harm):
        popt[i*2+2] -= (i + 1)*phi0
        # all phases in the range -pi to pi:
        popt[i*2+2] %= 2*np.pi
        if popt[i*2+2] &gt; np.pi:
            popt[i*2+2] -= 2*np.pi
    # store fourier spectrum:
    if hasattr(freq, &#39;shape&#39;):
        n = n_harm
        n += np.sum(freq[:,0] &gt; (n_harm+0.5)*freq[0,0])
        spec_data = np.zeros((n, 7))
        spec_data[:,:] = np.nan
        k = 0
        for i in range(n_harm):
            while k &lt; len(freq) and freq[k,0] &lt; (i+0.5)*freq0:
                k += 1
            if k &gt;= len(freq):
                break
            if freq[k,0] &lt; (i+1.5)*freq0:
                spec_data[i,6] = freq[k,1]
                k += 1
        for i in range(n_harm, n):
            if k &gt;= len(freq):
                break
            spec_data[i,:2] = [np.round(freq[k,0]/freq0)-1, freq[k,0]]
            spec_data[i,6] = freq[k,1]
            k += 1
    else:
        spec_data = np.zeros((n_harm, 6))
    for i in range(n_harm):
        spec_data[i,:6] = [i, (i+1)*freq0, popt[i*2+1], popt[i*2+1]/popt[1],
                           decibel((popt[i*2+1]/popt[1])**2.0), popt[i*2+2]]
    # smoothness of power spectrum:
    db_powers = decibel(spec_data[:n_harm,2]**2)
    db_diff = np.std(np.diff(db_powers))
    # maximum relative power of higher harmonics:
    p_max = np.argmax(db_powers[:3])
    db_powers -= db_powers[p_max]
    if len(db_powers[p_max+n_harmonics:]) == 0:
        max_harmonics_power = -100.0
    else:
        max_harmonics_power = np.max(db_powers[p_max+n_harmonics:])
    # total harmonic distortion:
    thd = np.sqrt(np.nansum(spec_data[1:,3]))

    # peak-to-peak and trough amplitudes:
    ppampl = np.max(meod[i0:i1,1]) - np.min(meod[i0:i1,1])
    relpeakampl = max(np.max(meod[i0:i1,1]), np.abs(np.min(meod[i0:i1,1])))/ppampl
    
    # variance and fit error:
    rmssem = np.sqrt(np.mean(meod[i0:i1,2]**2.0))/ppampl if eod.shape[1] &gt; 2 else None
    rmserror = np.sqrt(np.mean((meod[i0:i1,1] - meod[i0:i1,-1])**2.0))/ppampl

    # store results:
    props = {}
    props[&#39;type&#39;] = &#39;wave&#39;
    props[&#39;EODf&#39;] = freq0
    props[&#39;p-p-amplitude&#39;] = ppampl
    props[&#39;flipped&#39;] = flipped
    props[&#39;amplitude&#39;] = 0.5*ppampl  # remove it
    props[&#39;rmserror&#39;] = rmserror
    if rmssem:
        props[&#39;noise&#39;] = rmssem
    props[&#39;ncrossings&#39;] = ncrossings
    props[&#39;peakwidth&#39;] = peak_width/period
    props[&#39;troughwidth&#39;] = trough_width/period
    props[&#39;minwidth&#39;] = min(peak_width, trough_width)/period
    props[&#39;leftpeak&#39;] = phase1/period
    props[&#39;rightpeak&#39;] = phase2/period
    props[&#39;lefttrough&#39;] = phase3/period
    props[&#39;righttrough&#39;] = phase4/period
    props[&#39;p-p-distance&#39;] = distance/period
    props[&#39;min-p-p-distance&#39;] = min_distance/period
    props[&#39;relpeakampl&#39;] = relpeakampl
    pnh = power_n_harmonics if power_n_harmonics &gt; 0 else n_harm
    pnh = min(n_harm, pnh)
    props[&#39;power&#39;] = decibel(np.sum(spec_data[:pnh,2]**2.0))
    if hasattr(freq, &#39;shape&#39;):
        props[&#39;datapower&#39;] = decibel(np.sum(freq[:pnh,1]))
    props[&#39;thd&#39;] = thd
    props[&#39;dbdiff&#39;] = db_diff
    props[&#39;maxdb&#39;] = max_harmonics_power
    
    return meod, props, spec_data, error_str</code></pre>
</details>
<div class="desc"><p>Analyze the EOD waveform of a wave fish.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>eod</code></strong> :&ensp;<code>2-D array</code></dt>
<dd>The eod waveform. First column is time in seconds, second
column the EOD waveform, third column, if present, is the
standard error of the EOD waveform, Further columns are
optional but not used.</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>float</code> or <code>2-D array</code></dt>
<dd>The frequency of the EOD or the list of harmonics (rows) with
frequency and peak height (columns) as returned from
<code>harmonics.harmonic_groups()</code>.</dd>
<dt><strong><code>n_harm</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of harmonics used for the Fourier decomposition.</dd>
<dt><strong><code>power_n_harmonics</code></strong> :&ensp;<code>int</code></dt>
<dd>Sum over the first <code>power_n_harmonics</code> harmonics for computing
the total power.
If 0 sum over all harmonics.</dd>
<dt><strong><code>n_harmonics</code></strong> :&ensp;<code>int</code></dt>
<dd>The maximum power of higher harmonics is computed from
harmonics higher than the maximum harmonics within the first
three harmonics plus <code>n_harmonics</code>.</dd>
<dt><strong><code>flip_wave</code></strong> :&ensp;<code>'auto', 'none', 'flip'</code></dt>
<dd>
<ul>
<li>'auto' flip waveform such that the larger extremum is positive.</li>
<li>'flip' flip waveform.</li>
<li>'none' do not flip waveform.</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>meod</code></strong> :&ensp;<code>2-D array</code> of <code>floats</code></dt>
<dd>The eod waveform. First column is time in seconds, second
column the eod waveform.
Further columns are kept from the
input <code>eod</code>. And a column is added with the fit of the fourier
series to the waveform.</dd>
<dt><strong><code>props</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>A dictionary with properties of the analyzed EOD waveform.</p>
<ul>
<li>type: set to 'wave'.</li>
<li>EODf: is set to the EOD fundamental frequency.</li>
<li>p-p-amplitude: peak-to-peak amplitude of the Fourier fit.</li>
<li>flipped: True if the waveform was flipped.</li>
<li>amplitude: amplitude factor of the Fourier fit.</li>
<li>noise: root-mean squared standard error mean of the averaged
EOD waveform relative to the p-p amplitude.</li>
<li>rmserror: root-mean-square error between Fourier-fit and
EOD waveform relative to the p-p amplitude. If larger than
about 0.05 the data are bad.</li>
<li>ncrossings: number of zero crossings per period</li>
<li>peakwidth: width of the peak at the averaged amplitude relative
to EOD period.</li>
<li>troughwidth: width of the trough at the averaged amplitude
relative to EOD period.</li>
<li>minwidth: peakwidth or troughwidth, whichever is smaller.</li>
<li>leftpeak: time from positive zero crossing to peak relative
to EOD period.</li>
<li>rightpeak: time from peak to negative zero crossing relative to
EOD period.</li>
<li>lefttrough: time from negative zero crossing to trough relative to
EOD period.</li>
<li>righttrough: time from trough to positive zero crossing relative to
EOD period.</li>
<li>p-p-distance: time between peak and trough relative to EOD period.</li>
<li>min-p-p-distance: p-p-distance or EOD period minus p-p-distance,
whichever is smaller, relative to EOD period.</li>
<li>relpeakampl: amplitude of peak or trough, whichever is larger,
relative to p-p amplitude.</li>
<li>power: summed power of all harmonics of the extracted EOD waveform
in decibel relative to one.</li>
<li>datapower: summed power of all harmonics of the original data in
decibel relative to one. Only if <code>freq</code> is a list of harmonics.</li>
<li>thd: total harmonic distortion, i.e. square root of sum of
amplitudes squared of harmonics relative to amplitude
of fundamental.
</li>
<li>dbdiff: smoothness of power spectrum as standard deviation of
differences in decibel power.</li>
<li>maxdb: maximum power of higher harmonics relative to peak power
in decibel.</li>
</ul>
</dd>
<dt><strong><code>spec_data</code></strong> :&ensp;<code>2-D array</code> of <code>floats</code></dt>
<dd>First six columns are from the spectrum of the extracted
waveform.
First column is the index of the harmonics, second
column its frequency, third column its amplitude, fourth
column its amplitude relative to the fundamental, fifth column
is power of harmonics relative to fundamental in decibel, and
sixth column the phase shift relative to the fundamental.
If <code>freq</code> is a list of harmonics, a seventh column is added to
<code>spec_data</code> that contains the powers of the harmonics from the
original power spectrum of the raw data.
Rows are the
harmonics, first row is the fundamental frequency with index
0, relative amplitude of one, relative power of 0dB, and phase
shift of zero.</dd>
<dt><strong><code>error_str</code></strong> :&ensp;<code>string</code></dt>
<dd>If fitting of the fourier series failed,
this is reported in this string.</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="indexerror">Indexerror</h2>
<p>EOD data is less than one period long.</p></div>
</dd>
<dt id="thunderfish.eodanalysis.exp_decay"><code class="name flex">
<span>def <span class="ident">exp_decay</span></span>(<span>t, tau, ampl, offs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exp_decay(t, tau, ampl, offs):
    &#34;&#34;&#34;Exponential decay function.

    x(t) = ampl*exp(-t/tau) + offs

    Parameters
    ----------
    t: float or array
        Time.
    tau: float
        Time constant of exponential decay.
    ampl: float
        Amplitude of exponential decay, i.e. initial value minus
        steady-state value.
    offs: float
        Steady-state value.
    
    Returns
    -------
    x: float or array
        The exponential decay evaluated at times `t`.

    &#34;&#34;&#34;
    return offs + ampl*np.exp(-t/tau)</code></pre>
</details>
<div class="desc"><p>Exponential decay function.</p>
<p>x(t) = ampl*exp(-t/tau) + offs</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code> or <code>array</code></dt>
<dd>Time.</dd>
<dt><strong><code>tau</code></strong> :&ensp;<code>float</code></dt>
<dd>Time constant of exponential decay.</dd>
<dt><strong><code>ampl</code></strong> :&ensp;<code>float</code></dt>
<dd>Amplitude of exponential decay, i.e. initial value minus
steady-state value.</dd>
<dt><strong><code>offs</code></strong> :&ensp;<code>float</code></dt>
<dd>Steady-state value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code> or <code>array</code></dt>
<dd>The exponential decay evaluated at times <code>t</code>.</dd>
</dl></div>
</dd>
<dt id="thunderfish.eodanalysis.analyze_pulse"><code class="name flex">
<span>def <span class="ident">analyze_pulse</span></span>(<span>eod,<br>eod_times=None,<br>min_pulse_win=0.001,<br>peak_thresh_fac=0.01,<br>min_dist=5e-05,<br>width_frac=0.5,<br>fit_frac=0.5,<br>freq_resolution=1.0,<br>flip_pulse='none',<br>ipi_cv_thresh=0.5,<br>ipi_percentile=30.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def analyze_pulse(eod, eod_times=None, min_pulse_win=0.001,
                  peak_thresh_fac=0.01, min_dist=50.0e-6,
                  width_frac=0.5, fit_frac = 0.5, freq_resolution=1.0,
                  flip_pulse=&#39;none&#39;, ipi_cv_thresh=0.5,
                  ipi_percentile=30.0):
    &#34;&#34;&#34;Analyze the EOD waveform of a pulse fish.
    
    Parameters
    ----------
    eod: 2-D array
        The eod waveform. First column is time in seconds, second
        column the EOD waveform, third column, if present, is the
        standard error of the EOD waveform, Further columns are
        optional but not used.
    eod_times: 1-D array or None
        List of times of detected EOD peaks.
    min_pulse_win: float
        The minimum size of cut-out EOD waveform.
    peak_thresh_fac: float
        Set the threshold for peak detection to the maximum pulse
        amplitude times this factor.
    min_dist: float
        Minimum distance between peak and troughs of the pulse.
    width_frac: float
        The width of a peak is measured at this fraction of a peak&#39;s
        height (0-1).
    fit_frac: float or None
        An exponential is fitted to the tail of the last peak/trough
        starting where the waveform falls below this fraction of the
        peak&#39;s height (0-1).
    freq_resolution: float
        The frequency resolution of the power spectrum of the single pulse.
    flip_pulse: &#39;auto&#39;, &#39;none&#39;, &#39;flip&#39;
        - &#39;auto&#39; flip waveform such that the first large extremum is positive.
        - &#39;flip&#39; flip waveform.
        - &#39;none&#39; do not flip waveform.
    ipi_cv_thresh: float
        If the coefficient of variation of the interpulse intervals
        are smaller than this threshold, then the EOD frequency is
        computed as the inverse of the mean of all interpulse
        intervals. Otherwise only intervals smaller than a certain
        quantile are used.
    ipi_percentile: float
        When computing the EOD frequency, period, mean and standard
        deviation of interpulse intervals from a subset of the
        interpulse intervals, only intervals smaller than this
        percentile (between 0 and 100) are used.
    
    Returns
    -------
    meod: 2-D array of floats
        The eod waveform. First column is time in seconds,
        second column the eod waveform.
        Further columns are kept from the input `eod`.
        As a last column the fit to the tail of the last peak is appended.
    props: dict
        A dictionary with properties of the analyzed EOD waveform.

        - type: set to &#39;pulse&#39;.
        - EODf: the inverse of the median interval between `eod_times`,
          if provided.
        - period: the median interval between `eod_times`, if provided.
        - IPI-mean: the mean interval between `eod_times`, if provided.
        - IPI-std: the standard deviation of the intervals between
          `eod_times`, if provided.
        - max-ampl: the amplitude of the largest positive peak (P1).
        - min-ampl: the amplitude of the largest negative peak (P2).
        - p-p-amplitude: peak-to-peak amplitude of the EOD waveform.
        - noise: root-mean squared standard error mean of the averaged
          EOD waveform relative to the p-p amplitude.
        - tstart: time in seconds where the pulse starts,
          i.e. crosses the threshold for the first time.
        - tend: time in seconds where the pulse ends,
          i.e. crosses the threshold for the last time.
        - width: total width of the pulse in seconds (tend-tstart).
        - P2-P1-dist: distance between P2 and P1 in seconds.
        - tau: time constant of exponential decay of pulse tail in seconds.
        - firstpeak: index of the first peak in the pulse (i.e. -1 for P-1)
        - lastpeak: index of the last peak in the pulse (i.e. 3 for P3)
        - totalarea: sum of areas under positive and negative peaks.
        - positivearea: area under positive peaks relative to total area.
        - negativearea: area under negative peaks relative to total area.
        - polaritybalance: contrast between areas under positive and
          negative peak.
        - peakfreq: frequency at peak power of the single pulse spectrum
          in Hertz.
        - peakpower: peak power of the single pulse spectrum in decibel.
        - poweratt5: how much the average power below 5 Hz is attenuated
          relative to the peak power in decibel.
        - poweratt50: how much the average power below 5 Hz is attenuated
          relative to the peak power in decibel.
        - lowcutoff: frequency at which the power reached half of the
          peak power relative to the initial power in Hertz.
        - flipped: True if the waveform was flipped.
        - n: number of pulses analyzed  (i.e. `len(eod_times)`), if provided.
        - times: the times of the detected EOD pulses (i.e. `eod_times`),
          if provided.

        Empty if waveform is not a pulse EOD.
    peaks: 2-D array
        For each peak and trough (rows) of the EOD waveform
        7 columns: the peak index (1 is P1, i.e. the largest positive peak),
        time relative to largest positive peak, amplitude,
        amplitude normalized to largest postive peak,
        width of peak/trough at half height,
        area under the peak, and area under the peak relative to total area.
        Empty if waveform is not a pulse EOD.
    power: 2-D array
        The power spectrum of a single pulse. First column are the
        frequencies, second column the power in x^2/Hz such that the
        integral equals the variance.  Empty if waveform is not a
        pulse EOD.

    &#34;&#34;&#34;
    # storage:
    meod = np.zeros((eod.shape[0], eod.shape[1]+1))
    meod[:,:eod.shape[1]] = eod
    meod[:,-1] = np.nan
    toffs = 0
    
    # cut out stable estimate if standard deviation is available:
    if eod.shape[1] &gt; 2 and np.max(meod[:,2]) &gt; 3*np.min(meod[:,2]):
        n = len(meod)
        idx0 = np.argmax(np.abs(meod[n//10:9*n//10,1])) + n//10
        toffs += meod[idx0,0]
        meod[:,0] -= meod[idx0,0]
        # minimum in standard deviation:
        lstd_idx = np.argmin(meod[:idx0-5,2])
        rstd_idx = np.argmin(meod[idx0+5:,2]) + idx0
        # central, left, and right maximum of standard deviation:
        max_std = np.max(meod[lstd_idx:rstd_idx,2])
        l_std = np.max(meod[:len(meod)//4,2])
        r_std = np.max(meod[len(meod)*3//4:,2])
        lidx = 0
        ridx = len(meod)
        if l_std &gt; max_std and lstd_idx &gt; lidx:
            lidx = lstd_idx - np.argmax(meod[lstd_idx:0:-1,2] &gt;= 0.25*l_std + 0.75*meod[lstd_idx,2])
        if r_std &gt; max_std and rstd_idx &lt; ridx:
            ridx = rstd_idx + np.argmax(meod[rstd_idx:,2] &gt;= 0.25*r_std + 0.75*meod[rstd_idx,2])
        #plt.plot(meod[:,0], meod[:,1])
        #plt.plot(meod[:,0], meod[:,2], &#39;-r&#39;)
        #plt.plot([meod[lidx,0], meod[lidx,0]], [-0.1, 0.1], &#39;-k&#39;)
        #plt.plot([meod[ridx-1,0], meod[ridx-1,0]], [-0.1, 0.1], &#39;-b&#39;)
        #plt.show()
        meod = meod[lidx:ridx,:]
    
    # subtract mean computed from the ends of the snippet:
    n = len(meod)//20 if len(meod) &gt;= 20 else 1
    meod[:,1] -= 0.5*(np.mean(meod[:n,1]) + np.mean(meod[-n:,1]))

    # largest positive and negative peak:
    flipped = False
    max_idx = np.argmax(meod[:,1])
    max_ampl = np.abs(meod[max_idx,1])
    min_idx = np.argmin(meod[:,1])
    min_ampl = np.abs(meod[min_idx,1])
    amplitude = np.max((max_ampl, min_ampl))
    if max_ampl &gt; 0.2*amplitude and min_ampl &gt; 0.2*amplitude:
        # two major peaks:
        if &#39;flip&#39; in flip_pulse or (&#39;auto&#39; in flip_pulse and min_idx &lt; max_idx):
            # flip:
            meod[:,1] = -meod[:,1]
            peak_idx = min_idx
            min_idx = max_idx
            max_idx = peak_idx
            flipped = True
    elif &#39;flip&#39; in flip_pulse or (&#39;auto&#39; in flip_pulse and min_ampl &gt; 0.2*amplitude):
        # flip:
        meod[:,1] = -meod[:,1]
        peak_idx = min_idx
        min_idx = max_idx
        max_idx = peak_idx
        flipped = True
    max_ampl = np.abs(meod[max_idx,1])
    min_ampl = np.abs(meod[min_idx,1])
                
    # move peak of waveform to zero:
    toffs += meod[max_idx,0]
    meod[:,0] -= meod[max_idx,0]

    # minimum threshold for peak detection:
    n = len(meod[:,1])//10 if len(meod) &gt;= 20 else 2
    thl_max = np.max(meod[:n,1])
    thl_min = np.min(meod[:n,1])
    thr_max = np.max(meod[-n:,1])
    thr_min = np.min(meod[-n:,1])
    min_thresh = 2*np.max([thl_max, thr_max]) - np.min([thl_min, thr_min])
    if min_thresh &gt; 0.5*(max_ampl + min_ampl):
        min_thresh = 0.5*(max_ampl + min_ampl)
        fit_frac = None
    # threshold for peak detection:
    threshold = max_ampl*peak_thresh_fac
    if threshold &lt; min_thresh:
        threshold = min_thresh
    if threshold &lt;= 0.0:
        return meod, {}, [], []
        
    # cut out relevant signal:
    lidx = np.argmax(np.abs(meod[:,1]) &gt; threshold)
    ridx = len(meod) - 1 - np.argmax(np.abs(meod[::-1,1]) &gt; threshold)
    t0 = meod[lidx,0]
    t1 = meod[ridx,0]
    width = t1 - t0
    if width &lt; min_pulse_win:
        width = min_pulse_win
    dt = meod[1,0] - meod[0,0]
    width_idx = int(np.round(width/dt))
    # expand width:
    leidx = lidx - width_idx//2
    if leidx &lt; 0:
        leidx = 0
    reidx = ridx + width_idx//2
    if reidx &gt;= len(meod):
        reidx = len(meod)
    meod = meod[leidx:reidx,:]
    lidx -= leidx
    ridx -= leidx
    max_idx -= leidx
    min_idx -= leidx
    tau = None
    dist = 0.0
    peaks = []

    # amplitude and variance:
    ppampl = max_ampl + min_ampl
    rmssem = np.sqrt(np.mean(meod[:,2]**2.0))/ppampl if eod.shape[1] &gt; 2 else None

    # integrals and polarity balance:
    pos_area = np.sum(meod[meod[:,1] &gt; 0,1])*dt
    neg_area = np.sum(meod[meod[:,1] &lt; 0,1])*dt
    total_area = pos_area - neg_area
    polarity_balance = (pos_area + neg_area)/total_area
    
    # find smaller peaks:
    peak_idx, trough_idx = detect_peaks(meod[:,1], threshold)
    
    if len(peak_idx) &gt; 0:
        # and their width:
        peak_widths = peak_width(meod[:,0], meod[:,1], peak_idx, trough_idx,
                                 peak_frac=width_frac, base=&#39;max&#39;)
        trough_widths = peak_width(meod[:,0], -meod[:,1], trough_idx, peak_idx,
                                   peak_frac=width_frac, base=&#39;max&#39;)
        # combine peaks and troughs:
        pt_idx = np.concatenate((peak_idx, trough_idx))
        pt_widths = np.concatenate((peak_widths, trough_widths))
        pts_idx = np.argsort(pt_idx)
        peak_list = pt_idx[pts_idx]
        width_list = pt_widths[pts_idx]
        # remove multiple peaks that are too close: XXX replace by Dexters function that keeps the maximum peak
        rmidx = [(k, k+1) for k in np.where(np.diff(meod[peak_list,0]) &lt; min_dist)[0]]
        # flatten and keep maximum peak:
        rmidx = np.unique([k for kk in rmidx for k in kk if peak_list[k] != max_idx])
        # delete:
        if len(rmidx) &gt; 0:
            peak_list = np.delete(peak_list, rmidx)
            width_list = np.delete(width_list, rmidx)
        if len(peak_list) == 0:
            return meod, {}, [], []
        # find P1:
        p1i = np.argmax(peak_list == max_idx)
        # truncate peaks to the left: XXX REALLY? WHY?
        offs = 0 if p1i &lt;= 2 else p1i - 2
        peak_list = peak_list[offs:]
        width_list = width_list[offs:]
        p1i -= offs
        # peak areas:
        peak_areas = np.zeros(len(peak_list))
        for i in range(len(peak_list)):
            sign_fac = np.sign(meod[peak_list[i],1])
            i0 = peak_list[i - 1] if i &gt; 0 else 0
            i1 = peak_list[i + 1] if i + 1 &lt; len(peak_list) else len(meod)
            snippet = sign_fac*meod[i0:i1,1]
            peak_areas[i] = sign_fac*np.sum(snippet[snippet &gt; 0])*dt
        # store peaks:
        peaks = np.zeros((len(peak_list), 7))
        for i, pi in enumerate(peak_list):
            peaks[i,:] = [i+1-p1i, meod[pi,0], meod[pi,1], meod[pi,1]/max_ampl, width_list[i], peak_areas[i], peak_areas[i]/total_area]
        # P2 - P1 distance:
        dist = peaks[p1i+1,1] - peaks[p1i,1] if p1i+1 &lt; len(peaks) else 0.0
        # fit exponential to last peak/trough:
        pi = peak_list[-1]
        # positive or negative decay:
        sign = 1.0
        if np.sum(meod[pi:,1] &lt; -0.5*threshold) &gt; np.sum(meod[pi:,1] &gt; 0.5*threshold):
            sign = -1.0
        if sign*meod[pi,1] &lt; 0.0:
            pi += np.argmax(sign*meod[pi:,1])
        pi_ampl = np.abs(meod[pi,1])
        n = len(meod[pi:])
        # no sufficiently large initial value:
        if fit_frac and pi_ampl*fit_frac &lt;= 0.5*threshold:
            fit_frac = False
        # no sufficiently long decay:
        if n &lt; 10:
            fit_frac = False
        # not decaying towards zero:
        max_line = pi_ampl - (pi_ampl-threshold)*np.arange(n)/n + 1e-8
        if np.any(np.abs(meod[pi+2:,1]) &gt; max_line[2:]):
            fit_frac = False
        if fit_frac:
            thresh = meod[pi,1]*fit_frac
            inx = pi + np.argmax(sign*meod[pi:,1] &lt; sign*thresh)
            thresh = meod[inx,1]*np.exp(-1.0)
            tau_inx = np.argmax(sign*meod[inx:,1] &lt; sign*thresh)
            if tau_inx &lt; 2:
                tau_inx = 2
            rridx = inx + 6*tau_inx
            if rridx &gt; len(meod)-1:
                tau = None
            else:
                tau = meod[inx+tau_inx,0]-meod[inx,0]
                params = [tau, meod[inx,1]-meod[rridx,1], meod[rridx,1]]
                try:
                    popt, pcov = curve_fit(exp_decay, meod[inx:rridx,0]-meod[inx,0],
                                           meod[inx:rridx,1], params,
                                           bounds=([0.0, -np.inf, -np.inf], np.inf))
                except TypeError:
                    popt, pcov = curve_fit(exp_decay, meod[inx:rridx,0]-meod[inx,0],
                                           meod[inx:rridx,1], params)
                if popt[0] &gt; 1.2*tau:
                    tau_inx = int(np.round(popt[0]/dt))
                    rridx = inx + 6*tau_inx
                    if rridx &gt; len(meod)-1:
                        rridx = len(meod)-1
                    try:
                        popt, pcov = curve_fit(exp_decay, meod[inx:rridx,0]-meod[inx,0],
                                               meod[inx:rridx,1], popt,
                                               bounds=([0.0, -np.inf, -np.inf], np.inf))
                    except TypeError:
                        popt, pcov = curve_fit(exp_decay, meod[inx:rridx,0]-meod[inx,0],
                                               meod[inx:rridx,1], popt)
                tau = popt[0]
                meod[inx:rridx,-1] = exp_decay(meod[inx:rridx,0]-meod[inx,0], *popt)

    # power spectrum of single pulse:
    rate = 1.0/(meod[1,0]-meod[0,0])
    n_fft = nfft(rate, freq_resolution)

    n0 = max_idx
    n1 = len(meod)-max_idx
    n = 2*max(n0, n1)
    if n_fft &lt; n:
        n_fft = next_power_of_two(n)
    data = np.zeros(n_fft)
    data[n_fft//2-n0:n_fft//2+n1] = meod[:,1]
    nr = n//4
    data[n_fft//2-n0:n_fft//2-n0+nr] *= np.arange(nr)/nr
    data[n_fft//2+n1-nr:n_fft//2+n1] *= np.arange(nr)[::-1]/nr
    freqs = np.fft.rfftfreq(n_fft, 1.0/rate)
    fourier = np.fft.rfft(data)/n_fft/freqs[1]
    power = np.abs(fourier)**2.0
    ppower = np.zeros((len(power), 2))

    ppower[:,0] = freqs
    ppower[:,1] = power
    maxpower = np.max(power)
    att5 = decibel(np.mean(power[freqs&lt;5.0]), maxpower)
    att50 = decibel(np.mean(power[freqs&lt;50.0]), maxpower)
    lowcutoff = freqs[decibel(power, maxpower) &gt; 0.5*att5][0]

    # analyze pulse timing:
    if eod_times is not None:
        inter_pulse_intervals = np.diff(eod_times)
        ipi_cv = np.std(inter_pulse_intervals)/np.mean(inter_pulse_intervals)
        if ipi_cv &lt; ipi_cv_thresh:
            period = np.median(inter_pulse_intervals)
            ipi_mean = np.mean(inter_pulse_intervals)
            ipi_std = np.std(inter_pulse_intervals)
        else:
            intervals = inter_pulse_intervals[inter_pulse_intervals &lt;
                                    np.percentile(inter_pulse_intervals, ipi_percentile)]
            period = np.median(intervals)
            ipi_mean = np.mean(intervals)
            ipi_std = np.std(intervals)
    
    # store properties:
    props = {}
    props[&#39;type&#39;] = &#39;pulse&#39;
    if eod_times is not None:
        props[&#39;EODf&#39;] = 1.0/period
        props[&#39;period&#39;] = period
        props[&#39;IPI-mean&#39;] = ipi_mean
        props[&#39;IPI-std&#39;] = ipi_std
    props[&#39;max-ampl&#39;] = max_ampl
    props[&#39;min-ampl&#39;] = min_ampl
    props[&#39;p-p-amplitude&#39;] = ppampl
    if rmssem:
        props[&#39;noise&#39;] = rmssem
    props[&#39;tstart&#39;] = t0
    props[&#39;tend&#39;] = t1
    props[&#39;width&#39;] = t1 - t0
    props[&#39;P2-P1-dist&#39;] = dist
    if tau:
        props[&#39;tau&#39;] = tau
    props[&#39;firstpeak&#39;] = peaks[0, 0] if len(peaks) &gt; 0 else 1
    props[&#39;lastpeak&#39;] = peaks[-1, 0] if len(peaks) &gt; 0 else 1
    props[&#39;totalarea&#39;] = total_area
    props[&#39;positivearea&#39;] = pos_area/total_area
    props[&#39;negativearea&#39;] = neg_area/total_area
    props[&#39;polaritybalance&#39;] = polarity_balance
    props[&#39;peakfreq&#39;] = freqs[np.argmax(power)]
    props[&#39;peakpower&#39;] = decibel(maxpower)
    props[&#39;poweratt5&#39;] = att5
    props[&#39;poweratt50&#39;] = att50
    props[&#39;lowcutoff&#39;] = lowcutoff
    props[&#39;flipped&#39;] = flipped
    if eod_times is not None:
        props[&#39;n&#39;] = len(eod_times)
        props[&#39;times&#39;] = eod_times + toffs
    
    return meod, props, peaks, ppower</code></pre>
</details>
<div class="desc"><p>Analyze the EOD waveform of a pulse fish.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>eod</code></strong> :&ensp;<code>2-D array</code></dt>
<dd>The eod waveform. First column is time in seconds, second
column the EOD waveform, third column, if present, is the
standard error of the EOD waveform, Further columns are
optional but not used.</dd>
<dt><strong><code>eod_times</code></strong> :&ensp;<code>1-D array</code> or <code>None</code></dt>
<dd>List of times of detected EOD peaks.</dd>
<dt><strong><code>min_pulse_win</code></strong> :&ensp;<code>float</code></dt>
<dd>The minimum size of cut-out EOD waveform.</dd>
<dt><strong><code>peak_thresh_fac</code></strong> :&ensp;<code>float</code></dt>
<dd>Set the threshold for peak detection to the maximum pulse
amplitude times this factor.</dd>
<dt><strong><code>min_dist</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum distance between peak and troughs of the pulse.</dd>
<dt><strong><code>width_frac</code></strong> :&ensp;<code>float</code></dt>
<dd>The width of a peak is measured at this fraction of a peak's
height (0-1).</dd>
<dt><strong><code>fit_frac</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>An exponential is fitted to the tail of the last peak/trough
starting where the waveform falls below this fraction of the
peak's height (0-1).</dd>
<dt><strong><code>freq_resolution</code></strong> :&ensp;<code>float</code></dt>
<dd>The frequency resolution of the power spectrum of the single pulse.</dd>
<dt><strong><code>flip_pulse</code></strong> :&ensp;<code>'auto', 'none', 'flip'</code></dt>
<dd>
<ul>
<li>'auto' flip waveform such that the first large extremum is positive.</li>
<li>'flip' flip waveform.</li>
<li>'none' do not flip waveform.</li>
</ul>
</dd>
<dt><strong><code>ipi_cv_thresh</code></strong> :&ensp;<code>float</code></dt>
<dd>If the coefficient of variation of the interpulse intervals
are smaller than this threshold, then the EOD frequency is
computed as the inverse of the mean of all interpulse
intervals. Otherwise only intervals smaller than a certain
quantile are used.</dd>
<dt><strong><code>ipi_percentile</code></strong> :&ensp;<code>float</code></dt>
<dd>When computing the EOD frequency, period, mean and standard
deviation of interpulse intervals from a subset of the
interpulse intervals, only intervals smaller than this
percentile (between 0 and 100) are used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>meod</code></strong> :&ensp;<code>2-D array</code> of <code>floats</code></dt>
<dd>The eod waveform. First column is time in seconds,
second column the eod waveform.
Further columns are kept from the input <code>eod</code>.
As a last column the fit to the tail of the last peak is appended.</dd>
<dt><strong><code>props</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>A dictionary with properties of the analyzed EOD waveform.</p>
<ul>
<li>type: set to 'pulse'.</li>
<li>EODf: the inverse of the median interval between <code>eod_times</code>,
if provided.</li>
<li>period: the median interval between <code>eod_times</code>, if provided.</li>
<li>IPI-mean: the mean interval between <code>eod_times</code>, if provided.</li>
<li>IPI-std: the standard deviation of the intervals between
<code>eod_times</code>, if provided.</li>
<li>max-ampl: the amplitude of the largest positive peak (P1).</li>
<li>min-ampl: the amplitude of the largest negative peak (P2).</li>
<li>p-p-amplitude: peak-to-peak amplitude of the EOD waveform.</li>
<li>noise: root-mean squared standard error mean of the averaged
EOD waveform relative to the p-p amplitude.</li>
<li>tstart: time in seconds where the pulse starts,
i.e. crosses the threshold for the first time.</li>
<li>tend: time in seconds where the pulse ends,
i.e. crosses the threshold for the last time.</li>
<li>width: total width of the pulse in seconds (tend-tstart).</li>
<li>P2-P1-dist: distance between P2 and P1 in seconds.</li>
<li>tau: time constant of exponential decay of pulse tail in seconds.</li>
<li>firstpeak: index of the first peak in the pulse (i.e. -1 for P-1)</li>
<li>lastpeak: index of the last peak in the pulse (i.e. 3 for P3)</li>
<li>totalarea: sum of areas under positive and negative peaks.</li>
<li>positivearea: area under positive peaks relative to total area.</li>
<li>negativearea: area under negative peaks relative to total area.</li>
<li>polaritybalance: contrast between areas under positive and
negative peak.</li>
<li>peakfreq: frequency at peak power of the single pulse spectrum
in Hertz.</li>
<li>peakpower: peak power of the single pulse spectrum in decibel.</li>
<li>poweratt5: how much the average power below 5 Hz is attenuated
relative to the peak power in decibel.</li>
<li>poweratt50: how much the average power below 5 Hz is attenuated
relative to the peak power in decibel.</li>
<li>lowcutoff: frequency at which the power reached half of the
peak power relative to the initial power in Hertz.</li>
<li>flipped: True if the waveform was flipped.</li>
<li>n: number of pulses analyzed
(i.e. <code>len(eod_times)</code>), if provided.</li>
<li>times: the times of the detected EOD pulses (i.e. <code>eod_times</code>),
if provided.</li>
</ul>
<p>Empty if waveform is not a pulse EOD.</p>
</dd>
<dt><strong><code>peaks</code></strong> :&ensp;<code>2-D array</code></dt>
<dd>For each peak and trough (rows) of the EOD waveform
7 columns: the peak index (1 is P1, i.e. the largest positive peak),
time relative to largest positive peak, amplitude,
amplitude normalized to largest postive peak,
width of peak/trough at half height,
area under the peak, and area under the peak relative to total area.
Empty if waveform is not a pulse EOD.</dd>
<dt><strong><code>power</code></strong> :&ensp;<code>2-D array</code></dt>
<dd>The power spectrum of a single pulse. First column are the
frequencies, second column the power in x^2/Hz such that the
integral equals the variance.
Empty if waveform is not a
pulse EOD.</dd>
</dl></div>
</dd>
<dt id="thunderfish.eodanalysis.adjust_eodf"><code class="name flex">
<span>def <span class="ident">adjust_eodf</span></span>(<span>eodf, temp, temp_adjust=25.0, q10=1.62)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjust_eodf(eodf, temp, temp_adjust=25.0, q10=1.62):
    &#34;&#34;&#34;Adjust EOD frequencies to a standard temperature using Q10.

    Parameters
    ----------
    eodf: float or ndarray
        EOD frequencies.
    temp: float
        Temperature in degree celsisus at which EOD frequencies in
        `eodf` were measured.
    temp_adjust: float
        Standard temperature in degree celsisus to which EOD
        frequencies are adjusted.
    q10: float
        Q10 value describing temperature dependence of EOD
        frequencies.  The default of 1.62 is from Dunlap, Smith, Yetka
        (2000) Brain Behav Evol, measured for Apteronotus
        lepthorhynchus in the lab.

    Returns
    -------
    eodf_corrected: float or array
        EOD frequencies adjusted to `temp_adjust` using `q10`.
    &#34;&#34;&#34;
    return eodf*q10**((temp_adjust - temp) / 10.0)</code></pre>
</details>
<div class="desc"><p>Adjust EOD frequencies to a standard temperature using Q10.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>eodf</code></strong> :&ensp;<code>float</code> or <code>ndarray</code></dt>
<dd>EOD frequencies.</dd>
<dt><strong><code>temp</code></strong> :&ensp;<code>float</code></dt>
<dd>Temperature in degree celsisus at which EOD frequencies in
<code>eodf</code> were measured.</dd>
<dt><strong><code>temp_adjust</code></strong> :&ensp;<code>float</code></dt>
<dd>Standard temperature in degree celsisus to which EOD
frequencies are adjusted.</dd>
<dt><strong><code>q10</code></strong> :&ensp;<code>float</code></dt>
<dd>Q10 value describing temperature dependence of EOD
frequencies.
The default of 1.62 is from Dunlap, Smith, Yetka
(2000) Brain Behav Evol, measured for Apteronotus
lepthorhynchus in the lab.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>eodf_corrected</code></strong> :&ensp;<code>float</code> or <code>array</code></dt>
<dd>EOD frequencies adjusted to <code>temp_adjust</code> using <code>q10</code>.</dd>
</dl></div>
</dd>
<dt id="thunderfish.eodanalysis.load_species_waveforms"><code class="name flex">
<span>def <span class="ident">load_species_waveforms</span></span>(<span>species_file='none')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_species_waveforms(species_file=&#39;none&#39;):
    &#34;&#34;&#34;Load template EOD waveforms for species matching.
    
    Parameters
    ----------
    species_file: string
        Name of file containing species definitions. The content of
        this file is as follows:
        
        - Empty lines and line starting with a hash (&#39;#&#39;) are skipped.
        - A line with the key-word &#39;wavefish&#39; marks the beginning of the
          table for wave fish.
        - A line with the key-word &#39;pulsefish&#39; marks the beginning of the
          table for pulse fish.
        - Each line in a species table has three fields,
          separated by colons (&#39;:&#39;):
        
          1. First field is an abbreviation of the species name.
          2. Second field is the filename of the recording containing the
             EOD waveform.
          3. The optional third field is the EOD frequency of the EOD waveform.

          The EOD frequency is used to normalize the time axis of a
          wave fish EOD to one EOD period. If it is not specified in
          the third field, it is taken from the corresponding
          *-wavespectrum-* file, if present.  Otherwise the species is
          excluded and a warning is issued.

        Example file content:
        ``` plain
        Wavefish
        Aptero : F_91009L20-eodwaveform-0.csv : 823Hz
        Eigen  : C_91008L01-eodwaveform-0.csv

        Pulsefish
        Gymnotus : pulsefish/gymnotus.csv
        Brachy   : H_91009L11-eodwaveform-0.csv
        ```
    
    Returns
    -------
    wave_names: list of strings
        List of species names of wave-type fish.
    wave_eods: list of 2-D arrays
        List of EOD waveforms of wave-type fish corresponding to
        `wave_names`.  First column of a waveform is time in seconds,
        second column is the EOD waveform.  The waveforms contain
        exactly one EOD period.
    pulse_names: list of strings
        List of species names of pulse-type fish.
    pulse_eods: list of 2-D arrays
        List of EOD waveforms of pulse-type fish corresponding to
        `pulse_names`.  First column of a waveform is time in seconds,
        second column is the EOD waveform.
    &#34;&#34;&#34;
    if len(species_file) == 0 or species_file == &#39;none&#39; or \
       not os.path.isfile(species_file):
        return [], [], [], []
    wave_names = []
    wave_eods = []
    pulse_names = []
    pulse_eods = []
    fish_type = &#39;wave&#39;
    with open(species_file, &#39;r&#39;) as sf:
        for line in sf:
            line = line.strip()
            if len(line) == 0 or line[0] == &#39;#&#39;:
                continue
            if line.lower() == &#39;wavefish&#39;:
                fish_type = &#39;wave&#39;
            elif line.lower() == &#39;pulsefish&#39;:
                fish_type = &#39;pulse&#39;
            else:
                ls = [s.strip() for s in line.split(&#39;:&#39;)]
                if len(ls) &lt;  2:
                    continue
                name = ls[0]
                waveform_file = ls[1]
                eod = TableData(waveform_file).array()
                eod[:,0] *= 0.001
                if fish_type == &#39;wave&#39;:
                    eodf = None
                    if len(ls) &gt;  2:
                        eodf = float(ls[2].replace(&#39;Hz&#39;, &#39;&#39;).strip())
                    else:
                        spectrum_file = waveform_file.replace(&#39;eodwaveform&#39;, &#39;wavespectrum&#39;)
                        try:
                            wave_spec = TableData(spectrum_file)
                            eodf = wave_spec[0, 1]
                        except FileNotFoundError:
                            pass
                    if eodf is None:
                        print(&#39;warning: unknown EOD frequency of %s. Skip.&#39; % name)
                        continue
                    eod[:,0] *= eodf
                    wave_names.append(name)
                    wave_eods.append(eod[:,:2])
                elif fish_type == &#39;pulse&#39;:
                    pulse_names.append(name)
                    pulse_eods.append(eod[:,:2])
    return wave_names, wave_eods, pulse_names, pulse_eods</code></pre>
</details>
<div class="desc"><p>Load template EOD waveforms for species matching.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>species_file</code></strong> :&ensp;<code>string</code></dt>
<dd>
<p>Name of file containing species definitions. The content of
this file is as follows:</p>
<ul>
<li>Empty lines and line starting with a hash ('#') are skipped.</li>
<li>A line with the key-word 'wavefish' marks the beginning of the
table for wave fish.</li>
<li>A line with the key-word 'pulsefish' marks the beginning of the
table for pulse fish.</li>
<li>
<p>Each line in a species table has three fields,
separated by colons (':'):</p>
</li>
<li>
<p>First field is an abbreviation of the species name.</p>
</li>
<li>Second field is the filename of the recording containing the
EOD waveform.</li>
<li>The optional third field is the EOD frequency of the EOD waveform.</li>
</ul>
<p>The EOD frequency is used to normalize the time axis of a
wave fish EOD to one EOD period. If it is not specified in
the third field, it is taken from the corresponding
<em>-wavespectrum-</em> file, if present.
Otherwise the species is
excluded and a warning is issued.</p>
<p>Example file content:
``` plain
Wavefish
Aptero : F_91009L20-eodwaveform-0.csv : 823Hz
Eigen
: C_91008L01-eodwaveform-0.csv</p>
<p>Pulsefish
Gymnotus : pulsefish/gymnotus.csv
Brachy
: H_91009L11-eodwaveform-0.csv
```</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>wave_names</code></strong> :&ensp;<code>list</code> of <code>strings</code></dt>
<dd>List of species names of wave-type fish.</dd>
<dt><strong><code>wave_eods</code></strong> :&ensp;<code>list</code> of <code>2-D arrays</code></dt>
<dd>List of EOD waveforms of wave-type fish corresponding to
<code>wave_names</code>.
First column of a waveform is time in seconds,
second column is the EOD waveform.
The waveforms contain
exactly one EOD period.</dd>
<dt><strong><code>pulse_names</code></strong> :&ensp;<code>list</code> of <code>strings</code></dt>
<dd>List of species names of pulse-type fish.</dd>
<dt><strong><code>pulse_eods</code></strong> :&ensp;<code>list</code> of <code>2-D arrays</code></dt>
<dd>List of EOD waveforms of pulse-type fish corresponding to
<code>pulse_names</code>.
First column of a waveform is time in seconds,
second column is the EOD waveform.</dd>
</dl></div>
</dd>
<dt id="thunderfish.eodanalysis.wave_similarity"><code class="name flex">
<span>def <span class="ident">wave_similarity</span></span>(<span>eod1, eod2, eod1f=1.0, eod2f=1.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wave_similarity(eod1, eod2, eod1f=1.0, eod2f=1.0):
    &#34;&#34;&#34;Root-mean squared difference between two wave fish EODs.

    Compute the root-mean squared difference between two wave fish
    EODs over one period. The better sampled signal is down-sampled to
    the worse sampled one. Amplitude are normalized to peak-to-peak
    amplitude before computing rms difference.  Also compute the rms
    difference between the one EOD and the other one inverted in
    amplitude. The smaller of the two rms values is returned.

    Parameters
    ----------
    eod1: 2-D array
        Time and amplitude of reference EOD.
    eod2: 2-D array
        Time and amplitude of EOD that is to be compared to `eod1`.
    eod1f: float
        EOD frequency of `eod1` used to transform the time axis of `eod1`
        to multiples of the EOD period. If already normalized to EOD period,
        as for example by the `load_species_waveforms()` function, then
        set the EOD frequency to one (default).
    eod2f: float
        EOD frequency of `eod2` used to transform the time axis of `eod2`
        to multiples of the EOD period. If already normalized to EOD period,
        as for example by the `load_species_waveforms()` function, then
        set the EOD frequency to one (default).

    Returns
    -------
    rmse: float
        Root-mean-squared difference between the two EOD waveforms relative to
        their standard deviation over one period.
    &#34;&#34;&#34;
    # copy:
    eod1 = np.array(eod1[:,:2])
    eod2 = np.array(eod2[:,:2])
    # scale to multiples of EOD period:
    eod1[:,0] *= eod1f
    eod2[:,0] *= eod2f
    # make eod1 the waveform with less samples per period:
    n1 = int(1.0/(eod1[1,0]-eod1[0,0]))
    n2 = int(1.0/(eod2[1,0]-eod2[0,0]))
    if n1 &gt; n2:
        eod1, eod2 = eod2, eod1
        n1, n2 = n2, n1
    # one period around time zero:
    i0 = np.argmin(np.abs(eod1[:,0]))
    k0 = i0-n1//2
    if k0 &lt; 0:
        k0 = 0
    k1 = k0 + n1 + 1
    if k1 &gt;= len(eod1):
        k1 = len(eod1)
    # cut out one period from the reference EOD around maximum:
    i = k0 + np.argmax(eod1[k0:k1,1])
    k0 = i-n1//2
    if k0 &lt; 0:
        k0 = 0
    k1 = k0 + n1 + 1
    if k1 &gt;= len(eod1):
        k1 = len(eod1)
    eod1 = eod1[k0:k1,:]
    # normalize amplitudes of first EOD:
    eod1[:,1] -= np.min(eod1[:,1])
    eod1[:,1] /= np.max(eod1[:,1])
    sigma = np.std(eod1[:,1])
    # set time zero to maximum of second EOD:
    i0 = np.argmin(np.abs(eod2[:,0]))
    k0 = i0-n2//2
    if k0 &lt; 0:
        k0 = 0
    k1 = k0 + n2 + 1
    if k1 &gt;= len(eod2):
        k1 = len(eod2)
    i = k0 + np.argmax(eod2[k0:k1,1])
    eod2[:,0] -= eod2[i,0]
    # interpolate eod2 to the time base of eod1:
    eod2w = np.interp(eod1[:,0], eod2[:,0], eod2[:,1])
    # normalize amplitudes of second EOD:
    eod2w -= np.min(eod2w)
    eod2w /= np.max(eod2w)
    # root-mean-square difference:
    rmse1 = np.sqrt(np.mean((eod1[:,1] - eod2w)**2))/sigma
    # root-mean-square difference of the flipped signal:
    i = k0 + np.argmin(eod2[k0:k1,1])
    eod2[:,0] -= eod2[i,0]
    eod2w = np.interp(eod1[:,0], eod2[:,0], -eod2[:,1])
    eod2w -= np.min(eod2w)
    eod2w /= np.max(eod2w)
    rmse2 = np.sqrt(np.mean((eod1[:,1] - eod2w)**2))/sigma
    # take the smaller value:
    rmse = min(rmse1, rmse2)
    return rmse</code></pre>
</details>
<div class="desc"><p>Root-mean squared difference between two wave fish EODs.</p>
<p>Compute the root-mean squared difference between two wave fish
EODs over one period. The better sampled signal is down-sampled to
the worse sampled one. Amplitude are normalized to peak-to-peak
amplitude before computing rms difference.
Also compute the rms
difference between the one EOD and the other one inverted in
amplitude. The smaller of the two rms values is returned.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>eod1</code></strong> :&ensp;<code>2-D array</code></dt>
<dd>Time and amplitude of reference EOD.</dd>
<dt><strong><code>eod2</code></strong> :&ensp;<code>2-D array</code></dt>
<dd>Time and amplitude of EOD that is to be compared to <code>eod1</code>.</dd>
<dt><strong><code>eod1f</code></strong> :&ensp;<code>float</code></dt>
<dd>EOD frequency of <code>eod1</code> used to transform the time axis of <code>eod1</code>
to multiples of the EOD period. If already normalized to EOD period,
as for example by the <code><a title="thunderfish.eodanalysis.load_species_waveforms" href="#thunderfish.eodanalysis.load_species_waveforms">load_species_waveforms()</a></code> function, then
set the EOD frequency to one (default).</dd>
<dt><strong><code>eod2f</code></strong> :&ensp;<code>float</code></dt>
<dd>EOD frequency of <code>eod2</code> used to transform the time axis of <code>eod2</code>
to multiples of the EOD period. If already normalized to EOD period,
as for example by the <code><a title="thunderfish.eodanalysis.load_species_waveforms" href="#thunderfish.eodanalysis.load_species_waveforms">load_species_waveforms()</a></code> function, then
set the EOD frequency to one (default).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rmse</code></strong> :&ensp;<code>float</code></dt>
<dd>Root-mean-squared difference between the two EOD waveforms relative to
their standard deviation over one period.</dd>
</dl></div>
</dd>
<dt id="thunderfish.eodanalysis.pulse_similarity"><code class="name flex">
<span>def <span class="ident">pulse_similarity</span></span>(<span>eod1, eod2, wfac=10.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pulse_similarity(eod1, eod2, wfac=10.0):
    &#34;&#34;&#34;Root-mean squared difference between two pulse fish EODs.

    Compute the root-mean squared difference between two pulse fish
    EODs over `wfac` times the distance between minimum and maximum of
    the wider EOD. The waveforms are normalized to their maxima prior
    to computing the rms difference.  Also compute the rms difference
    between the one EOD and the other one inverted in amplitude. The
    smaller of the two rms values is returned.

    Parameters
    ----------
    eod1: 2-D array
        Time and amplitude of reference EOD.
    eod2: 2-D array
        Time and amplitude of EOD that is to be compared to `eod1`.
    wfac: float
        Multiply the distance between minimum and maximum by this factor
        to get the window size over which to compute the rms difference.

    Returns
    -------
    rmse: float
        Root-mean-squared difference between the two EOD waveforms
        relative to their standard deviation over the analysis window.
    &#34;&#34;&#34;
    # copy:
    eod1 = np.array(eod1[:,:2])
    eod2 = np.array(eod2[:,:2])
    # width of the pulses:
    imin1 = np.argmin(eod1[:,1])
    imax1 = np.argmax(eod1[:,1])
    w1 = np.abs(eod1[imax1,0]-eod1[imin1,0])
    imin2 = np.argmin(eod2[:,1])
    imax2 = np.argmax(eod2[:,1])
    w2 = np.abs(eod2[imax2,0]-eod2[imin2,0])
    w = wfac*max(w1, w2)
    # cut out signal from the reference EOD:
    n = int(w/(eod1[1,0]-eod1[0,0]))
    i0 = imax1-n//2
    if i0 &lt; 0:
        i0 = 0
    i1 = imax1+n//2+1
    if i1 &gt;= len(eod1):
        i1 = len(eod1)
    eod1[:,0] -= eod1[imax1,0]
    eod1 = eod1[i0:i1,:]
    # normalize amplitude of first EOD:
    eod1[:,1] /= np.max(eod1[:,1])
    sigma = np.std(eod1[:,1])
    # interpolate eod2 to the time base of eod1:
    eod2[:,0] -= eod2[imax2,0]
    eod2w = np.interp(eod1[:,0], eod2[:,0], eod2[:,1])
    # normalize amplitude of second EOD:
    eod2w /= np.max(eod2w)
    # root-mean-square difference:
    rmse1 = np.sqrt(np.mean((eod1[:,1] - eod2w)**2))/sigma
    # root-mean-square difference of the flipped signal:
    eod2[:,0] -= eod2[imin2,0]
    eod2w = np.interp(eod1[:,0], eod2[:,0], -eod2[:,1])
    eod2w /= np.max(eod2w)
    rmse2 = np.sqrt(np.mean((eod1[:,1] - eod2w)**2))/sigma
    # take the smaller value:
    rmse = min(rmse1, rmse2)
    return rmse</code></pre>
</details>
<div class="desc"><p>Root-mean squared difference between two pulse fish EODs.</p>
<p>Compute the root-mean squared difference between two pulse fish
EODs over <code>wfac</code> times the distance between minimum and maximum of
the wider EOD. The waveforms are normalized to their maxima prior
to computing the rms difference.
Also compute the rms difference
between the one EOD and the other one inverted in amplitude. The
smaller of the two rms values is returned.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>eod1</code></strong> :&ensp;<code>2-D array</code></dt>
<dd>Time and amplitude of reference EOD.</dd>
<dt><strong><code>eod2</code></strong> :&ensp;<code>2-D array</code></dt>
<dd>Time and amplitude of EOD that is to be compared to <code>eod1</code>.</dd>
<dt><strong><code>wfac</code></strong> :&ensp;<code>float</code></dt>
<dd>Multiply the distance between minimum and maximum by this factor
to get the window size over which to compute the rms difference.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rmse</code></strong> :&ensp;<code>float</code></dt>
<dd>Root-mean-squared difference between the two EOD waveforms
relative to their standard deviation over the analysis window.</dd>
</dl></div>
</dd>
<dt id="thunderfish.eodanalysis.clipped_fraction"><code class="name flex">
<span>def <span class="ident">clipped_fraction</span></span>(<span>data, rate, eod_times, mean_eod, min_clip=-inf, max_clip=inf)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clipped_fraction(data, rate, eod_times, mean_eod,
                     min_clip=-np.inf, max_clip=np.inf):
    &#34;&#34;&#34;Compute fraction of clipped EOD waveform snippets.

    Cut out snippets at each `eod_times` based on time axis of
    `mean_eod`.  Check which fraction of snippets exceeds clipping
    amplitude `min_clip` and `max_clip`.

    Parameters
    ----------
    data: 1-D array of float
        The data to be analysed.
    rate: float
        Sampling rate of the data in Hertz.
    eod_times: 1-D array of float
        Array of EOD times in seconds.
    mean_eod: 2-D array with time, mean, sem, and fit.
        Averaged EOD waveform of wave fish. Only the time axis is used
        to set width of snippets.
    min_clip: float
        Minimum amplitude that is not clipped.
    max_clip: float
        Maximum amplitude that is not clipped.
    
    Returns
    -------
    clipped_frac: float
        Fraction of snippets that are clipped.
    &#34;&#34;&#34;
    # snippets:
    idx0 = np.argmin(np.abs(mean_eod[:,0])) # index of time zero
    w0 = -idx0
    w1 = len(mean_eod[:,0]) - idx0
    eod_idx = np.round(eod_times*rate).astype(int)
    eod_snippets = snippets(data, eod_idx, w0, w1)
    # fraction of clipped snippets:
    clipped_frac = np.sum(np.any((eod_snippets &gt; max_clip) |
                                 (eod_snippets &lt; min_clip), axis=1))\
                   / len(eod_snippets)
    return clipped_frac</code></pre>
</details>
<div class="desc"><p>Compute fraction of clipped EOD waveform snippets.</p>
<p>Cut out snippets at each <code>eod_times</code> based on time axis of
<code>mean_eod</code>.
Check which fraction of snippets exceeds clipping
amplitude <code>min_clip</code> and <code>max_clip</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>1-D array</code> of <code>float</code></dt>
<dd>The data to be analysed.</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Sampling rate of the data in Hertz.</dd>
<dt><strong><code>eod_times</code></strong> :&ensp;<code>1-D array</code> of <code>float</code></dt>
<dd>Array of EOD times in seconds.</dd>
<dt>mean_eod: 2-D array with time, mean, sem, and fit.</dt>
<dt>Averaged EOD waveform of wave fish. Only the time axis is used</dt>
<dt>to set width of snippets.</dt>
<dt><strong><code>min_clip</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum amplitude that is not clipped.</dd>
<dt><strong><code>max_clip</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum amplitude that is not clipped.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>clipped_frac</code></strong> :&ensp;<code>float</code></dt>
<dd>Fraction of snippets that are clipped.</dd>
</dl></div>
</dd>
<dt id="thunderfish.eodanalysis.wave_quality"><code class="name flex">
<span>def <span class="ident">wave_quality</span></span>(<span>props,<br>harm_relampl=None,<br>min_freq=0.0,<br>max_freq=2000.0,<br>max_clipped_frac=0.1,<br>max_crossings=4,<br>max_rms_sem=0.0,<br>max_rms_error=0.05,<br>min_power=-100.0,<br>max_thd=0.0,<br>max_db_diff=20.0,<br>max_harmonics_db=-5.0,<br>max_relampl_harm1=0.0,<br>max_relampl_harm2=0.0,<br>max_relampl_harm3=0.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wave_quality(props, harm_relampl=None, min_freq=0.0,
                 max_freq=2000.0, max_clipped_frac=0.1,
                 max_crossings=4, max_rms_sem=0.0, max_rms_error=0.05,
                 min_power=-100.0, max_thd=0.0, max_db_diff=20.0,
                 max_harmonics_db=-5.0, max_relampl_harm1=0.0,
                 max_relampl_harm2=0.0, max_relampl_harm3=0.0):
    &#34;&#34;&#34;Assess the quality of an EOD waveform of a wave fish.
    
    Parameters
    ----------
    props: dict
        A dictionary with properties of the analyzed EOD waveform
        as returned by `analyze_wave()`.
    harm_relampl: 1-D array of floats or None
        Relative amplitude of at least the first 3 harmonics without
        the fundamental.
    min_freq: float
        Minimum EOD frequency (`props[&#39;EODf&#39;]`).
    max_freq: float
        Maximum EOD frequency (`props[&#39;EODf&#39;]`).
    max_clipped_frac: float
        If larger than zero, maximum allowed fraction of clipped data
        (`props[&#39;clipped&#39;]`).
    max_crossings: int
        If larger than zero, maximum number of zero crossings per EOD period
        (`props[&#39;ncrossings&#39;]`).
    max_rms_sem: float
        If larger than zero, maximum allowed standard error of the
        data relative to p-p amplitude (`props[&#39;noise&#39;]`).
    max_rms_error: float
        If larger than zero, maximum allowed root-mean-square error
        between EOD waveform and Fourier fit relative to p-p amplitude
        (`props[&#39;rmserror&#39;]`).
    min_power: float
        Minimum power of the EOD in dB (`props[&#39;power&#39;]`).
    max_thd: float
        If larger than zero, then maximum total harmonic distortion
        (`props[&#39;thd&#39;]`).
    max_db_diff: float
        If larger than zero, maximum standard deviation of differences between
        logarithmic powers of harmonics in decibel (`props[&#39;dbdiff&#39;]`).
        Low values enforce smoother power spectra.
    max_harmonics_db:
        Maximum power of higher harmonics relative to peak power in
        decibel (`props[&#39;maxdb&#39;]`).
    max_relampl_harm1: float
        If larger than zero, maximum allowed amplitude of first harmonic
        relative to fundamental.
    max_relampl_harm2: float
        If larger than zero, maximum allowed amplitude of second harmonic
        relative to fundamental.
    max_relampl_harm3: float
        If larger than zero, maximum allowed amplitude of third harmonic
        relative to fundamental.
                                       
    Returns
    -------
    remove: bool
        If True then this is most likely not an electric fish. Remove
        it from both the waveform properties and the list of EOD
        frequencies.  If False, keep it in the list of EOD
        frequencies, but remove it from the waveform properties if
        `skip_reason` is not empty.
    skip_reason: string
        An empty string if the waveform is good, otherwise a string
        indicating the failure.
    msg: string
        A textual representation of the values tested.
    &#34;&#34;&#34;
    remove = False
    msg = []
    skip_reason = []
    # EOD frequency:
    if &#39;EODf&#39; in props:
        eodf = props[&#39;EODf&#39;]
        msg += [&#39;EODf=%5.1fHz&#39; % eodf]
        if eodf &lt; min_freq or eodf &gt; max_freq:
            remove = True
            skip_reason += [&#39;invalid EODf=%5.1fHz (minimumFrequency=%5.1fHz, maximumFrequency=%5.1f))&#39; %
                            (eodf, min_freq, max_freq)]
    # clipped fraction:
    if &#39;clipped&#39; in props:
        clipped_frac = props[&#39;clipped&#39;]
        msg += [&#39;clipped=%3.0f%%&#39; % (100.0*clipped_frac)]
        if max_clipped_frac &gt; 0 and clipped_frac &gt;= max_clipped_frac:
            skip_reason += [&#39;clipped=%3.0f%% (maximumClippedFraction=%3.0f%%)&#39; %
                            (100.0*clipped_frac, 100.0*max_clipped_frac)]
    # too many zero crossings:
    if &#39;ncrossings&#39; in props:
        ncrossings = props[&#39;ncrossings&#39;]
        msg += [&#39;zero crossings=%d&#39; % ncrossings]
        if max_crossings &gt; 0 and ncrossings &gt; max_crossings:
            skip_reason += [&#39;too many zero crossings=%d (maximumCrossings=%d)&#39; %
                            (ncrossings, max_crossings)]
    # noise:
    rms_sem = None
    if &#39;rmssem&#39; in props:
        rms_sem = props[&#39;rmssem&#39;]
    if &#39;noise&#39; in props:
        rms_sem = props[&#39;noise&#39;]
    if rms_sem is not None:
        msg += [&#39;rms sem waveform=%6.2f%%&#39; % (100.0*rms_sem)]
        if max_rms_sem &gt; 0.0 and rms_sem &gt;= max_rms_sem:
            skip_reason += [&#39;noisy waveform s.e.m.=%6.2f%% (max %6.2f%%)&#39; %
                            (100.0*rms_sem, 100.0*max_rms_sem)]
    # fit error:
    if &#39;rmserror&#39; in props:
        rms_error = props[&#39;rmserror&#39;]
        msg += [&#39;rmserror=%6.2f%%&#39; % (100.0*rms_error)]
        if max_rms_error &gt; 0.0 and rms_error &gt;= max_rms_error:
            skip_reason += [&#39;noisy rmserror=%6.2f%% (maximumVariance=%6.2f%%)&#39; %
                            (100.0*rms_error, 100.0*max_rms_error)]
    # wave power:
    if &#39;power&#39; in props:
        power = props[&#39;power&#39;]
        msg += [&#39;power=%6.1fdB&#39; % power]
        if power &lt; min_power:
            skip_reason += [&#39;small power=%6.1fdB (minimumPower=%6.1fdB)&#39; %
                            (power, min_power)]
    # total harmonic distortion:
    if &#39;thd&#39; in props:
        thd = props[&#39;thd&#39;]
        msg += [&#39;thd=%5.1f%%&#39; % (100.0*thd)]
        if max_thd &gt; 0.0 and thd &gt; max_thd:
            skip_reason += [&#39;large THD=%5.1f%% (maxximumTotalHarmonicDistortion=%5.1f%%)&#39; %
                            (100.0*thd, 100.0*max_thd)]
    # smoothness of spectrum:
    if &#39;dbdiff&#39; in props:
        db_diff = props[&#39;dbdiff&#39;]
        msg += [&#39;dBdiff=%5.1fdB&#39; % db_diff]
        if max_db_diff &gt; 0.0 and db_diff &gt; max_db_diff:
            remove = True
            skip_reason += [&#39;not smooth s.d. diff=%5.1fdB (maxximumPowerDifference=%5.1fdB)&#39; %
                            (db_diff, max_db_diff)]
    # maximum power of higher harmonics:
    if &#39;maxdb&#39; in props:
        max_harmonics = props[&#39;maxdb&#39;]
        msg += [&#39;max harmonics=%5.1fdB&#39; % max_harmonics]
        if max_harmonics &gt; max_harmonics_db:
            remove = True
            skip_reason += [&#39;maximum harmonics=%5.1fdB too strong (maximumHarmonicsPower=%5.1fdB)&#39; %
                            (max_harmonics, max_harmonics_db)]
    # relative amplitude of harmonics:
    if harm_relampl is not None:
        for k, max_relampl in enumerate([max_relampl_harm1, max_relampl_harm2, max_relampl_harm3]):
            if k &gt;= len(harm_relampl):
                break
            msg += [&#39;ampl%d=%5.1f%%&#39; % (k+1, 100.0*harm_relampl[k])]
            if max_relampl &gt; 0.0 and k &lt; len(harm_relampl) and harm_relampl[k] &gt;= max_relampl:
                num_str = [&#39;First&#39;, &#39;Second&#39;, &#39;Third&#39;]
                skip_reason += [&#39;distorted ampl%d=%5.1f%% (maximum%sHarmonicAmplitude=%5.1f%%)&#39; %
                                (k+1, 100.0*harm_relampl[k], num_str[k], 100.0*max_relampl)]
    return remove, &#39;, &#39;.join(skip_reason), &#39;, &#39;.join(msg)</code></pre>
</details>
<div class="desc"><p>Assess the quality of an EOD waveform of a wave fish.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>props</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary with properties of the analyzed EOD waveform
as returned by <code><a title="thunderfish.eodanalysis.analyze_wave" href="#thunderfish.eodanalysis.analyze_wave">analyze_wave()</a></code>.</dd>
<dt><strong><code>harm_relampl</code></strong> :&ensp;<code>1-D array</code> of <code>floats</code> or <code>None</code></dt>
<dd>Relative amplitude of at least the first 3 harmonics without
the fundamental.</dd>
<dt><strong><code>min_freq</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum EOD frequency (<code>props['EODf']</code>).</dd>
<dt><strong><code>max_freq</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum EOD frequency (<code>props['EODf']</code>).</dd>
<dt><strong><code>max_clipped_frac</code></strong> :&ensp;<code>float</code></dt>
<dd>If larger than zero, maximum allowed fraction of clipped data
(<code>props['clipped']</code>).</dd>
<dt><strong><code>max_crossings</code></strong> :&ensp;<code>int</code></dt>
<dd>If larger than zero, maximum number of zero crossings per EOD period
(<code>props['ncrossings']</code>).</dd>
<dt><strong><code>max_rms_sem</code></strong> :&ensp;<code>float</code></dt>
<dd>If larger than zero, maximum allowed standard error of the
data relative to p-p amplitude (<code>props['noise']</code>).</dd>
<dt><strong><code>max_rms_error</code></strong> :&ensp;<code>float</code></dt>
<dd>If larger than zero, maximum allowed root-mean-square error
between EOD waveform and Fourier fit relative to p-p amplitude
(<code>props['rmserror']</code>).</dd>
<dt><strong><code>min_power</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum power of the EOD in dB (<code>props['power']</code>).</dd>
<dt><strong><code>max_thd</code></strong> :&ensp;<code>float</code></dt>
<dd>If larger than zero, then maximum total harmonic distortion
(<code>props['thd']</code>).</dd>
<dt><strong><code>max_db_diff</code></strong> :&ensp;<code>float</code></dt>
<dd>If larger than zero, maximum standard deviation of differences between
logarithmic powers of harmonics in decibel (<code>props['dbdiff']</code>).
Low values enforce smoother power spectra.</dd>
<dt>max_harmonics_db:</dt>
<dt>Maximum power of higher harmonics relative to peak power in</dt>
<dt>decibel (<code>props['maxdb']</code>).</dt>
<dt><strong><code>max_relampl_harm1</code></strong> :&ensp;<code>float</code></dt>
<dd>If larger than zero, maximum allowed amplitude of first harmonic
relative to fundamental.</dd>
<dt><strong><code>max_relampl_harm2</code></strong> :&ensp;<code>float</code></dt>
<dd>If larger than zero, maximum allowed amplitude of second harmonic
relative to fundamental.</dd>
<dt><strong><code>max_relampl_harm3</code></strong> :&ensp;<code>float</code></dt>
<dd>If larger than zero, maximum allowed amplitude of third harmonic
relative to fundamental.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>remove</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True then this is most likely not an electric fish. Remove
it from both the waveform properties and the list of EOD
frequencies.
If False, keep it in the list of EOD
frequencies, but remove it from the waveform properties if
<code>skip_reason</code> is not empty.</dd>
<dt><strong><code>skip_reason</code></strong> :&ensp;<code>string</code></dt>
<dd>An empty string if the waveform is good, otherwise a string
indicating the failure.</dd>
<dt><strong><code>msg</code></strong> :&ensp;<code>string</code></dt>
<dd>A textual representation of the values tested.</dd>
</dl></div>
</dd>
<dt id="thunderfish.eodanalysis.pulse_quality"><code class="name flex">
<span>def <span class="ident">pulse_quality</span></span>(<span>props, max_clipped_frac=0.1, max_rms_sem=0.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pulse_quality(props, max_clipped_frac=0.1, max_rms_sem=0.0):
    &#34;&#34;&#34;Assess the quality of an EOD waveform of a pulse fish.
    
    Parameters
    ----------
    props: dict
        A dictionary with properties of the analyzed EOD waveform
        as returned by `analyze_pulse()`.
    max_clipped_frac: float
        Maximum allowed fraction of clipped data.
    max_rms_sem: float
        If not zero, maximum allowed standard error of the data
        relative to p-p amplitude.

    Returns
    -------
    skip_reason: string
        An empty string if the waveform is good, otherwise a string
        indicating the failure.
    msg: string
        A textual representation of the values tested.
    skipped_clipped: bool
        True if waveform was skipped because of clipping.
    &#34;&#34;&#34;
    msg = []
    skip_reason = []
    skipped_clipped = False
    # clipped fraction:
    if &#39;clipped&#39; in props:
        clipped_frac = props[&#39;clipped&#39;]
        msg += [&#39;clipped=%3.0f%%&#39; % (100.0*clipped_frac)]
        if clipped_frac &gt;= max_clipped_frac:
            skip_reason += [&#39;clipped=%3.0f%% (maximumClippedFraction=%3.0f%%)&#39; %
                            (100.0*clipped_frac, 100.0*max_clipped_frac)]
            skipped_clipped = True
    # noise:
    rms_sem = None
    if &#39;rmssem&#39; in props:
        rms_sem = props[&#39;rmssem&#39;]
    if &#39;noise&#39; in props:
        rms_sem = props[&#39;noise&#39;]
    if rms_sem is not None:
        msg += [&#39;rms sem waveform=%6.2f%%&#39; % (100.0*rms_sem)]
        if max_rms_sem &gt; 0.0 and rms_sem &gt;= max_rms_sem:
            skip_reason += [&#39;noisy waveform s.e.m.=%6.2f%% (maximumRMSNoise=%6.2f%%)&#39; %
                            (100.0*rms_sem, 100.0*max_rms_sem)]
    return &#39;, &#39;.join(skip_reason), &#39;, &#39;.join(msg), skipped_clipped</code></pre>
</details>
<div class="desc"><p>Assess the quality of an EOD waveform of a pulse fish.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>props</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary with properties of the analyzed EOD waveform
as returned by <code><a title="thunderfish.eodanalysis.analyze_pulse" href="#thunderfish.eodanalysis.analyze_pulse">analyze_pulse()</a></code>.</dd>
<dt><strong><code>max_clipped_frac</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum allowed fraction of clipped data.</dd>
<dt><strong><code>max_rms_sem</code></strong> :&ensp;<code>float</code></dt>
<dd>If not zero, maximum allowed standard error of the data
relative to p-p amplitude.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>skip_reason</code></strong> :&ensp;<code>string</code></dt>
<dd>An empty string if the waveform is good, otherwise a string
indicating the failure.</dd>
<dt><strong><code>msg</code></strong> :&ensp;<code>string</code></dt>
<dd>A textual representation of the values tested.</dd>
<dt><strong><code>skipped_clipped</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if waveform was skipped because of clipping.</dd>
</dl></div>
</dd>
<dt id="thunderfish.eodanalysis.plot_eod_recording"><code class="name flex">
<span>def <span class="ident">plot_eod_recording</span></span>(<span>ax, data, rate, unit=None, width=0.1, toffs=0.0, pstyle={'lw': 2, 'color': 'tab:red'})</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_eod_recording(ax, data, rate, unit=None, width=0.1,
                       toffs=0.0, pstyle=dict(lw=2, color=&#39;tab:red&#39;)):
    &#34;&#34;&#34;Plot a zoomed in range of the recorded trace.

    Parameters
    ----------
    ax: matplotlib axes
        Axes used for plotting.
    data: 1D ndarray
        Recorded data to be plotted.
    rate: float
        Sampling rate of the data in Hertz.
    unit: string
        Optional unit of the data used for y-label.
    width: float
        Width of data segment to be plotted in seconds.
    toffs: float
        Time of first data value in seconds.
    pstyle: dict
        Arguments passed on to the plot command for the recorded trace.
    &#34;&#34;&#34;
    widx2 = int(width*rate)//2
    i0 = len(data)//2 - widx2
    i0 = (i0//widx2)*widx2
    i1 = i0 + 2*widx2
    if i0 &lt; 0:
        i0 = 0
    if i1 &gt;= len(data):
        i1 = len(data)
    time = np.arange(len(data))/rate + toffs
    tunit = &#39;sec&#39;
    if np.abs(time[i0]) &lt; 1.0 and np.abs(time[i1]) &lt; 1.0:
        time *= 1000.0
        tunit = &#39;ms&#39;
    ax.plot(time, data, **pstyle)
    ax.set_xlim(time[i0], time[i1])

    ax.set_xlabel(&#39;Time [%s]&#39; % tunit)
    ymin = np.min(data[i0:i1])
    ymax = np.max(data[i0:i1])
    dy = ymax - ymin
    ax.set_ylim(ymin-0.05*dy, ymax+0.05*dy)
    if len(unit) == 0 or unit == &#39;a.u.&#39;:
        ax.set_ylabel(&#39;Amplitude&#39;)
    else:
        ax.set_ylabel(&#39;Amplitude [%s]&#39; % unit)</code></pre>
</details>
<div class="desc"><p>Plot a zoomed in range of the recorded trace.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib axes</code></dt>
<dd>Axes used for plotting.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>1D ndarray</code></dt>
<dd>Recorded data to be plotted.</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Sampling rate of the data in Hertz.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>string</code></dt>
<dd>Optional unit of the data used for y-label.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code></dt>
<dd>Width of data segment to be plotted in seconds.</dd>
<dt><strong><code>toffs</code></strong> :&ensp;<code>float</code></dt>
<dd>Time of first data value in seconds.</dd>
<dt><strong><code>pstyle</code></strong> :&ensp;<code>dict</code></dt>
<dd>Arguments passed on to the plot command for the recorded trace.</dd>
</dl></div>
</dd>
<dt id="thunderfish.eodanalysis.plot_pulse_eods"><code class="name flex">
<span>def <span class="ident">plot_pulse_eods</span></span>(<span>ax,<br>data,<br>rate,<br>zoom_window,<br>width,<br>eod_props,<br>toffs=0.0,<br>colors=None,<br>markers=None,<br>marker_size=10,<br>legend_rows=8,<br>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_pulse_eods(ax, data, rate, zoom_window, width, eod_props,
                    toffs=0.0, colors=None, markers=None, marker_size=10,
                    legend_rows=8, **kwargs):
    &#34;&#34;&#34;Mark pulse EODs in a plot of an EOD recording.

    Parameters
    ----------
    ax: matplotlib axes
        Axes used for plotting.
    data: 1D ndarray
        Recorded data (these are not plotted!).
    rate: float
        Sampling rate of the data in Hertz.
    zoom_window: tuple of floats
       Start and end time of the data to be plotted in seconds.
    width: float
       Minimum width of the data to be plotted in seconds.
    eod_props: list of dictionaries
            Lists of EOD properties as returned by `analyze_pulse()`
            and `analyze_wave()`.  From the entries with &#39;type&#39; ==
            &#39;pulse&#39; the properties &#39;EODf&#39; and &#39;times&#39; are used. &#39;EODf&#39;
            is the averaged EOD frequency, and &#39;times&#39; is a list of
            detected EOD pulse times.
    toffs: float
        Time of first data value in seconds that will be added
        to the pulse times in `eod_props`.
    colors: list of colors or None
            If not None list of colors for plotting each cluster
    markers: list of markers or None
            If not None list of markers for plotting each cluster
    marker_size: float
            Size of markers used to mark the pulses.
    legend_rows: int
            Maximum number of rows to be used for the legend.
    kwargs: 
            Key word arguments for the legend of the plot.
    &#34;&#34;&#34;
    k = 0
    for eod in eod_props:
        if eod[&#39;type&#39;] != &#39;pulse&#39;:
            continue
        if &#39;times&#39; not in eod:
            continue

        width = np.min([width, np.diff(zoom_window)[0]])
        while len(eod[&#39;peaktimes&#39;][(eod[&#39;peaktimes&#39;]&gt;(zoom_window[1]-width)) &amp; (eod[&#39;peaktimes&#39;]&lt;(zoom_window[1]))]) == 0:
            width *= 2
            if zoom_window[1] - width &lt; 0:
                width = width/2
                break  

        x = eod[&#39;peaktimes&#39;] + toffs
        pidx = np.round(eod[&#39;peaktimes&#39;]*rate).astype(int)
        y = data[pidx[(pidx&gt;0)&amp;(pidx&lt;len(data))]]
        x = x[(pidx&gt;0)&amp;(pidx&lt;len(data))]
        color_kwargs = {}
        #if colors is not None:
        #    color_kwargs[&#39;color&#39;] = colors[k%len(colors)]
        if marker_size is not None:
            color_kwargs[&#39;ms&#39;] = marker_size
        label = &#39;%6.1f Hz&#39; % eod[&#39;EODf&#39;]
        if legend_rows &gt; 5 and k &gt;= legend_rows:
            label = None
        if markers is None:
            ax.plot(x, y, &#39;o&#39;, label=label, zorder=-1, **color_kwargs)
        else:
            ax.plot(x, y, linestyle=&#39;none&#39;, label=label,
                    marker=markers[k%len(markers)], mec=None, mew=0.0,
                    zorder=-1, **color_kwargs)
        k += 1

    # legend:
    if k &gt; 1:
        if legend_rows &gt; 0:
            if legend_rows &gt; 5:
                ncol = 1
            else:
                ncol = (len(idx)-1) // legend_rows + 1
            ax.legend(numpoints=1, ncol=ncol, **kwargs)
        else:
            ax.legend(numpoints=1, **kwargs)

    # reset window so at least one EOD of each cluster is visible    
    if len(zoom_window)&gt;0:
        ax.set_xlim(max(toffs,toffs+zoom_window[1]-width), toffs+zoom_window[1])

        i0 = max(0,int((zoom_window[1]-width)*rate))
        i1 = int(zoom_window[1]*rate)

        ymin = np.min(data[i0:i1])
        ymax = np.max(data[i0:i1])
        dy = ymax - ymin
        ax.set_ylim(ymin-0.05*dy, ymax+0.05*dy)</code></pre>
</details>
<div class="desc"><p>Mark pulse EODs in a plot of an EOD recording.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib axes</code></dt>
<dd>Axes used for plotting.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>1D ndarray</code></dt>
<dd>Recorded data (these are not plotted!).</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Sampling rate of the data in Hertz.</dd>
<dt><strong><code>zoom_window</code></strong> :&ensp;<code>tuple</code> of <code>floats</code></dt>
<dd>&nbsp;</dd>
<dt>Start and end time of the data to be plotted in seconds.</dt>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt>Minimum width of the data to be plotted in seconds.</dt>
<dt><strong><code>eod_props</code></strong> :&ensp;<code>list</code> of <code>dictionaries</code></dt>
<dd>Lists of EOD properties as returned by <code><a title="thunderfish.eodanalysis.analyze_pulse" href="#thunderfish.eodanalysis.analyze_pulse">analyze_pulse()</a></code>
and <code><a title="thunderfish.eodanalysis.analyze_wave" href="#thunderfish.eodanalysis.analyze_wave">analyze_wave()</a></code>.
From the entries with 'type' ==
'pulse' the properties 'EODf' and 'times' are used. 'EODf'
is the averaged EOD frequency, and 'times' is a list of
detected EOD pulse times.</dd>
<dt><strong><code>toffs</code></strong> :&ensp;<code>float</code></dt>
<dd>Time of first data value in seconds that will be added
to the pulse times in <code>eod_props</code>.</dd>
<dt><strong><code>colors</code></strong> :&ensp;<code>list</code> of <code>colors</code> or <code>None</code></dt>
<dd>If not None list of colors for plotting each cluster</dd>
<dt><strong><code>markers</code></strong> :&ensp;<code>list</code> of <code>markers</code> or <code>None</code></dt>
<dd>If not None list of markers for plotting each cluster</dd>
<dt><strong><code>marker_size</code></strong> :&ensp;<code>float</code></dt>
<dd>Size of markers used to mark the pulses.</dd>
<dt><strong><code>legend_rows</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of rows to be used for the legend.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Key word arguments for the legend of the plot.</dd>
</dl></div>
</dd>
<dt id="thunderfish.eodanalysis.plot_eod_snippets"><code class="name flex">
<span>def <span class="ident">plot_eod_snippets</span></span>(<span>ax,<br>data,<br>rate,<br>tmin,<br>tmax,<br>eod_times,<br>n_snippets=10,<br>flip=False,<br>sstyle={'scaley': False, 'lw': 0.5, 'color': '0.6'})</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_eod_snippets(ax, data, rate, tmin, tmax, eod_times,
                      n_snippets=10, flip=False,
                      sstyle=dict(scaley=False,
                                  lw=0.5, color=&#39;0.6&#39;)):
    &#34;&#34;&#34;Plot a few EOD waveform snippets.

    Parameters
    ----------
    ax: matplotlib axes
        Axes used for plotting.
    data: 1D ndarray
        Recorded data from which the snippets are taken.
    rate: float
        Sampling rate of the data in Hertz.
    tmin: float
        Start time of each snippet.
    tmax: float
        End time of each snippet.
    eod_times: 1-D array
        EOD peak times from which a few are selected to be plotted.
    n_snippets: int
        Number of snippets to be plotted. If zero do not plot anything.
    flip: bool
        If True flip the snippets upside down.
    sstyle: dict
        Arguments passed on to the plot command for plotting the snippets.
    &#34;&#34;&#34;
    if n_snippets &lt;= 0:
        return
    i0 = int(tmin*rate)
    i1 = int(tmax*rate)
    time = 1000.0*np.arange(i0, i1)/rate
    step = len(eod_times)//n_snippets
    if step &lt; 1:
        step = 1
    for t in eod_times[n_snippets//2::step]:
        idx = int(np.round(t*rate))
        if idx+i0 &lt; 0 or idx+i1 &gt;= len(data):
            continue
        snippet = data[idx+i0:idx+i1]
        if flip:
            snippet *= -1
        ax.plot(time, snippet - np.mean(snippet[:len(snippet)//4]),
                zorder=-5, **sstyle)</code></pre>
</details>
<div class="desc"><p>Plot a few EOD waveform snippets.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib axes</code></dt>
<dd>Axes used for plotting.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>1D ndarray</code></dt>
<dd>Recorded data from which the snippets are taken.</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Sampling rate of the data in Hertz.</dd>
<dt><strong><code>tmin</code></strong> :&ensp;<code>float</code></dt>
<dd>Start time of each snippet.</dd>
<dt><strong><code>tmax</code></strong> :&ensp;<code>float</code></dt>
<dd>End time of each snippet.</dd>
<dt><strong><code>eod_times</code></strong> :&ensp;<code>1-D array</code></dt>
<dd>EOD peak times from which a few are selected to be plotted.</dd>
<dt><strong><code>n_snippets</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of snippets to be plotted. If zero do not plot anything.</dd>
<dt><strong><code>flip</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True flip the snippets upside down.</dd>
<dt><strong><code>sstyle</code></strong> :&ensp;<code>dict</code></dt>
<dd>Arguments passed on to the plot command for plotting the snippets.</dd>
</dl></div>
</dd>
<dt id="thunderfish.eodanalysis.plot_eod_waveform"><code class="name flex">
<span>def <span class="ident">plot_eod_waveform</span></span>(<span>ax,<br>eod_waveform,<br>props,<br>peaks=None,<br>unit=None,<br>mstyle={'lw': 2, 'color': 'tab:red'},<br>pstyle={'facecolor': 'tab:green', 'alpha': 0.2, 'edgecolor': 'none'},<br>nstyle={'facecolor': 'tab:blue', 'alpha': 0.2, 'edgecolor': 'none'},<br>sstyle={'color': '0.8'},<br>fstyle={'lw': 6, 'color': 'tab:blue'},<br>zstyle={'lw': 1, 'color': '0.7'})</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_eod_waveform(ax, eod_waveform, props, peaks=None, unit=None,
                      mstyle=dict(lw=2, color=&#39;tab:red&#39;),
                      pstyle=dict(facecolor=&#39;tab:green&#39;, alpha=0.2,
                                  edgecolor=&#39;none&#39;),
                      nstyle=dict(facecolor=&#39;tab:blue&#39;, alpha=0.2,
                                  edgecolor=&#39;none&#39;),
                      sstyle=dict(color=&#39;0.8&#39;),
                      fstyle=dict(lw=6, color=&#39;tab:blue&#39;),
                      zstyle=dict(lw=1, color=&#39;0.7&#39;)):
    &#34;&#34;&#34;Plot mean EOD, its standard error, and an optional fit to the EOD.

    Parameters
    ----------
    ax: matplotlib axes
        Axes used for plotting.
    eod_waveform: 2-D array
        EOD waveform. First column is time in seconds, second column
        the (mean) eod waveform. The optional third column is the
        standard error, and the optional fourth column is a fit on the
        waveform.
    props: dict
        A dictionary with properties of the analyzed EOD waveform as
        returned by `analyze_wave()` and `analyze_pulse()`.
    peaks: 2_D arrays or None
        List of peak properties (index, time, and amplitude) of a EOD pulse
        as returned by `analyze_pulse()`.
    unit: string
        Optional unit of the data used for y-label.
    mstyle: dict
        Arguments passed on to the plot command for the mean EOD.
    pstyle: dict
        Arguments passed on to the fill_between command for coloring
        positive phases.
    nstyle: dict
        Arguments passed on to the fill_between command for coloring
        negative phases.
    sstyle: dict
        Arguments passed on to the fill_between command for the
        standard error of the EOD.
    fstyle: dict
        Arguments passed on to the plot command for the fitted EOD.
    zstyle: dict
        Arguments passed on to the plot command for the zero line.
    &#34;&#34;&#34;
    ax.autoscale(True)
    time = 1000 * eod_waveform[:,0]
    mean_eod = eod_waveform[:,1]
    # plot zero line:
    ax.axhline(0.0, zorder=-5, **zstyle)
    # plot areas:
    if peaks is not None and len(peaks) &gt; 0:
        if pstyle is not None and len(pstyle) &gt; 0:
            ax.fill_between(time, mean_eod, 0, mean_eod &gt;= 0, zorder=4,
                            **pstyle)
        if nstyle is not None and len(nstyle) &gt; 0:
                ax.fill_between(time, mean_eod, 0, mean_eod &lt;= 0, zorder=4,
                                **nstyle)
    # plot fit:
    if eod_waveform.shape[1] &gt; 3:
        ax.plot(time, eod_waveform[:,3], zorder=5, **fstyle)
    # plot waveform:
    ax.plot(time, mean_eod, zorder=10, **mstyle)
    # plot standard error:
    if eod_waveform.shape[1] &gt; 2:
        std_eod = eod_waveform[:,2]
        if np.mean(std_eod)/(np.max(mean_eod) - np.min(mean_eod)) &gt; 0.1:
            ax.autoscale_view(False)
            ax.autoscale(False)
        ax.fill_between(time, mean_eod + std_eod, mean_eod - std_eod,
                        zorder=-10, **sstyle)
    # ax height dimensions:
    pixely = np.abs(np.diff(ax.get_window_extent().get_points()[:,1]))[0]
    ymin, ymax = ax.get_ylim()
    unity = ymax - ymin
    dyu = np.abs(unity)/pixely
    font_size = plt.rcParams[&#39;font.size&#39;]*dyu
    # annotate fit:
    tau = None if props is None else props.get(&#39;tau&#39;, None)
    ty = 0.0
    if tau is not None and eod_waveform.shape[1] &gt; 3:
        if tau &lt; 0.001:
            label = f&#39;\u03c4={1.e6*tau:.0f}\u00b5s&#39;
        else:
            label = f&#39;\u03c4={1.e3*tau:.2f}ms&#39;
        inx = np.argmin(np.isnan(eod_waveform[:,3]))
        x = eod_waveform[inx,0] + 1.5*tau
        ty = 0.7*eod_waveform[inx,3]
        if np.abs(ty) &lt; 0.5*font_size:
            ty = 0.5*font_size*np.sign(ty)
        va = &#39;bottom&#39; if ty &gt; 0.0 else &#39;top&#39;
        ax.text(1000*x, ty, label, ha=&#39;left&#39;, va=va, zorder=20)
    # annotate peaks:
    if peaks is not None and len(peaks) &gt; 0:
        for i, p in enumerate(peaks):
            ax.plot(1000*p[1], p[2], &#39;o&#39;, clip_on=False, zorder=0,
                    alpha=0.4, color=mstyle[&#39;color&#39;], ms=12,
                    mec=&#39;none&#39;, mew=0)
            label = f&#39;P{p[0]:.0f}&#39;
            if p[0] != 1:
                if np.abs(p[1]) &lt; 0.001:
                    ts = f&#39;{1.0e6*p[1]:.0f}\u00b5s&#39;
                elif np.abs(p[1]) &lt; 0.01:
                    ts = f&#39;{1.0e3*p[1]:.2f}ms&#39;
                else:
                    ts = f&#39;{1.0e3*p[1]:.3g}ms&#39;
                if np.abs(p[3]) &lt; 0.05:
                    ps = f&#39;{100*p[3]:.1f}%&#39;
                else:
                    ps = f&#39;{100*p[3]:.0f}%&#39;
                label += f&#39;({ps} @ {ts})&#39;
            va = &#39;baseline&#39;
            dy = 0.4*font_size
            sign = np.sign(p[2])
            if sign &lt; 0:
                va = &#39;top&#39;
                dy = -dy
            if p[0] == 1:
                dy = 0.0
            &#34;&#34;&#34;
            if p[2] &lt;= np.min(peaks[:,2]):
                dy = -0.8*font_size
                va = &#39;baseline&#39;
            &#34;&#34;&#34;
            if p[2] + dy &lt; ymin + 1.3*font_size:
                dy = ymin + 1.3*font_size - p[2]
            if p[0] == np.max(peaks[:,0]) and ty*p[2] &gt; 0.0 and \
               sign*p[2]+dy &lt; sign*ty+1.2*font_size:
                dy = ty + sign*1.2*font_size - p[2]
            dx = 0.05*time[-1]
            if p[1] &gt;= 0.0:
                ax.text(1000*p[1]+dx, p[2]+dy, label,
                        ha=&#39;left&#39;, va=va, zorder=20)
            else:
                ax.text(1000*p[1]-dx, p[2]+dy, label,
                        ha=&#39;right&#39;, va=va, zorder=20)
            # area:
            if len(p) &gt; 6:
                if np.abs(p[6]) &lt; 0.05:
                    label = f&#39;{100*p[6]:.1f}%&#39;
                else:
                    label = f&#39;{100*p[6]:.0f}%&#39;
                dxl = p[1] - peaks[i - 1][1] if i &gt; 0 else np.inf
                dxr = peaks[i + 1][1] - p[1] if i &lt; len(peaks) - 1 else np.inf
                dx = 0
                if dxl &lt; dxr:
                    dx = +1000*0.2*dxl
                elif dxr &lt; dxl:
                    dx = -1000*0.2*dxr
                if abs(p[3]) &gt; 0.5:
                    ax.text(1000*p[1] + dx, sign*0.6*font_size, label,
                            rotation=&#39;vertical&#39;,
                            va=&#39;top&#39; if sign &lt; 0 else &#39;bottom&#39;,
                            ha=&#39;center&#39;, zorder=20)
                else:
                    ax.text(1000*p[1] + dx, -sign*0.4*font_size, label,
                            va=&#39;baseline&#39; if sign &lt; 0 else &#39;top&#39;,
                            ha=&#39;center&#39;, zorder=20)
    # annotate plot:
    if unit is None or len(unit) == 0 or unit == &#39;a.u.&#39;:
        unit = &#39;&#39;
    if props is not None:
        label = f&#39;p-p amplitude = {props[&#34;p-p-amplitude&#34;]:.3g} {unit}\n&#39;
        if &#39;n&#39; in props:
            eods = &#39;EODs&#39; if props[&#39;n&#39;] &gt; 1 else &#39;EOD&#39;
            label += f&#39;n = {props[&#34;n&#34;]} {eods}\n&#39;
        if &#39;flipped&#39; in props and props[&#39;flipped&#39;]:
            label += &#39;flipped\n&#39;
        if &#39;polaritybalance&#39; in props:
            label += f&#39;PB={100*props[&#34;polaritybalance&#34;]:.0f} %\n&#39;
        if -eod_waveform[0,0] &lt; 0.6*eod_waveform[-1,0]:
            ax.text(0.97, 0.97, label, transform=ax.transAxes,
                    va=&#39;top&#39;, ha=&#39;right&#39;, zorder=20)
        else:
            ax.text(0.03, 0.97, label, transform=ax.transAxes,
                    va=&#39;top&#39;, zorder=20)
    # axis:                
    if props is not None and props[&#39;type&#39;] == &#39;wave&#39;:
        lim = 750.0/props[&#39;EODf&#39;]
        ax.set_xlim([-lim, +lim])
    else:
        ax.set_xlim(time[0], time[-1])
    ax.set_xlabel(&#39;Time [msec]&#39;)
    if unit:
        ax.set_ylabel(f&#39;Amplitude [{unit}]&#39;)
    else:
        ax.set_ylabel(&#39;Amplitude&#39;)</code></pre>
</details>
<div class="desc"><p>Plot mean EOD, its standard error, and an optional fit to the EOD.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib axes</code></dt>
<dd>Axes used for plotting.</dd>
<dt><strong><code>eod_waveform</code></strong> :&ensp;<code>2-D array</code></dt>
<dd>EOD waveform. First column is time in seconds, second column
the (mean) eod waveform. The optional third column is the
standard error, and the optional fourth column is a fit on the
waveform.</dd>
<dt><strong><code>props</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary with properties of the analyzed EOD waveform as
returned by <code><a title="thunderfish.eodanalysis.analyze_wave" href="#thunderfish.eodanalysis.analyze_wave">analyze_wave()</a></code> and <code><a title="thunderfish.eodanalysis.analyze_pulse" href="#thunderfish.eodanalysis.analyze_pulse">analyze_pulse()</a></code>.</dd>
<dt><strong><code>peaks</code></strong> :&ensp;<code>2_D arrays</code> or <code>None</code></dt>
<dd>List of peak properties (index, time, and amplitude) of a EOD pulse
as returned by <code><a title="thunderfish.eodanalysis.analyze_pulse" href="#thunderfish.eodanalysis.analyze_pulse">analyze_pulse()</a></code>.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>string</code></dt>
<dd>Optional unit of the data used for y-label.</dd>
<dt><strong><code>mstyle</code></strong> :&ensp;<code>dict</code></dt>
<dd>Arguments passed on to the plot command for the mean EOD.</dd>
<dt><strong><code>pstyle</code></strong> :&ensp;<code>dict</code></dt>
<dd>Arguments passed on to the fill_between command for coloring
positive phases.</dd>
<dt><strong><code>nstyle</code></strong> :&ensp;<code>dict</code></dt>
<dd>Arguments passed on to the fill_between command for coloring
negative phases.</dd>
<dt><strong><code>sstyle</code></strong> :&ensp;<code>dict</code></dt>
<dd>Arguments passed on to the fill_between command for the
standard error of the EOD.</dd>
<dt><strong><code>fstyle</code></strong> :&ensp;<code>dict</code></dt>
<dd>Arguments passed on to the plot command for the fitted EOD.</dd>
<dt><strong><code>zstyle</code></strong> :&ensp;<code>dict</code></dt>
<dd>Arguments passed on to the plot command for the zero line.</dd>
</dl></div>
</dd>
<dt id="thunderfish.eodanalysis.plot_wave_spectrum"><code class="name flex">
<span>def <span class="ident">plot_wave_spectrum</span></span>(<span>axa,<br>axp,<br>spec,<br>props,<br>unit=None,<br>mstyle={'color': 'tab:blue', 'markersize': 10},<br>sstyle={'color': 'tab:blue', 'alpha': 0.5, 'lw': 2})</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_wave_spectrum(axa, axp, spec, props, unit=None,
                       mstyle=dict(color=&#39;tab:blue&#39;, markersize=10),
                       sstyle=dict(color=&#39;tab:blue&#39;, alpha=0.5, lw=2)):
    &#34;&#34;&#34;Plot and annotate spectrum of wave EOD.

    Parameters
    ----------
    axa: matplotlib axes
        Axes for amplitude plot.
    axp: matplotlib axes
        Axes for phase plot.
    spec: 2-D array
        The amplitude spectrum of a single pulse as returned by
        `analyze_wave()`.  First column is the index of the harmonics,
        second column its frequency, third column its amplitude,
        fourth column its amplitude relative to the fundamental, fifth
        column is power of harmonics relative to fundamental in
        decibel, and sixth column the phase shift relative to the
        fundamental.
    props: dict
        A dictionary with properties of the analyzed EOD waveform as
        returned by `analyze_wave()`.
    unit: string
        Optional unit of the data used for y-label.
    mstyle: dict
        Arguments passed on to the stem plot command for the markers.
    sstyle: dict
        Arguments passed on to the stem plot command for the stem lines.
    &#34;&#34;&#34;
    n = min(9, np.sum(np.isfinite(spec[:,2])))
    # amplitudes:
    markers, stemlines, _ = axa.stem(spec[:n,0]+1, spec[:n,2], basefmt=&#39;none&#39;)
    plt.setp(markers, clip_on=False, **mstyle)
    plt.setp(stemlines, **sstyle)
    axa.set_xlim(0.5, n+0.5)
    axa.set_ylim(bottom=0)
    axa.xaxis.set_major_locator(plt.MultipleLocator(1))
    axa.tick_params(&#39;x&#39;, direction=&#39;out&#39;)
    if unit:
        axa.set_ylabel(f&#39;Amplitude [{unit}]&#39;)
    else:
        axa.set_ylabel(&#39;Amplitude&#39;)
    # phases:
    phases = spec[:n,5]
    phases[phases&lt;0.0] = phases[phases&lt;0.0] + 2.0*np.pi
    markers, stemlines, _ = axp.stem(spec[:n,0]+1, phases[:n], basefmt=&#39;none&#39;)
    plt.setp(markers, clip_on=False, **mstyle)
    plt.setp(stemlines, **sstyle)
    axp.set_xlim(0.5, n+0.5)
    axp.xaxis.set_major_locator(plt.MultipleLocator(1))
    axp.tick_params(&#39;x&#39;, direction=&#39;out&#39;)
    axp.set_ylim(0, 2.0*np.pi)
    axp.set_yticks([0, np.pi, 2.0*np.pi])
    axp.set_yticklabels([&#39;0&#39;, &#39;\u03c0&#39;, &#39;2\u03c0&#39;])
    axp.set_xlabel(&#39;Harmonics&#39;)
    axp.set_ylabel(&#39;Phase&#39;)</code></pre>
</details>
<div class="desc"><p>Plot and annotate spectrum of wave EOD.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>axa</code></strong> :&ensp;<code>matplotlib axes</code></dt>
<dd>Axes for amplitude plot.</dd>
<dt><strong><code>axp</code></strong> :&ensp;<code>matplotlib axes</code></dt>
<dd>Axes for phase plot.</dd>
<dt><strong><code>spec</code></strong> :&ensp;<code>2-D array</code></dt>
<dd>The amplitude spectrum of a single pulse as returned by
<code><a title="thunderfish.eodanalysis.analyze_wave" href="#thunderfish.eodanalysis.analyze_wave">analyze_wave()</a></code>.
First column is the index of the harmonics,
second column its frequency, third column its amplitude,
fourth column its amplitude relative to the fundamental, fifth
column is power of harmonics relative to fundamental in
decibel, and sixth column the phase shift relative to the
fundamental.</dd>
<dt><strong><code>props</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary with properties of the analyzed EOD waveform as
returned by <code><a title="thunderfish.eodanalysis.analyze_wave" href="#thunderfish.eodanalysis.analyze_wave">analyze_wave()</a></code>.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>string</code></dt>
<dd>Optional unit of the data used for y-label.</dd>
<dt><strong><code>mstyle</code></strong> :&ensp;<code>dict</code></dt>
<dd>Arguments passed on to the stem plot command for the markers.</dd>
<dt><strong><code>sstyle</code></strong> :&ensp;<code>dict</code></dt>
<dd>Arguments passed on to the stem plot command for the stem lines.</dd>
</dl></div>
</dd>
<dt id="thunderfish.eodanalysis.plot_pulse_spectrum"><code class="name flex">
<span>def <span class="ident">plot_pulse_spectrum</span></span>(<span>ax,<br>power,<br>props,<br>min_freq=1.0,<br>max_freq=10000.0,<br>sstyle={'lw': 3, 'color': 'tab:blue'},<br>pstyle={'ls': '', 'marker': 'o', 'markersize': 10, 'color': 'tab:blue', 'mec': 'none', 'mew': 0, 'alpha': 0.4},<br>cstyle={'lw': 1, 'ls': '-', 'color': '0.5'},<br>att5_color='0.8',<br>att50_color='0.9')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_pulse_spectrum(ax, power, props, min_freq=1.0, max_freq=10000.0,
                        sstyle=dict(lw=3, color=&#39;tab:blue&#39;),
                        pstyle=dict(ls=&#39;&#39;, marker=&#39;o&#39;, markersize=10,
                                    color=&#39;tab:blue&#39;, mec=&#39;none&#39;, mew=0,
                                    alpha=0.4),
                        cstyle=dict(lw=1, ls=&#39;-&#39;, color=&#39;0.5&#39;),
                        att5_color=&#39;0.8&#39;, att50_color=&#39;0.9&#39;):
    &#34;&#34;&#34;Plot and annotate spectrum of single pulse EOD.

    Parameters
    ----------
    ax: matplotlib axes
        Axes used for plotting.
    power: 2-D array
        The power spectrum of a single pulse as returned by `analyze_pulse()`.
        First column are the frequencies, second column the power.
    props: dict
        A dictionary with properties of the analyzed EOD waveform as
        returned by `analyze_pulse()`.
    min_freq: float
        Minimun frequency of the spectrum to be plotted (logscale!).
    max_freq: float
        Maximun frequency of the spectrum to be plotted (logscale!).
    sstyle: dict
        Arguments passed on to the plot command for the power spectrum.
    pstyle: dict
        Arguments passed on to the plot command for marking the peak frequency.
    cstyle: dict
        Arguments passed on to the plot command for the line marking
        the lower cutoff frequency.
    att5_color: matplotlib color specification
        Color for the rectangular patch marking the first 5 Hz.
    att50_color: matplotlib color specification
        Color for the rectangular patch marking the first 50 Hz.
    &#34;&#34;&#34;
    ax.axvspan(1, 50, color=att50_color, zorder=1)
    att = props[&#39;poweratt50&#39;]
    if att &lt; -5.0:
        ax.text(10.0, att+1.0, f&#39;{att:.0f} dB&#39;, ha=&#39;left&#39;, va=&#39;bottom&#39;, zorder=10)
    else:
        ax.text(10.0, att-1.0, f&#39;{att:.0f} dB&#39;, ha=&#39;left&#39;, va=&#39;top&#39;, zorder=10)
    ax.axvspan(1, 5, color=att5_color, zorder=2)
    att = props[&#39;poweratt5&#39;]
    if att &lt; -5.0:
        ax.text(4.0, att+1.0, f&#39;{att:.0f} dB&#39;, ha=&#39;right&#39;, va=&#39;bottom&#39;, zorder=10)
    else:
        ax.text(4.0, att-1.0, f&#39;{att:.0f} dB&#39;, ha=&#39;right&#39;, va=&#39;top&#39;, zorder=10)
    lowcutoff = props[&#39;lowcutoff&#39;]
    if lowcutoff &gt;= min_freq:
        ax.plot([lowcutoff, lowcutoff, 1.0], [-60.0, 0.5*att, 0.5*att],
                zorder=3, **cstyle)
        ax.text(1.2*lowcutoff, 0.5*att-1.0, f&#39;{lowcutoff:.0f} Hz&#39;, ha=&#39;left&#39;, va=&#39;top&#39;, zorder=10)
    db = decibel(power[:,1])
    smax = np.nanmax(db)
    ax.plot(power[:,0], db - smax, zorder=4, **sstyle)
    peakfreq = props[&#39;peakfreq&#39;]
    if peakfreq &gt;= min_freq:
        ax.plot([peakfreq], [0.0], zorder=5, **pstyle)
        ax.text(peakfreq*1.2, 1.0, f&#39;{peakfreq:.0f} Hz&#39;, va=&#39;bottom&#39;, zorder=10)
    ax.set_xlim(min_freq, max_freq)
    ax.set_xscale(&#39;log&#39;)
    ax.set_ylim(-60.0, 2.0)
    ax.set_xlabel(&#39;Frequency [Hz]&#39;)
    ax.set_ylabel(&#39;Power [dB]&#39;)</code></pre>
</details>
<div class="desc"><p>Plot and annotate spectrum of single pulse EOD.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib axes</code></dt>
<dd>Axes used for plotting.</dd>
<dt><strong><code>power</code></strong> :&ensp;<code>2-D array</code></dt>
<dd>The power spectrum of a single pulse as returned by <code><a title="thunderfish.eodanalysis.analyze_pulse" href="#thunderfish.eodanalysis.analyze_pulse">analyze_pulse()</a></code>.
First column are the frequencies, second column the power.</dd>
<dt><strong><code>props</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary with properties of the analyzed EOD waveform as
returned by <code><a title="thunderfish.eodanalysis.analyze_pulse" href="#thunderfish.eodanalysis.analyze_pulse">analyze_pulse()</a></code>.</dd>
<dt><strong><code>min_freq</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimun frequency of the spectrum to be plotted (logscale!).</dd>
<dt><strong><code>max_freq</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximun frequency of the spectrum to be plotted (logscale!).</dd>
<dt><strong><code>sstyle</code></strong> :&ensp;<code>dict</code></dt>
<dd>Arguments passed on to the plot command for the power spectrum.</dd>
<dt><strong><code>pstyle</code></strong> :&ensp;<code>dict</code></dt>
<dd>Arguments passed on to the plot command for marking the peak frequency.</dd>
<dt><strong><code>cstyle</code></strong> :&ensp;<code>dict</code></dt>
<dd>Arguments passed on to the plot command for the line marking
the lower cutoff frequency.</dd>
<dt><strong><code>att5_color</code></strong> :&ensp;<code>matplotlib color specification</code></dt>
<dd>Color for the rectangular patch marking the first 5 Hz.</dd>
<dt><strong><code>att50_color</code></strong> :&ensp;<code>matplotlib color specification</code></dt>
<dd>Color for the rectangular patch marking the first 50 Hz.</dd>
</dl></div>
</dd>
<dt id="thunderfish.eodanalysis.save_eod_waveform"><code class="name flex">
<span>def <span class="ident">save_eod_waveform</span></span>(<span>mean_eod, unit, idx, basename, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_eod_waveform(mean_eod, unit, idx, basename, **kwargs):
    &#34;&#34;&#34;Save mean EOD waveform to file.

    Parameters
    ----------
    mean_eod: 2D array of floats
        Averaged EOD waveform as returned by `eod_waveform()`,
        `analyze_wave()`, and `analyze_pulse()`.
    unit: string
        Unit of the waveform data.
    idx: int or None
        Index of fish.
    basename: string or stream
        If string, path and basename of file.
        If `basename` does not have an extension,
        &#39;-eodwaveform&#39;, the fish index, and a file extension are appended.
        If stream, write EOD waveform data into this stream.
    kwargs:
        Arguments passed on to `TableData.write()`.

    Returns
    -------
    filename: string
        Path and full name of the written file in case of `basename`
        being a string. Otherwise, the file name and extension that
        would have been appended to a basename.

    See Also
    --------
    load_eod_waveform()
    &#34;&#34;&#34;
    td = TableData(mean_eod[:,:3]*[1000.0, 1.0, 1.0], [&#39;time&#39;, &#39;mean&#39;, &#39;sem&#39;],
                   [&#39;ms&#39;, unit, unit], [&#39;%.3f&#39;, &#39;%.6g&#39;, &#39;%.6g&#39;])
    if mean_eod.shape[1] &gt; 3:
        td.append(&#39;fit&#39;, unit, &#39;%.5f&#39;, mean_eod[:,3])
    _, ext = os.path.splitext(basename)
    fp = &#39;&#39;
    if not ext:
        fp = &#39;-eodwaveform&#39;
        if idx is not None:
            fp += f&#39;-{idx}&#39;
    return td.write_file_stream(basename, fp, **kwargs)</code></pre>
</details>
<div class="desc"><p>Save mean EOD waveform to file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mean_eod</code></strong> :&ensp;<code>2D array</code> of <code>floats</code></dt>
<dd>Averaged EOD waveform as returned by <code><a title="thunderfish.eodanalysis.eod_waveform" href="#thunderfish.eodanalysis.eod_waveform">eod_waveform()</a></code>,
<code><a title="thunderfish.eodanalysis.analyze_wave" href="#thunderfish.eodanalysis.analyze_wave">analyze_wave()</a></code>, and <code><a title="thunderfish.eodanalysis.analyze_pulse" href="#thunderfish.eodanalysis.analyze_pulse">analyze_pulse()</a></code>.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>string</code></dt>
<dd>Unit of the waveform data.</dd>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>Index of fish.</dd>
<dt><strong><code>basename</code></strong> :&ensp;<code>string</code> or <code>stream</code></dt>
<dd>If string, path and basename of file.
If <code>basename</code> does not have an extension,
'-eodwaveform', the fish index, and a file extension are appended.
If stream, write EOD waveform data into this stream.</dd>
</dl>
<p>kwargs:
Arguments passed on to <code>TableData.write()</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>string</code></dt>
<dd>Path and full name of the written file in case of <code>basename</code>
being a string. Otherwise, the file name and extension that
would have been appended to a basename.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="thunderfish.eodanalysis.load_eod_waveform" href="#thunderfish.eodanalysis.load_eod_waveform">load_eod_waveform()</a></code></p></div>
</dd>
<dt id="thunderfish.eodanalysis.load_eod_waveform"><code class="name flex">
<span>def <span class="ident">load_eod_waveform</span></span>(<span>file_path)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_eod_waveform(file_path):
    &#34;&#34;&#34;Load EOD waveform from file.

    Parameters
    ----------
    file_path: string
        Path of the file to be loaded.

    Returns
    -------
    mean_eod: 2D array of floats
        Averaged EOD waveform: time in seconds, mean, standard deviation, fit.
    unit: string
        Unit of EOD waveform.

    Raises
    ------
    FileNotFoundError:
        If `file_path` does not exist.

    See Also
    --------
    save_eod_waveform()
    &#34;&#34;&#34;
    data = TableData(file_path)
    mean_eod = data.array()
    mean_eod[:,0] *= 0.001
    return mean_eod, data.unit(&#39;mean&#39;)</code></pre>
</details>
<div class="desc"><p>Load EOD waveform from file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>string</code></dt>
<dd>Path of the file to be loaded.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mean_eod</code></strong> :&ensp;<code>2D array</code> of <code>floats</code></dt>
<dd>Averaged EOD waveform: time in seconds, mean, standard deviation, fit.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>string</code></dt>
<dd>Unit of EOD waveform.</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="filenotfounderror">Filenotfounderror</h2>
<p>If <code>file_path</code> does not exist.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="thunderfish.eodanalysis.save_eod_waveform" href="#thunderfish.eodanalysis.save_eod_waveform">save_eod_waveform()</a></code></p></div>
</dd>
<dt id="thunderfish.eodanalysis.save_wave_eodfs"><code class="name flex">
<span>def <span class="ident">save_wave_eodfs</span></span>(<span>wave_eodfs, wave_indices, basename, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_wave_eodfs(wave_eodfs, wave_indices, basename, **kwargs):
    &#34;&#34;&#34;Save frequencies of wave EODs to file.

    Parameters
    ----------
    wave_eodfs: list of 2D arrays
        Each item is a matrix with the frequencies and powers
        (columns) of the fundamental and harmonics (rows) as returned
        by `harmonics.harmonic_groups()`.
    wave_indices: array
        Indices identifying each fish or NaN.
        If None no index column is inserted.
    basename: string or stream
        If string, path and basename of file.
        If `basename` does not have an extension,
        &#39;-waveeodfs&#39; and a file extension according to `kwargs` are appended.
        If stream, write EOD frequencies data into this stream.
    kwargs:
        Arguments passed on to `TableData.write()`.

    Returns
    -------
    filename: string
        Path and full name of the written file in case of `basename`
        being a string. Otherwise, the file name and extension that
        would have been appended to a basename.

    See Also
    --------
    load_wave_eodfs()

    &#34;&#34;&#34;
    eodfs = fundamental_freqs_and_power(wave_eodfs)
    td = TableData()
    if wave_indices is not None:
        td.append(&#39;index&#39;, &#39;&#39;, &#39;%d&#39;, [wi if wi &gt;= 0 else np.nan for wi in wave_indices])
    td.append(&#39;EODf&#39;, &#39;Hz&#39;, &#39;%7.2f&#39;, eodfs[:,0])
    td.append(&#39;datapower&#39;, &#39;dB&#39;, &#39;%7.2f&#39;, eodfs[:,1])
    _, ext = os.path.splitext(basename)
    fp = &#39;-waveeodfs&#39; if not ext else &#39;&#39;
    return td.write_file_stream(basename, fp, **kwargs)</code></pre>
</details>
<div class="desc"><p>Save frequencies of wave EODs to file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>wave_eodfs</code></strong> :&ensp;<code>list</code> of <code>2D arrays</code></dt>
<dd>Each item is a matrix with the frequencies and powers
(columns) of the fundamental and harmonics (rows) as returned
by <code>harmonics.harmonic_groups()</code>.</dd>
<dt><strong><code>wave_indices</code></strong> :&ensp;<code>array</code></dt>
<dd>Indices identifying each fish or NaN.
If None no index column is inserted.</dd>
<dt><strong><code>basename</code></strong> :&ensp;<code>string</code> or <code>stream</code></dt>
<dd>If string, path and basename of file.
If <code>basename</code> does not have an extension,
'-waveeodfs' and a file extension according to <code>kwargs</code> are appended.
If stream, write EOD frequencies data into this stream.</dd>
</dl>
<p>kwargs:
Arguments passed on to <code>TableData.write()</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>string</code></dt>
<dd>Path and full name of the written file in case of <code>basename</code>
being a string. Otherwise, the file name and extension that
would have been appended to a basename.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="thunderfish.eodanalysis.load_wave_eodfs" href="#thunderfish.eodanalysis.load_wave_eodfs">load_wave_eodfs()</a></code></p></div>
</dd>
<dt id="thunderfish.eodanalysis.load_wave_eodfs"><code class="name flex">
<span>def <span class="ident">load_wave_eodfs</span></span>(<span>file_path)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_wave_eodfs(file_path):
    &#34;&#34;&#34;Load frequencies of wave EODs from file.

    Parameters
    ----------
    file_path: string
        Path of the file to be loaded.

    Returns
    -------
    eodfs: 2D array of floats
        EODfs and power of wave type fish.
    indices: array of ints
        Corresponding indices of fish, can contain negative numbers to
        indicate frequencies without fish.

    Raises
    ------
    FileNotFoundError:
        If `file_path` does not exist.

    See Also
    --------
    save_wave_eodfs()
    &#34;&#34;&#34;
    data = TableData(file_path)
    eodfs = data.array()
    if &#39;index&#39; in data:
        indices = data[:,&#39;index&#39;]
        indices[~np.isfinite(indices)] = -1
        indices = np.array(indices, dtype=int)
        eodfs = eodfs[:,1:]
    else:
        indices = np.zeros(data.rows(), dtype=int) - 1
    return eodfs, indices</code></pre>
</details>
<div class="desc"><p>Load frequencies of wave EODs from file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>string</code></dt>
<dd>Path of the file to be loaded.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>eodfs</code></strong> :&ensp;<code>2D array</code> of <code>floats</code></dt>
<dd>EODfs and power of wave type fish.</dd>
<dt><strong><code>indices</code></strong> :&ensp;<code>array</code> of <code>ints</code></dt>
<dd>Corresponding indices of fish, can contain negative numbers to
indicate frequencies without fish.</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="filenotfounderror">Filenotfounderror</h2>
<p>If <code>file_path</code> does not exist.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="thunderfish.eodanalysis.save_wave_eodfs" href="#thunderfish.eodanalysis.save_wave_eodfs">save_wave_eodfs()</a></code></p></div>
</dd>
<dt id="thunderfish.eodanalysis.save_wave_fish"><code class="name flex">
<span>def <span class="ident">save_wave_fish</span></span>(<span>eod_props, unit, basename, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_wave_fish(eod_props, unit, basename, **kwargs):
    &#34;&#34;&#34;Save properties of wave EODs to file.

    Parameters
    ----------
    eod_props: list of dict
        Properties of EODs as returned by `analyze_wave()` and
        `analyze_pulse()`.  Only properties of wave fish are saved.
    unit: string
        Unit of the waveform data.
    basename: string or stream
        If string, path and basename of file.
        If `basename` does not have an extension,
        &#39;-wavefish&#39; and a file extension are appended.
        If stream, write wave fish properties into this stream.
    kwargs:
        Arguments passed on to `TableData.write()`.

    Returns
    -------
    filename: string or None
        Path and full name of the written file in case of `basename`
        being a string. Otherwise, the file name and extension that
        would have been appended to a basename.
        None if no wave fish are contained in eod_props and
        consequently no file was written.

    See Also
    --------
    load_wave_fish()
    &#34;&#34;&#34;
    wave_props = [p for p in eod_props if p[&#39;type&#39;] == &#39;wave&#39;]
    if len(wave_props) == 0:
        return None
    td = TableData()
    if &#39;twin&#39; in wave_props[0] or &#39;rate&#39; in wave_props[0] or \
       &#39;nfft&#39; in wave_props[0]:
        td.append_section(&#39;recording&#39;)
    if &#39;twin&#39; in wave_props[0]:
        td.append(&#39;twin&#39;, &#39;s&#39;, &#39;%7.2f&#39;, wave_props)
        td.append(&#39;window&#39;, &#39;s&#39;, &#39;%7.2f&#39;, wave_props)
        td.append(&#39;winclipped&#39;, &#39;%&#39;, &#39;%.2f&#39;, wave_props, 100.0)
    if &#39;samplerate&#39; in wave_props[0]:
        td.append(&#39;samplerate&#39;, &#39;kHz&#39;, &#39;%.3f&#39;, wave_props, 0.001)
    if &#39;nfft&#39; in wave_props[0]:
        td.append(&#39;nfft&#39;, &#39;&#39;, &#39;%d&#39;, wave_props)
        td.append(&#39;dfreq&#39;, &#39;Hz&#39;, &#39;%.2f&#39;, wave_props)
    td.append_section(&#39;waveform&#39;)
    td.append(&#39;index&#39;, &#39;&#39;, &#39;%d&#39;, wave_props)
    td.append(&#39;EODf&#39;, &#39;Hz&#39;, &#39;%7.2f&#39;, wave_props)
    td.append(&#39;p-p-amplitude&#39;, unit, &#39;%.5f&#39;, wave_props)
    td.append(&#39;power&#39;, &#39;dB&#39;, &#39;%7.2f&#39;, wave_props)
    if &#39;datapower&#39; in wave_props[0]:
        td.append(&#39;datapower&#39;, &#39;dB&#39;, &#39;%7.2f&#39;, wave_props)
    td.append(&#39;thd&#39;, &#39;%&#39;, &#39;%.2f&#39;, wave_props, 100.0)
    td.append(&#39;dbdiff&#39;, &#39;dB&#39;, &#39;%7.2f&#39;, wave_props)
    td.append(&#39;maxdb&#39;, &#39;dB&#39;, &#39;%7.2f&#39;, wave_props)
    if &#39;noise&#39; in wave_props[0]:
        td.append(&#39;noise&#39;, &#39;%&#39;, &#39;%.1f&#39;, wave_props, 100.0)
    td.append(&#39;rmserror&#39;, &#39;%&#39;, &#39;%.2f&#39;, wave_props, 100.0)
    if &#39;clipped&#39; in wave_props[0]:
        td.append(&#39;clipped&#39;, &#39;%&#39;, &#39;%.1f&#39;, wave_props, 100.0)
    td.append(&#39;flipped&#39;, &#39;&#39;, &#39;%d&#39;, wave_props)
    td.append(&#39;n&#39;, &#39;&#39;, &#39;%5d&#39;, wave_props)
    td.append_section(&#39;timing&#39;)
    td.append(&#39;ncrossings&#39;, &#39;&#39;, &#39;%d&#39;, wave_props)
    td.append(&#39;peakwidth&#39;, &#39;%&#39;, &#39;%.2f&#39;, wave_props, 100.0)
    td.append(&#39;troughwidth&#39;, &#39;%&#39;, &#39;%.2f&#39;, wave_props, 100.0)
    td.append(&#39;minwidth&#39;, &#39;%&#39;, &#39;%.2f&#39;, wave_props, 100.0)
    td.append(&#39;leftpeak&#39;, &#39;%&#39;, &#39;%.2f&#39;, wave_props, 100.0)
    td.append(&#39;rightpeak&#39;, &#39;%&#39;, &#39;%.2f&#39;, wave_props, 100.0)
    td.append(&#39;lefttrough&#39;, &#39;%&#39;, &#39;%.2f&#39;, wave_props, 100.0)
    td.append(&#39;righttrough&#39;, &#39;%&#39;, &#39;%.2f&#39;, wave_props, 100.0)
    td.append(&#39;p-p-distance&#39;, &#39;%&#39;, &#39;%.2f&#39;, wave_props, 100.0)
    td.append(&#39;min-p-p-distance&#39;, &#39;%&#39;, &#39;%.2f&#39;, wave_props, 100.0)
    td.append(&#39;relpeakampl&#39;, &#39;%&#39;, &#39;%.2f&#39;, wave_props, 100.0)
    _, ext = os.path.splitext(basename)
    fp = &#39;-wavefish&#39; if not ext else &#39;&#39;
    return td.write_file_stream(basename, fp, **kwargs)</code></pre>
</details>
<div class="desc"><p>Save properties of wave EODs to file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>eod_props</code></strong> :&ensp;<code>list</code> of <code>dict</code></dt>
<dd>Properties of EODs as returned by <code><a title="thunderfish.eodanalysis.analyze_wave" href="#thunderfish.eodanalysis.analyze_wave">analyze_wave()</a></code> and
<code><a title="thunderfish.eodanalysis.analyze_pulse" href="#thunderfish.eodanalysis.analyze_pulse">analyze_pulse()</a></code>.
Only properties of wave fish are saved.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>string</code></dt>
<dd>Unit of the waveform data.</dd>
<dt><strong><code>basename</code></strong> :&ensp;<code>string</code> or <code>stream</code></dt>
<dd>If string, path and basename of file.
If <code>basename</code> does not have an extension,
'-wavefish' and a file extension are appended.
If stream, write wave fish properties into this stream.</dd>
</dl>
<p>kwargs:
Arguments passed on to <code>TableData.write()</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>string</code> or <code>None</code></dt>
<dd>Path and full name of the written file in case of <code>basename</code>
being a string. Otherwise, the file name and extension that
would have been appended to a basename.
None if no wave fish are contained in eod_props and
consequently no file was written.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="thunderfish.eodanalysis.load_wave_fish" href="#thunderfish.eodanalysis.load_wave_fish">load_wave_fish()</a></code></p></div>
</dd>
<dt id="thunderfish.eodanalysis.load_wave_fish"><code class="name flex">
<span>def <span class="ident">load_wave_fish</span></span>(<span>file_path)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_wave_fish(file_path):
    &#34;&#34;&#34;Load properties of wave EODs from file.

    All times are scaled to seconds, all frequencies to Hertz and all
    percentages to fractions.

    Parameters
    ----------
    file_path: string
        Path of the file to be loaded.

    Returns
    -------
    eod_props: list of dict
        Properties of EODs.

    Raises
    ------
    FileNotFoundError:
        If `file_path` does not exist.

    See Also
    --------
    save_wave_fish()

    &#34;&#34;&#34;
    data = TableData(file_path)
    eod_props = data.dicts()
    for props in eod_props:
        if &#39;winclipped&#39; in props:
            props[&#39;winclipped&#39;] /= 100
        if &#39;samplerate&#39; in props:
            props[&#39;samplerate&#39;] *= 1000
        if &#39;nfft&#39; in props:
            props[&#39;nfft&#39;] = int(props[&#39;nfft&#39;])
        props[&#39;index&#39;] = int(props[&#39;index&#39;])
        props[&#39;n&#39;] = int(props[&#39;n&#39;])
        props[&#39;type&#39;] = &#39;wave&#39;
        props[&#39;thd&#39;] /= 100
        props[&#39;noise&#39;] /= 100
        props[&#39;rmserror&#39;] /= 100
        if &#39;clipped&#39; in props:
            props[&#39;clipped&#39;] /= 100
        props[&#39;ncrossings&#39;] = int(props[&#39;ncrossings&#39;])
        props[&#39;peakwidth&#39;] /= 100
        props[&#39;troughwidth&#39;] /= 100
        props[&#39;minwidth&#39;] /= 100
        props[&#39;leftpeak&#39;] /= 100
        props[&#39;rightpeak&#39;] /= 100
        props[&#39;lefttrough&#39;] /= 100
        props[&#39;righttrough&#39;] /= 100
        props[&#39;p-p-distance&#39;] /= 100
        props[&#39;min-p-p-distance&#39;] /= 100
        props[&#39;relpeakampl&#39;] /= 100
    return eod_props</code></pre>
</details>
<div class="desc"><p>Load properties of wave EODs from file.</p>
<p>All times are scaled to seconds, all frequencies to Hertz and all
percentages to fractions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>string</code></dt>
<dd>Path of the file to be loaded.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>eod_props</code></strong> :&ensp;<code>list</code> of <code>dict</code></dt>
<dd>Properties of EODs.</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="filenotfounderror">Filenotfounderror</h2>
<p>If <code>file_path</code> does not exist.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="thunderfish.eodanalysis.save_wave_fish" href="#thunderfish.eodanalysis.save_wave_fish">save_wave_fish()</a></code></p></div>
</dd>
<dt id="thunderfish.eodanalysis.save_pulse_fish"><code class="name flex">
<span>def <span class="ident">save_pulse_fish</span></span>(<span>eod_props, unit, basename, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_pulse_fish(eod_props, unit, basename, **kwargs):
    &#34;&#34;&#34;Save properties of pulse EODs to file.

    Parameters
    ----------
    eod_props: list of dict
        Properties of EODs as returned by `analyze_wave()` and
        `analyze_pulse()`.  Only properties of pulse fish are saved.
    unit: string
        Unit of the waveform data.
    basename: string or stream
        If string, path and basename of file.
        If `basename` does not have an extension,
        &#39;-pulsefish&#39; and a file extension are appended.
        If stream, write pulse fish properties into this stream.
    kwargs:
        Arguments passed on to `TableData.write()`.

    Returns
    -------
    filename: string or None
        Path and full name of the written file in case of `basename`
        being a string. Otherwise, the file name and extension that
        would have been appended to a basename.
        None if no pulse fish are contained in eod_props and
        consequently no file was written.

    See Also
    --------
    load_pulse_fish()
    &#34;&#34;&#34;
    pulse_props = [p for p in eod_props if p[&#39;type&#39;] == &#39;pulse&#39;]
    if len(pulse_props) == 0:
        return None
    td = TableData()
    if &#39;twin&#39; in pulse_props[0] or &#39;samplerate&#39; in pulse_props[0] or \
       &#39;nfft&#39; in pulse_props[0]:
        td.append_section(&#39;recording&#39;)
    if &#39;twin&#39; in pulse_props[0]:
        td.append(&#39;twin&#39;, &#39;s&#39;, &#39;%7.2f&#39;, pulse_props)
        td.append(&#39;window&#39;, &#39;s&#39;, &#39;%7.2f&#39;, pulse_props)
        td.append(&#39;winclipped&#39;, &#39;%&#39;, &#39;%.2f&#39;, pulse_props, 100.0)
    if &#39;samplerate&#39; in pulse_props[0]:
        td.append(&#39;samplerate&#39;, &#39;kHz&#39;, &#39;%.3f&#39;, pulse_props, 0.001)
    if &#39;nfft&#39; in pulse_props[0]:
        td.append(&#39;nfft&#39;, &#39;&#39;, &#39;%d&#39;, pulse_props)
        td.append(&#39;dfreq&#39;, &#39;Hz&#39;, &#39;%.2f&#39;, pulse_props)
    td.append_section(&#39;waveform&#39;)
    td.append(&#39;index&#39;, &#39;&#39;, &#39;%d&#39;, pulse_props)
    td.append(&#39;EODf&#39;, &#39;Hz&#39;, &#39;%7.2f&#39;, pulse_props)
    td.append(&#39;period&#39;, &#39;ms&#39;, &#39;%7.2f&#39;, pulse_props, 1000.0)
    td.append(&#39;max-ampl&#39;, unit, &#39;%.5f&#39;, pulse_props)
    td.append(&#39;min-ampl&#39;, unit, &#39;%.5f&#39;, pulse_props)
    td.append(&#39;p-p-amplitude&#39;, unit, &#39;%.5f&#39;, pulse_props)
    if &#39;noise&#39; in pulse_props[0]:
        td.append(&#39;noise&#39;, &#39;%&#39;, &#39;%.2f&#39;, pulse_props, 100.0)
    if &#39;clipped&#39; in pulse_props[0]:
        td.append(&#39;clipped&#39;, &#39;%&#39;, &#39;%.2f&#39;, pulse_props, 100.0)
    td.append(&#39;flipped&#39;, &#39;&#39;, &#39;%d&#39;, pulse_props)
    td.append(&#39;tstart&#39;, &#39;ms&#39;, &#39;%.3f&#39;, pulse_props, 1000.0)
    td.append(&#39;tend&#39;, &#39;ms&#39;, &#39;%.3f&#39;, pulse_props, 1000.0)
    td.append(&#39;width&#39;, &#39;ms&#39;, &#39;%.3f&#39;, pulse_props, 1000.0)
    td.append(&#39;P2-P1-dist&#39;, &#39;ms&#39;, &#39;%.3f&#39;, pulse_props, 1000.0)
    td.append(&#39;tau&#39;, &#39;ms&#39;, &#39;%.3f&#39;, pulse_props, 1000.0)
    td.append(&#39;firstpeak&#39;, &#39;&#39;, &#39;%d&#39;, pulse_props)
    td.append(&#39;lastpeak&#39;, &#39;&#39;, &#39;%d&#39;, pulse_props)
    td.append(&#39;totalarea&#39;, f&#39;{unit}*ms&#39;, &#39;%.4f&#39;, pulse_props, 1000.0)
    td.append(&#39;positivearea&#39;, &#39;%&#39;, &#39;%.2f&#39;, pulse_props, 100.0)
    td.append(&#39;negativearea&#39;, &#39;%&#39;, &#39;%.2f&#39;, pulse_props, 100.0)
    td.append(&#39;polaritybalance&#39;, &#39;%&#39;, &#39;%.2f&#39;, pulse_props, 100.0)
    td.append(&#39;n&#39;, &#39;&#39;, &#39;%d&#39;, pulse_props)
    td.append_section(&#39;power spectrum&#39;)
    td.append(&#39;peakfreq&#39;, &#39;Hz&#39;, &#39;%.2f&#39;, pulse_props)
    td.append(&#39;peakpower&#39;, &#39;dB&#39;, &#39;%.2f&#39;, pulse_props)
    td.append(&#39;poweratt5&#39;, &#39;dB&#39;, &#39;%.2f&#39;, pulse_props)
    td.append(&#39;poweratt50&#39;, &#39;dB&#39;, &#39;%.2f&#39;, pulse_props)
    td.append(&#39;lowcutoff&#39;, &#39;Hz&#39;, &#39;%.2f&#39;, pulse_props)
    _, ext = os.path.splitext(basename)
    fp = &#39;-pulsefish&#39; if not ext else &#39;&#39;
    return td.write_file_stream(basename, fp, **kwargs)</code></pre>
</details>
<div class="desc"><p>Save properties of pulse EODs to file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>eod_props</code></strong> :&ensp;<code>list</code> of <code>dict</code></dt>
<dd>Properties of EODs as returned by <code><a title="thunderfish.eodanalysis.analyze_wave" href="#thunderfish.eodanalysis.analyze_wave">analyze_wave()</a></code> and
<code><a title="thunderfish.eodanalysis.analyze_pulse" href="#thunderfish.eodanalysis.analyze_pulse">analyze_pulse()</a></code>.
Only properties of pulse fish are saved.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>string</code></dt>
<dd>Unit of the waveform data.</dd>
<dt><strong><code>basename</code></strong> :&ensp;<code>string</code> or <code>stream</code></dt>
<dd>If string, path and basename of file.
If <code>basename</code> does not have an extension,
'-pulsefish' and a file extension are appended.
If stream, write pulse fish properties into this stream.</dd>
</dl>
<p>kwargs:
Arguments passed on to <code>TableData.write()</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>string</code> or <code>None</code></dt>
<dd>Path and full name of the written file in case of <code>basename</code>
being a string. Otherwise, the file name and extension that
would have been appended to a basename.
None if no pulse fish are contained in eod_props and
consequently no file was written.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="thunderfish.eodanalysis.load_pulse_fish" href="#thunderfish.eodanalysis.load_pulse_fish">load_pulse_fish()</a></code></p></div>
</dd>
<dt id="thunderfish.eodanalysis.load_pulse_fish"><code class="name flex">
<span>def <span class="ident">load_pulse_fish</span></span>(<span>file_path)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_pulse_fish(file_path):
    &#34;&#34;&#34;Load properties of pulse EODs from file.

    All times are scaled to seconds, all frequencies to Hertz and all
    percentages to fractions.

    Parameters
    ----------
    file_path: string
        Path of the file to be loaded.

    Returns
    -------
    eod_props: list of dict
        Properties of EODs.

    Raises
    ------
    FileNotFoundError:
        If `file_path` does not exist.

    See Also
    --------
    save_pulse_fish()

    &#34;&#34;&#34;
    data = TableData(file_path)
    eod_props = data.dicts()
    for props in eod_props:
        if &#39;winclipped&#39; in props:
            props[&#39;winclipped&#39;] /= 100
        if &#39;samplerate&#39; in props:
            props[&#39;samplerate&#39;] *= 1000
        if &#39;nfft&#39; in props:
            props[&#39;nfft&#39;] = int(props[&#39;nfft&#39;])
        props[&#39;index&#39;] = int(props[&#39;index&#39;])
        props[&#39;n&#39;] = int(props[&#39;n&#39;])
        props[&#39;firstpeak&#39;] = int(props[&#39;firstpeak&#39;])
        props[&#39;lastpeak&#39;] = int(props[&#39;lastpeak&#39;])
        if &#39;totalarea&#39; in props:
            props[&#39;totalarea&#39;] /= 1000
        if &#39;positivearea&#39; in props:
            props[&#39;positivearea&#39;] /= 100
        if &#39;negativearea&#39; in props:
            props[&#39;negativearea&#39;] /= 100
        if &#39;polaritybalance&#39; in props:
            props[&#39;polaritybalance&#39;] /= 100
        props[&#39;type&#39;] = &#39;pulse&#39;
        if &#39;clipped&#39; in props:
            props[&#39;clipped&#39;] /= 100
        props[&#39;period&#39;] /= 1000
        props[&#39;noise&#39;] /= 100
        props[&#39;tstart&#39;] /= 1000
        props[&#39;tend&#39;] /= 1000
        props[&#39;width&#39;] /= 1000
        props[&#39;P2-P1-dist&#39;] /= 1000
        props[&#39;tau&#39;] /= 1000
    return eod_props</code></pre>
</details>
<div class="desc"><p>Load properties of pulse EODs from file.</p>
<p>All times are scaled to seconds, all frequencies to Hertz and all
percentages to fractions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>string</code></dt>
<dd>Path of the file to be loaded.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>eod_props</code></strong> :&ensp;<code>list</code> of <code>dict</code></dt>
<dd>Properties of EODs.</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="filenotfounderror">Filenotfounderror</h2>
<p>If <code>file_path</code> does not exist.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="thunderfish.eodanalysis.save_pulse_fish" href="#thunderfish.eodanalysis.save_pulse_fish">save_pulse_fish()</a></code></p></div>
</dd>
<dt id="thunderfish.eodanalysis.save_wave_spectrum"><code class="name flex">
<span>def <span class="ident">save_wave_spectrum</span></span>(<span>spec_data, unit, idx, basename, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_wave_spectrum(spec_data, unit, idx, basename, **kwargs):
    &#34;&#34;&#34;Save amplitude and phase spectrum of wave EOD to file.

    Parameters
    ----------
    spec_data: 2D array of floats
        Amplitude and phase spectrum of wave EOD as returned by
        `analyze_wave()`.
    unit: string
        Unit of the waveform data.
    idx: int or None
        Index of fish.
    basename: string or stream
        If string, path and basename of file.
        If `basename` does not have an extension,
        &#39;-wavespectrum&#39;, the fish index, and a file extension are appended.
        If stream, write wave spectrum into this stream.
    kwargs:
        Arguments passed on to `TableData.write()`.

    Returns
    -------
    filename: string
        Path and full name of the written file in case of `basename`
        being a string. Otherwise, the file name and extension that
        would have been appended to a basename.

    See Also
    --------
    load_wave_spectrum()

    &#34;&#34;&#34;
    td = TableData(spec_data[:,:6]*[1.0, 1.0, 1.0, 100.0, 1.0, 1.0],
                   [&#39;harmonics&#39;, &#39;frequency&#39;, &#39;amplitude&#39;, &#39;relampl&#39;, &#39;relpower&#39;, &#39;phase&#39;],
                   [&#39;&#39;, &#39;Hz&#39;, unit, &#39;%&#39;, &#39;dB&#39;, &#39;rad&#39;],
                   [&#39;%.0f&#39;, &#39;%.2f&#39;, &#39;%.6f&#39;, &#39;%10.2f&#39;, &#39;%6.2f&#39;, &#39;%8.4f&#39;])
    if spec_data.shape[1] &gt; 6:
        td.append(&#39;datapower&#39;, &#39;%s^2/Hz&#39; % unit, &#39;%11.4e&#39;, spec_data[:,6])
    _, ext = os.path.splitext(basename)
    fp = &#39;&#39;
    if not ext:
        fp = &#39;-wavespectrum&#39;
        if idx is not None:
            fp += &#39;-%d&#39; % idx
    return td.write_file_stream(basename, fp, **kwargs)</code></pre>
</details>
<div class="desc"><p>Save amplitude and phase spectrum of wave EOD to file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spec_data</code></strong> :&ensp;<code>2D array</code> of <code>floats</code></dt>
<dd>Amplitude and phase spectrum of wave EOD as returned by
<code><a title="thunderfish.eodanalysis.analyze_wave" href="#thunderfish.eodanalysis.analyze_wave">analyze_wave()</a></code>.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>string</code></dt>
<dd>Unit of the waveform data.</dd>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>Index of fish.</dd>
<dt><strong><code>basename</code></strong> :&ensp;<code>string</code> or <code>stream</code></dt>
<dd>If string, path and basename of file.
If <code>basename</code> does not have an extension,
'-wavespectrum', the fish index, and a file extension are appended.
If stream, write wave spectrum into this stream.</dd>
</dl>
<p>kwargs:
Arguments passed on to <code>TableData.write()</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>string</code></dt>
<dd>Path and full name of the written file in case of <code>basename</code>
being a string. Otherwise, the file name and extension that
would have been appended to a basename.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="thunderfish.eodanalysis.load_wave_spectrum" href="#thunderfish.eodanalysis.load_wave_spectrum">load_wave_spectrum()</a></code></p></div>
</dd>
<dt id="thunderfish.eodanalysis.load_wave_spectrum"><code class="name flex">
<span>def <span class="ident">load_wave_spectrum</span></span>(<span>file_path)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_wave_spectrum(file_path):
    &#34;&#34;&#34;Load amplitude and phase spectrum of wave EOD from file.

    Parameters
    ----------
    file_path: string
        Path of the file to be loaded.

    Returns
    -------
    spec: 2D array of floats
        Amplitude and phase spectrum of wave EOD:
        harmonics, frequency, amplitude, relative amplitude in dB,
        relative power in dB, phase, data power in unit squared.
        Can contain NaNs.
    unit: string
        Unit of amplitudes.

    Raises
    ------
    FileNotFoundError:
        If `file_path` does not exist.

    See Also
    --------
    save_wave_spectrum()
    &#34;&#34;&#34;
    data = TableData(file_path)
    spec = data.array()
    spec[:,3] *= 0.01
    return spec, data.unit(&#39;amplitude&#39;)</code></pre>
</details>
<div class="desc"><p>Load amplitude and phase spectrum of wave EOD from file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>string</code></dt>
<dd>Path of the file to be loaded.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>spec</code></strong> :&ensp;<code>2D array</code> of <code>floats</code></dt>
<dd>Amplitude and phase spectrum of wave EOD:
harmonics, frequency, amplitude, relative amplitude in dB,
relative power in dB, phase, data power in unit squared.
Can contain NaNs.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>string</code></dt>
<dd>Unit of amplitudes.</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="filenotfounderror">Filenotfounderror</h2>
<p>If <code>file_path</code> does not exist.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="thunderfish.eodanalysis.save_wave_spectrum" href="#thunderfish.eodanalysis.save_wave_spectrum">save_wave_spectrum()</a></code></p></div>
</dd>
<dt id="thunderfish.eodanalysis.save_pulse_spectrum"><code class="name flex">
<span>def <span class="ident">save_pulse_spectrum</span></span>(<span>spec_data, unit, idx, basename, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_pulse_spectrum(spec_data, unit, idx, basename, **kwargs):
    &#34;&#34;&#34;Save power spectrum of pulse EOD to file.

    Parameters
    ----------
    spec_data: 2D array of floats
        Power spectrum of single pulse as returned by `analyze_pulse()`.
    unit: string
        Unit of the waveform data.
    idx: int or None
        Index of fish.
    basename: string or stream
        If string, path and basename of file.
        If `basename` does not have an extension,
        &#39;-pulsespectrum&#39;, the fish index, and a file extension are appended.
        If stream, write pulse spectrum into this stream.
    kwargs:
        Arguments passed on to `TableData.write()`.

    Returns
    -------
    filename: string
        Path and full name of the written file in case of `basename`
        being a string. Otherwise, the file name and extension that
        would have been appended to a basename.

    See Also
    --------
    load_pulse_spectrum()
    &#34;&#34;&#34;
    td = TableData(spec_data[:,:2], [&#39;frequency&#39;, &#39;power&#39;],
                   [&#39;Hz&#39;, &#39;%s^2/Hz&#39; % unit], [&#39;%.2f&#39;, &#39;%.4e&#39;])
    _, ext = os.path.splitext(basename)
    fp = &#39;&#39;
    if not ext:
        fp = &#39;-pulsespectrum&#39;
        if idx is not None:
            fp += &#39;-%d&#39; % idx
    return td.write_file_stream(basename, fp, **kwargs)</code></pre>
</details>
<div class="desc"><p>Save power spectrum of pulse EOD to file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spec_data</code></strong> :&ensp;<code>2D array</code> of <code>floats</code></dt>
<dd>Power spectrum of single pulse as returned by <code><a title="thunderfish.eodanalysis.analyze_pulse" href="#thunderfish.eodanalysis.analyze_pulse">analyze_pulse()</a></code>.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>string</code></dt>
<dd>Unit of the waveform data.</dd>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>Index of fish.</dd>
<dt><strong><code>basename</code></strong> :&ensp;<code>string</code> or <code>stream</code></dt>
<dd>If string, path and basename of file.
If <code>basename</code> does not have an extension,
'-pulsespectrum', the fish index, and a file extension are appended.
If stream, write pulse spectrum into this stream.</dd>
</dl>
<p>kwargs:
Arguments passed on to <code>TableData.write()</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>string</code></dt>
<dd>Path and full name of the written file in case of <code>basename</code>
being a string. Otherwise, the file name and extension that
would have been appended to a basename.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="thunderfish.eodanalysis.load_pulse_spectrum" href="#thunderfish.eodanalysis.load_pulse_spectrum">load_pulse_spectrum()</a></code></p></div>
</dd>
<dt id="thunderfish.eodanalysis.load_pulse_spectrum"><code class="name flex">
<span>def <span class="ident">load_pulse_spectrum</span></span>(<span>file_path)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_pulse_spectrum(file_path):
    &#34;&#34;&#34;Load power spectrum of pulse EOD from file.

    Parameters
    ----------
    file_path: string
        Path of the file to be loaded.

    Returns
    -------
    spec: 2D array of floats
        Power spectrum of single pulse: frequency, power

    Raises
    ------
    FileNotFoundError:
        If `file_path` does not exist.

    See Also
    --------
    save_pulse_spectrum()
    &#34;&#34;&#34;
    data = TableData(file_path)
    spec = data.array()
    return spec</code></pre>
</details>
<div class="desc"><p>Load power spectrum of pulse EOD from file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>string</code></dt>
<dd>Path of the file to be loaded.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>spec</code></strong> :&ensp;<code>2D array</code> of <code>floats</code></dt>
<dd>Power spectrum of single pulse: frequency, power</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="filenotfounderror">Filenotfounderror</h2>
<p>If <code>file_path</code> does not exist.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="thunderfish.eodanalysis.save_pulse_spectrum" href="#thunderfish.eodanalysis.save_pulse_spectrum">save_pulse_spectrum()</a></code></p></div>
</dd>
<dt id="thunderfish.eodanalysis.save_pulse_peaks"><code class="name flex">
<span>def <span class="ident">save_pulse_peaks</span></span>(<span>peak_data, unit, idx, basename, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_pulse_peaks(peak_data, unit, idx, basename, **kwargs):
    &#34;&#34;&#34;Save peak properties of pulse EOD to file.

    Parameters
    ----------
    peak_data: 2D array of floats
        Properties of peaks and troughs of pulse EOD as returned by
        `analyze_pulse()`.
    unit: string
        Unit of the waveform data.
    idx: int or None
        Index of fish.
    basename: string or stream
        If string, path and basename of file.
        If `basename` does not have an extension,
        &#39;-pulsepeaks&#39;, the fish index, and a file extension are appended.
        If stream, write pulse peaks into this stream.
    kwargs:
        Arguments passed on to `TableData.write()`.

    Returns
    -------
    filename: string
        Path and full name of the written file in case of `basename`
        being a string. Otherwise, the file name and extension that
        would have been appended to a basename.

    See Also
    --------
    load_pulse_peaks()
    &#34;&#34;&#34;
    if len(peak_data) == 0:
        return None
    td = TableData(peak_data[:,:7]*[1, 1000, 1, 100, 1000, 1000, 100],
                   [&#39;P&#39;, &#39;time&#39;, &#39;amplitude&#39;, &#39;relampl&#39;, &#39;width&#39;, &#39;area&#39;, &#39;relarea&#39;],
                   [&#39;&#39;, &#39;ms&#39;, unit, &#39;%&#39;, &#39;ms&#39;, f&#39;{unit}*ms&#39;, &#39;%&#39;],
                   [&#39;%.0f&#39;, &#39;%.3f&#39;, &#39;%.5f&#39;, &#39;%.2f&#39;, &#39;%.3f&#39;, &#39;%.4f&#39;, &#39;%.2f&#39;])
    _, ext = os.path.splitext(basename)
    fp = &#39;&#39;
    if not ext:
        fp = &#39;-pulsepeaks&#39;
        if idx is not None:
            fp += &#39;-%d&#39; % idx
    return td.write_file_stream(basename, fp, **kwargs)</code></pre>
</details>
<div class="desc"><p>Save peak properties of pulse EOD to file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>peak_data</code></strong> :&ensp;<code>2D array</code> of <code>floats</code></dt>
<dd>Properties of peaks and troughs of pulse EOD as returned by
<code><a title="thunderfish.eodanalysis.analyze_pulse" href="#thunderfish.eodanalysis.analyze_pulse">analyze_pulse()</a></code>.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>string</code></dt>
<dd>Unit of the waveform data.</dd>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>Index of fish.</dd>
<dt><strong><code>basename</code></strong> :&ensp;<code>string</code> or <code>stream</code></dt>
<dd>If string, path and basename of file.
If <code>basename</code> does not have an extension,
'-pulsepeaks', the fish index, and a file extension are appended.
If stream, write pulse peaks into this stream.</dd>
</dl>
<p>kwargs:
Arguments passed on to <code>TableData.write()</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>string</code></dt>
<dd>Path and full name of the written file in case of <code>basename</code>
being a string. Otherwise, the file name and extension that
would have been appended to a basename.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="thunderfish.eodanalysis.load_pulse_peaks" href="#thunderfish.eodanalysis.load_pulse_peaks">load_pulse_peaks()</a></code></p></div>
</dd>
<dt id="thunderfish.eodanalysis.load_pulse_peaks"><code class="name flex">
<span>def <span class="ident">load_pulse_peaks</span></span>(<span>file_path)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_pulse_peaks(file_path):
    &#34;&#34;&#34;Load peak properties of pulse EOD from file.

    Parameters
    ----------
    file_path: string
        Path of the file to be loaded.

    Returns
    -------
    peak_data: 2D array of floats
        Properties of peaks and troughs of pulse EOD:
        P, time, amplitude, relampl, width
    unit: string
        Unit of peak amplitudes.

    Raises
    ------
    FileNotFoundError:
        If `file_path` does not exist.

    See Also
    --------
    save_pulse_peaks()
    &#34;&#34;&#34;
    data = TableData(file_path)
    peaks = data.array()
    peaks[:,1] *= 0.001
    peaks[:,3] *= 0.01
    peaks[:,4] *= 0.001
    peaks[:,5] *= 0.001
    peaks[:,6] *= 0.01
    return peaks, data.unit(&#39;amplitude&#39;)</code></pre>
</details>
<div class="desc"><p>Load peak properties of pulse EOD from file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>string</code></dt>
<dd>Path of the file to be loaded.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>peak_data</code></strong> :&ensp;<code>2D array</code> of <code>floats</code></dt>
<dd>Properties of peaks and troughs of pulse EOD:
P, time, amplitude, relampl, width</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>string</code></dt>
<dd>Unit of peak amplitudes.</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="filenotfounderror">Filenotfounderror</h2>
<p>If <code>file_path</code> does not exist.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="thunderfish.eodanalysis.save_pulse_peaks" href="#thunderfish.eodanalysis.save_pulse_peaks">save_pulse_peaks()</a></code></p></div>
</dd>
<dt id="thunderfish.eodanalysis.save_pulse_times"><code class="name flex">
<span>def <span class="ident">save_pulse_times</span></span>(<span>pulse_times, idx, basename, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_pulse_times(pulse_times, idx, basename, **kwargs):
    &#34;&#34;&#34;Save times of pulse EOD to file.

    Parameters
    ----------
    pulse_times: dict or array of floats
        Times of EOD pulses. Either as array of times or
        `props[&#39;peaktimes&#39;]` or `props[&#39;times&#39;]` as returned by
        `analyze_pulse()`.
    idx: int or None
        Index of fish.
    basename: string or stream
        If string, path and basename of file.
        If `basename` does not have an extension,
        &#39;-pulsetimes&#39;, the fish index, and a file extension are appended.
        If stream, write pulse times into this stream.
    kwargs:
        Arguments passed on to `TableData.write()`.

    Returns
    -------
    filename: string
        Path and full name of the written file in case of `basename`
        being a string. Otherwise, the file name and extension that
        would have been appended to a basename.

    See Also
    --------
    load_pulse_times()
    &#34;&#34;&#34;
    if isinstance(pulse_times, dict):
        props = pulse_times
        pulse_times = props.get(&#39;times&#39;, [])
        pulse_times = props.get(&#39;peaktimes&#39;, pulse_times)
    if len(pulse_times) == 0:
        return None
    td = TableData()
    td.append(&#39;time&#39;, &#39;s&#39;, &#39;%.4f&#39;, pulse_times)
    _, ext = os.path.splitext(basename)
    fp = &#39;&#39;
    if not ext:
        fp = &#39;-pulsetimes&#39;
        if idx is not None:
            fp += &#39;-%d&#39; % idx
    return td.write_file_stream(basename, fp, **kwargs)</code></pre>
</details>
<div class="desc"><p>Save times of pulse EOD to file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pulse_times</code></strong> :&ensp;<code>dict</code> or <code>array</code> of <code>floats</code></dt>
<dd>Times of EOD pulses. Either as array of times or
<code>props['peaktimes']</code> or <code>props['times']</code> as returned by
<code><a title="thunderfish.eodanalysis.analyze_pulse" href="#thunderfish.eodanalysis.analyze_pulse">analyze_pulse()</a></code>.</dd>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>Index of fish.</dd>
<dt><strong><code>basename</code></strong> :&ensp;<code>string</code> or <code>stream</code></dt>
<dd>If string, path and basename of file.
If <code>basename</code> does not have an extension,
'-pulsetimes', the fish index, and a file extension are appended.
If stream, write pulse times into this stream.</dd>
</dl>
<p>kwargs:
Arguments passed on to <code>TableData.write()</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>string</code></dt>
<dd>Path and full name of the written file in case of <code>basename</code>
being a string. Otherwise, the file name and extension that
would have been appended to a basename.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code><a title="thunderfish.eodanalysis.load_pulse_times" href="#thunderfish.eodanalysis.load_pulse_times">load_pulse_times()</a></code></p></div>
</dd>
<dt id="thunderfish.eodanalysis.load_pulse_times"><code class="name flex">
<span>def <span class="ident">load_pulse_times</span></span>(<span>file_path)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_pulse_times(file_path):
    &#34;&#34;&#34;Load times of pulse EOD from file.

    Parameters
    ----------
    file_path: string
        Path of the file to be loaded.

    Returns
    -------
    pulse_times: array of floats
        Times of pulse EODs in seconds.

    Raises
    ------
    FileNotFoundError:
        If `file_path` does not exist.

    See Also
    --------
    save_pulse_times()
    &#34;&#34;&#34;
    data = TableData(file_path)
    pulse_times = data.array()[:,0]
    return pulse_times</code></pre>
</details>
<div class="desc"><p>Load times of pulse EOD from file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>string</code></dt>
<dd>Path of the file to be loaded.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pulse_times</code></strong> :&ensp;<code>array</code> of <code>floats</code></dt>
<dd>Times of pulse EODs in seconds.</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="filenotfounderror">Filenotfounderror</h2>
<p>If <code>file_path</code> does not exist.</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="thunderfish.eodanalysis.save_pulse_times" href="#thunderfish.eodanalysis.save_pulse_times">save_pulse_times()</a></code></p></div>
</dd>
<dt id="thunderfish.eodanalysis.parse_filename"><code class="name flex">
<span>def <span class="ident">parse_filename</span></span>(<span>file_path)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_filename(file_path):
    &#34;&#34;&#34;Parse components of an EOD analysis file name.

    Analysis files generated by the `eodanalysis` module are named
    according to
    ```plain
    PATH/RECORDING-CHANNEL-TIME-FTYPE-N.EXT
    ```

    Parameters
    ----------
    file_path: string
        Path of the file to be parsed.

    Returns
    -------
    recording: string
        Path and basename of the recording, i.e. &#39;PATH/RECORDING&#39;.
        A leading &#39;./&#39; is removed.
    base_path: string
        Path and basename of the analysis results,
        i.e. &#39;PATH/RECORDING-CHANNEL-TIME&#39;. A leading &#39;./&#39; is removed.
    channel: int
        Channel of the recording
        (&#39;CHANNEL&#39; component of the file name if present).
        -1 if not present in `file_path`.
    time: float
        Start time of analysis window in seconds
        (&#39;TIME&#39; component of the file name if present).
        `None` if not present in `file_path`.
    ftype: string
        Type of analysis file (e.g. &#39;wavespectrum&#39;, &#39;pulsepeaks&#39;, etc.),
        (&#39;FTYPE&#39; component of the file name if present).
        See `file_types` for a list of all supported file types.
        Empty string if not present in `file_path`.
    index: int
        Index of the EOD.
        (&#39;N&#39; component of the file name if present).
        -1 if not present in `file_path`.
    ext: string
        File extension *without* leading period
        (&#39;EXT&#39; component of the file name).

    &#34;&#34;&#34;
    name, ext = os.path.splitext(file_path)
    ext = ext[1:]
    parts = name.split(&#39;-&#39;)
    index = -1
    if len(parts) &gt; 0 and parts[-1].isdigit():
        index = int(parts[-1])
        parts = parts[:-1]
    ftype = &#39;&#39;
    if len(parts) &gt; 0:
        ftype = parts[-1]
        parts = parts[:-1]
    base_path = &#39;-&#39;.join(parts)
    if base_path.startswith(&#39;./&#39;):
        base_path = base_path[2:]
    time = None
    if len(parts) &gt; 0 and len(parts[-1]) &gt; 0 and \
       parts[-1][0] == &#39;t&#39; and parts[-1][-1] == &#39;s&#39; and \
       parts[-1][1:-1].isdigit():
        time = float(parts[-1][1:-1])
        parts = parts[:-1]
    channel = -1
    if len(parts) &gt; 0 and len(parts[-1]) &gt; 0 and \
       parts[-1][0] == &#39;c&#39; and parts[-1][1:].isdigit():
        channel = int(parts[-1][1:])
        parts = parts[:-1]
    recording = &#39;-&#39;.join(parts)
    if recording.startswith(&#39;./&#39;):
        recording = recording[2:]
    return recording, base_path, channel, time, ftype, index, ext</code></pre>
</details>
<div class="desc"><p>Parse components of an EOD analysis file name.</p>
<p>Analysis files generated by the <code>eodanalysis</code> module are named
according to</p>
<pre><code class="language-plain">PATH/RECORDING-CHANNEL-TIME-FTYPE-N.EXT
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>string</code></dt>
<dd>Path of the file to be parsed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>recording</code></strong> :&ensp;<code>string</code></dt>
<dd>Path and basename of the recording, i.e. 'PATH/RECORDING'.
A leading './' is removed.</dd>
<dt><strong><code>base_path</code></strong> :&ensp;<code>string</code></dt>
<dd>Path and basename of the analysis results,
i.e. 'PATH/RECORDING-CHANNEL-TIME'. A leading './' is removed.</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code>int</code></dt>
<dd>Channel of the recording
('CHANNEL' component of the file name if present).
-1 if not present in <code>file_path</code>.</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>float</code></dt>
<dd>Start time of analysis window in seconds
('TIME' component of the file name if present).
<code>None</code> if not present in <code>file_path</code>.</dd>
<dt><strong><code>ftype</code></strong> :&ensp;<code>string</code></dt>
<dd>Type of analysis file (e.g. 'wavespectrum', 'pulsepeaks', etc.),
('FTYPE' component of the file name if present).
See <code><a title="thunderfish.eodanalysis.file_types" href="#thunderfish.eodanalysis.file_types">file_types</a></code> for a list of all supported file types.
Empty string if not present in <code>file_path</code>.</dd>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the EOD.
('N' component of the file name if present).
-1 if not present in <code>file_path</code>.</dd>
<dt><strong><code>ext</code></strong> :&ensp;<code>string</code></dt>
<dd>File extension <em>without</em> leading period
('EXT' component of the file name).</dd>
</dl></div>
</dd>
<dt id="thunderfish.eodanalysis.save_analysis"><code class="name flex">
<span>def <span class="ident">save_analysis</span></span>(<span>output_basename,<br>zip_file,<br>eod_props,<br>mean_eods,<br>spec_data,<br>peak_data,<br>wave_eodfs,<br>wave_indices,<br>unit,<br>verbose,<br>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_analysis(output_basename, zip_file, eod_props, mean_eods,
                  spec_data, peak_data, wave_eodfs, wave_indices, unit,
                  verbose, **kwargs):
    &#34;&#34;&#34;Save EOD analysis results to files.

    Parameters
    ----------
    output_basename: string
        Path and basename of files to be saved.
    zip_file: bool
        If `True`, write all analysis results into a zip archive.
    eod_props: list of dict
        Properties of EODs as returned by `analyze_wave()` and
        `analyze_pulse()`.
    mean_eods: list of 2D array of floats
        Averaged EOD waveforms as returned by `eod_waveform()`,
        `analyze_wave()`, and `analyze_pulse()`.
    spec_data: list of 2D array of floats
        Power spectra of single pulses as returned by
        `analyze_pulse()`.
    peak_data: list of 2D array of floats
        Properties of peaks and troughs of pulse EODs as returned by
        `analyze_pulse()`.
    wave_eodfs: list of 2D array of float
        Each item is a matrix with the frequencies and powers
        (columns) of the fundamental and harmonics (rows) as returned
        by `harmonics.harmonic_groups()`.
    wave_indices: array of int
        Indices identifying each fish in `wave_eodfs` or NaN.
    unit: string
        Unit of the waveform data.
    verbose: int
        Verbosity level.
    kwargs:
        Arguments passed on to `TableData.write()`.
    &#34;&#34;&#34;
    def write_file_zip(zf, save_func, output, *args, **kwargs):
        if zf is None:
            fp = save_func(*args, basename=output, **kwargs)
            if verbose &gt; 0 and fp is not None:
                print(&#39;wrote file %s&#39; % fp)
        else:
            with io.StringIO() as df:
                fp = save_func(*args, basename=df, **kwargs)
                if fp is not None:
                    fp = output_basename + fp
                    zf.writestr(os.path.basename(fp), df.getvalue())
                    if verbose &gt; 0:
                        print(&#39;zipped file %s&#39; % fp)

    
    if &#39;table_format&#39; in kwargs and kwargs[&#39;table_format&#39;] == &#39;py&#39;:
        with open(output_basename+&#39;.py&#39;, &#39;w&#39;) as f:
            name = os.path.basename(output_basename)
            for k, sdata in enumerate(spec_data):
                # save wave fish only:
                if len(sdata)&gt;0 and sdata.shape[1] &gt; 2:
                    fish = dict(amplitudes=sdata[:,3], phases=sdata[:,5])
                    fish = normalize_wavefish(fish)
                    export_wavefish(fish, name+&#39;-%d_harmonics&#39; % k, f)
    else:
        zf = None
        if zip_file:
            zf = zipfile.ZipFile(output_basename + &#39;.zip&#39;, &#39;w&#39;)
        # all wave fish in wave_eodfs:
        if len(wave_eodfs) &gt; 0:
            write_file_zip(zf, save_wave_eodfs, output_basename,
                           wave_eodfs, wave_indices, **kwargs)
        # all wave and pulse fish:
        for i, (mean_eod, sdata, pdata, props) in enumerate(zip(mean_eods, spec_data, peak_data, eod_props)):
            write_file_zip(zf, save_eod_waveform, output_basename,
                           mean_eod, unit, i, **kwargs)
            # power spectrum:
            if len(sdata)&gt;0:
                if sdata.shape[1] == 2:
                    write_file_zip(zf, save_pulse_spectrum, output_basename,
                                   sdata, unit, i, **kwargs)
                else:
                    write_file_zip(zf, save_wave_spectrum, output_basename,
                                   sdata, unit, i, **kwargs)
            # peaks:
            write_file_zip(zf, save_pulse_peaks, output_basename,
                           pdata, unit, i, **kwargs)
            # times:
            write_file_zip(zf, save_pulse_times, output_basename,
                           props, i, **kwargs)
        # wave fish properties:
        write_file_zip(zf, save_wave_fish, output_basename,
                       eod_props, unit, **kwargs)
        # pulse fish properties:
        write_file_zip(zf, save_pulse_fish, output_basename,
                       eod_props, unit, **kwargs)</code></pre>
</details>
<div class="desc"><p>Save EOD analysis results to files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>output_basename</code></strong> :&ensp;<code>string</code></dt>
<dd>Path and basename of files to be saved.</dd>
<dt><strong><code>zip_file</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, write all analysis results into a zip archive.</dd>
<dt><strong><code>eod_props</code></strong> :&ensp;<code>list</code> of <code>dict</code></dt>
<dd>Properties of EODs as returned by <code><a title="thunderfish.eodanalysis.analyze_wave" href="#thunderfish.eodanalysis.analyze_wave">analyze_wave()</a></code> and
<code><a title="thunderfish.eodanalysis.analyze_pulse" href="#thunderfish.eodanalysis.analyze_pulse">analyze_pulse()</a></code>.</dd>
<dt><strong><code>mean_eods</code></strong> :&ensp;<code>list</code> of <code>2D array</code> of <code>floats</code></dt>
<dd>Averaged EOD waveforms as returned by <code><a title="thunderfish.eodanalysis.eod_waveform" href="#thunderfish.eodanalysis.eod_waveform">eod_waveform()</a></code>,
<code><a title="thunderfish.eodanalysis.analyze_wave" href="#thunderfish.eodanalysis.analyze_wave">analyze_wave()</a></code>, and <code><a title="thunderfish.eodanalysis.analyze_pulse" href="#thunderfish.eodanalysis.analyze_pulse">analyze_pulse()</a></code>.</dd>
<dt><strong><code>spec_data</code></strong> :&ensp;<code>list</code> of <code>2D array</code> of <code>floats</code></dt>
<dd>Power spectra of single pulses as returned by
<code><a title="thunderfish.eodanalysis.analyze_pulse" href="#thunderfish.eodanalysis.analyze_pulse">analyze_pulse()</a></code>.</dd>
<dt><strong><code>peak_data</code></strong> :&ensp;<code>list</code> of <code>2D array</code> of <code>floats</code></dt>
<dd>Properties of peaks and troughs of pulse EODs as returned by
<code><a title="thunderfish.eodanalysis.analyze_pulse" href="#thunderfish.eodanalysis.analyze_pulse">analyze_pulse()</a></code>.</dd>
<dt><strong><code>wave_eodfs</code></strong> :&ensp;<code>list</code> of <code>2D array</code> of <code>float</code></dt>
<dd>Each item is a matrix with the frequencies and powers
(columns) of the fundamental and harmonics (rows) as returned
by <code>harmonics.harmonic_groups()</code>.</dd>
<dt><strong><code>wave_indices</code></strong> :&ensp;<code>array</code> of <code>int</code></dt>
<dd>Indices identifying each fish in <code>wave_eodfs</code> or NaN.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>string</code></dt>
<dd>Unit of the waveform data.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>int</code></dt>
<dd>Verbosity level.</dd>
</dl>
<p>kwargs:
Arguments passed on to <code>TableData.write()</code>.</p></div>
</dd>
<dt id="thunderfish.eodanalysis.load_analysis"><code class="name flex">
<span>def <span class="ident">load_analysis</span></span>(<span>file_pathes)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_analysis(file_pathes):
    &#34;&#34;&#34;Load all EOD analysis files.

    Parameters
    ----------
    file_pathes: list of string
        Pathes of the analysis files of a single recording to be loaded.

    Returns
    -------
    mean_eods: list of 2D array of floats
        Averaged EOD waveforms: time in seconds, mean, standard deviation, fit.
    wave_eodfs: 2D array of floats
        EODfs and power of wave type fish.
    wave_indices: array of ints
        Corresponding indices of fish, can contain negative numbers to
        indicate frequencies without fish.
    eod_props: list of dict
        Properties of EODs. The &#39;index&#39; property is an index into the
        reurned lists.
    spec_data: list of 2D array of floats
        Amplitude and phase spectrum of wave-type EODs with columns
        harmonics, frequency, amplitude, relative amplitude in dB,
        relative power in dB, phase, data power in unit squared.
        Power spectrum of single pulse-type EODs with columns frequency, power
    peak_data: list of 2D array of floats
        Properties of peaks and troughs of pulse-type EODs with columns
        P, time, amplitude, relampl, width
    recording: string
        Path and base name of the recording file.
    channel: int
        Analysed channel of the recording.
    unit: string
        Unit of EOD waveform.
    &#34;&#34;&#34;
    recording = None
    channel = -1
    eod_props = []
    zf = None
    if len(file_pathes) == 1 and os.path.splitext(file_pathes[0])[1][1:] == &#39;zip&#39;:
        zf = zipfile.ZipFile(file_pathes[0])
        file_pathes = sorted(zf.namelist())
    # first, read wave- and pulse-fish summaries:
    pulse_fish = False
    wave_fish = False
    for f in file_pathes:
        recording, _, channel, _, ftype, _, _ = parse_filename(f)
        if zf is not None:
            f = io.TextIOWrapper(zf.open(f, &#39;r&#39;))
        if ftype == &#39;wavefish&#39;:
            eod_props.extend(load_wave_fish(f))
            wave_fish = True
        elif ftype == &#39;pulsefish&#39;:
            eod_props.extend(load_pulse_fish(f))
            pulse_fish = True
    idx_offs = 0
    if wave_fish and not pulse_fish:
        idx_offs = sorted([ep[&#39;index&#39;] for ep in eod_props])[0]
    # then load all other files:
    neods = len(eod_props)
    if neods &lt; 1:
        neods = 1
        eod_props = [None]
    wave_eodfs = np.array([])
    wave_indices = np.array([])
    mean_eods = [None]*neods
    spec_data = [None]*neods
    peak_data = [None]*neods
    unit = None
    for f in file_pathes:
        recording, _, channel, _, ftype, idx, _ = parse_filename(f)
        if neods == 1 and idx &gt; 0:
            idx = 0
        idx -= idx_offs
        if zf is not None:
            f = io.TextIOWrapper(zf.open(f, &#39;r&#39;))
        if ftype == &#39;waveeodfs&#39;:
            wave_eodfs, wave_indices = load_wave_eodfs(f)
        elif ftype == &#39;eodwaveform&#39;:
            mean_eods[idx], unit = load_eod_waveform(f)
        elif ftype == &#39;wavespectrum&#39;:
            spec_data[idx], unit = load_wave_spectrum(f)
        elif ftype == &#39;pulsepeaks&#39;:
            peak_data[idx], unit = load_pulse_peaks(f)
        elif ftype == &#39;pulsetimes&#39;:
            pulse_times = load_pulse_times(f)
            eod_props[idx][&#39;times&#39;] = pulse_times
            eod_props[idx][&#39;peaktimes&#39;] = pulse_times
        elif ftype == &#39;pulsespectrum&#39;:
            spec_data[idx] = load_pulse_spectrum(f)
    # fix wave spectra:
    wave_eodfs = [fish.reshape(1, 2) if len(fish)&gt;0 else fish
                  for fish in wave_eodfs]
    if len(wave_eodfs) &gt; 0 and len(spec_data) &gt; 0:
        eodfs = []
        for idx, fish in zip(wave_indices, wave_eodfs):
            if idx &gt;= 0:
                spec = spec_data[idx]
                specd = np.zeros((np.sum(np.isfinite(spec[:,-1])),
                                  2))
                specd[:,0] = spec[np.isfinite(spec[:,-1]),1]
                specd[:,1] = spec[np.isfinite(spec[:,-1]),-1]
                eodfs.append(specd)
            else:
                specd = np.zeros((10, 2))
                specd[:,0] = np.arange(len(specd))*fish[0,0]
                specd[:,1] = np.nan
                eodfs.append(specd)
        wave_eodfs = eodfs
    return mean_eods, wave_eodfs, wave_indices, eod_props, spec_data, \
        peak_data, recording, channel, unit</code></pre>
</details>
<div class="desc"><p>Load all EOD analysis files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_pathes</code></strong> :&ensp;<code>list</code> of <code>string</code></dt>
<dd>Pathes of the analysis files of a single recording to be loaded.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mean_eods</code></strong> :&ensp;<code>list</code> of <code>2D array</code> of <code>floats</code></dt>
<dd>Averaged EOD waveforms: time in seconds, mean, standard deviation, fit.</dd>
<dt><strong><code>wave_eodfs</code></strong> :&ensp;<code>2D array</code> of <code>floats</code></dt>
<dd>EODfs and power of wave type fish.</dd>
<dt><strong><code>wave_indices</code></strong> :&ensp;<code>array</code> of <code>ints</code></dt>
<dd>Corresponding indices of fish, can contain negative numbers to
indicate frequencies without fish.</dd>
<dt><strong><code>eod_props</code></strong> :&ensp;<code>list</code> of <code>dict</code></dt>
<dd>Properties of EODs. The 'index' property is an index into the
reurned lists.</dd>
<dt><strong><code>spec_data</code></strong> :&ensp;<code>list</code> of <code>2D array</code> of <code>floats</code></dt>
<dd>Amplitude and phase spectrum of wave-type EODs with columns
harmonics, frequency, amplitude, relative amplitude in dB,
relative power in dB, phase, data power in unit squared.
Power spectrum of single pulse-type EODs with columns frequency, power</dd>
<dt><strong><code>peak_data</code></strong> :&ensp;<code>list</code> of <code>2D array</code> of <code>floats</code></dt>
<dd>Properties of peaks and troughs of pulse-type EODs with columns
P, time, amplitude, relampl, width</dd>
<dt><strong><code>recording</code></strong> :&ensp;<code>string</code></dt>
<dd>Path and base name of the recording file.</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code>int</code></dt>
<dd>Analysed channel of the recording.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>string</code></dt>
<dd>Unit of EOD waveform.</dd>
</dl></div>
</dd>
<dt id="thunderfish.eodanalysis.load_recording"><code class="name flex">
<span>def <span class="ident">load_recording</span></span>(<span>file_path, channel=0, load_kwargs={}, eod_props=None, verbose=0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_recording(file_path, channel=0, load_kwargs={},
                   eod_props=None, verbose=0):
    &#34;&#34;&#34;Load recording.

    Parameters
    ----------
    file_path: string
        Full path of the file with the recorded data.
        Extension is optional. If absent, look for the first file
        with a reasonable extension.
    channel: int
        Channel of the recording to be returned.
    load_kwargs: dict
        Keyword arguments that are passed on to the 
        format specific loading functions.
    eod_props: list of dict or None
        List of EOD properties from which start and end times of
        analysis window are extracted.
    verbose: int
        Verbosity level passed on to load function.

    Returns
    -------
    data: array of float
        Data of the requested `channel`.
    rate: float
        Sampling rate in Hertz.
    idx0: int
        Start index of the analysis window.
    idx1: int
        End index of the analysis window.
    data_file: str
        Full path and name of the loaded file inclusively extension.

    &#34;&#34;&#34;
    data = None
    rate = 0.0
    idx0 = 0
    idx1 = 0
    data_file = &#39;&#39;
    if len(os.path.splitext(file_path)[1]) &gt; 1:
        data_file = file_path
    else:
        data_files = glob.glob(file_path + os.extsep + &#39;*&#39;)
        for dfile in data_files:
            if not os.path.splitext(dfile)[1][1:] in [&#39;zip&#39;] + list(TableData.ext_formats.values()):
                data_file = dfile
                break
    if os.path.exists(data_file):
        data, rate, unit, amax = load_data(data_file, verbose=verbose,
                                           **load_kwargs)
        idx0 = 0
        idx1 = len(data)
        if eod_props is not None and len(eod_props) &gt; 0 and &#39;twin&#39; in eod_props[0]:
            idx0 = int(eod_props[0][&#39;twin&#39;]*rate)
        if len(eod_props) &gt; 0 and &#39;window&#39; in eod_props[0]:
            idx1 = idx0 + int(eod_props[0][&#39;window&#39;]*rate)
    return data[:,channel], rate, idx0, idx1, data_file</code></pre>
</details>
<div class="desc"><p>Load recording.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>string</code></dt>
<dd>Full path of the file with the recorded data.
Extension is optional. If absent, look for the first file
with a reasonable extension.</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code>int</code></dt>
<dd>Channel of the recording to be returned.</dd>
<dt><strong><code>load_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments that are passed on to the
format specific loading functions.</dd>
<dt><strong><code>eod_props</code></strong> :&ensp;<code>list</code> of <code>dict</code> or <code>None</code></dt>
<dd>List of EOD properties from which start and end times of
analysis window are extracted.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>int</code></dt>
<dd>Verbosity level passed on to load function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>array</code> of <code>float</code></dt>
<dd>Data of the requested <code>channel</code>.</dd>
<dt><strong><code>rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Sampling rate in Hertz.</dd>
<dt><strong><code>idx0</code></strong> :&ensp;<code>int</code></dt>
<dd>Start index of the analysis window.</dd>
<dt><strong><code>idx1</code></strong> :&ensp;<code>int</code></dt>
<dd>End index of the analysis window.</dd>
<dt><strong><code>data_file</code></strong> :&ensp;<code>str</code></dt>
<dd>Full path and name of the loaded file inclusively extension.</dd>
</dl></div>
</dd>
<dt id="thunderfish.eodanalysis.add_eod_analysis_config"><code class="name flex">
<span>def <span class="ident">add_eod_analysis_config</span></span>(<span>cfg,<br>thresh_fac=0.8,<br>percentile=0.1,<br>win_fac=2.0,<br>min_win=0.01,<br>max_eods=None,<br>min_sem=False,<br>unfilter_cutoff=0.0,<br>flip_wave='none',<br>flip_pulse='none',<br>n_harm=10,<br>min_pulse_win=0.001,<br>peak_thresh_fac=0.01,<br>min_dist=5e-05,<br>width_frac=0.5,<br>fit_frac=0.5,<br>ipi_cv_thresh=0.5,<br>ipi_percentile=30.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_eod_analysis_config(cfg, thresh_fac=0.8, percentile=0.1,
                            win_fac=2.0, min_win=0.01, max_eods=None,
                            min_sem=False, unfilter_cutoff=0.0,
                            flip_wave=&#39;none&#39;, flip_pulse=&#39;none&#39;,
                            n_harm=10, min_pulse_win=0.001,
                            peak_thresh_fac=0.01, min_dist=50.0e-6,
                            width_frac = 0.5, fit_frac = 0.5,
                            ipi_cv_thresh=0.5, ipi_percentile=30.0):
    &#34;&#34;&#34;Add all parameters needed for the eod analysis functions as a new
    section to a configuration.

    Parameters
    ----------
    cfg: ConfigFile
        The configuration.
        
    See `eod_waveform()`, `analyze_wave()`, and `analyze_pulse()` for
    details on the remaining arguments.
    &#34;&#34;&#34;
    cfg.add_section(&#39;EOD analysis:&#39;)
    cfg.add(&#39;eodSnippetFac&#39;, win_fac, &#39;&#39;, &#39;The duration of EOD snippets is the EOD period times this factor.&#39;)
    cfg.add(&#39;eodMinSnippet&#39;, min_win, &#39;s&#39;, &#39;Minimum duration of cut out EOD snippets.&#39;)
    cfg.add(&#39;eodMaxEODs&#39;, max_eods or 0, &#39;&#39;, &#39;The maximum number of EODs used to compute the average EOD. If 0 use all EODs.&#39;)
    cfg.add(&#39;eodMinSem&#39;, min_sem, &#39;&#39;, &#39;Use minimum of s.e.m. to set maximum number of EODs used to compute the average EOD.&#39;)
    cfg.add(&#39;unfilterCutoff&#39;, unfilter_cutoff, &#39;Hz&#39;, &#39;If non-zero remove effect of high-pass filter with this cut-off frequency.&#39;)
    cfg.add(&#39;flipWaveEOD&#39;, flip_wave, &#39;&#39;, &#39;Flip EOD of wave fish to make largest extremum positive (flip, none, or auto).&#39;)
    cfg.add(&#39;flipPulseEOD&#39;, flip_pulse, &#39;&#39;, &#39;Flip EOD of pulse fish to make the first large peak positive (flip, none, or auto).&#39;)
    cfg.add(&#39;eodHarmonics&#39;, n_harm, &#39;&#39;, &#39;Number of harmonics fitted to the EOD waveform.&#39;)
    cfg.add(&#39;eodMinPulseSnippet&#39;, min_pulse_win, &#39;s&#39;, &#39;Minimum duration of cut out EOD snippets for a pulse fish.&#39;)
    cfg.add(&#39;eodPeakThresholdFactor&#39;, peak_thresh_fac, &#39;&#39;, &#39;Threshold for detection of peaks in pulse EODs as a fraction of the pulse amplitude.&#39;)
    cfg.add(&#39;eodMinimumDistance&#39;, min_dist, &#39;s&#39;, &#39;Minimum distance between peaks and troughs in a EOD pulse.&#39;)
    cfg.add(&#39;eodPulseWidthFraction&#39;, width_frac, &#39;&#39;, &#39;The width of a pulse is measured at this fraction of the pulse height.&#39;)
    cfg.add(&#39;eodExponentialFitFraction&#39;, fit_frac, &#39;&#39;, &#39;An exponential function is fitted on the tail of a pulse starting at this fraction of the height of the last peak.&#39;)
    cfg.add(&#39;ipiCVThresh&#39;, ipi_cv_thresh, &#39;&#39;, &#39;If coefficient of variation of interpulse intervals is smaller than this threshold, then use all intervals for computing EOD frequency.&#39;)
    cfg.add(&#39;ipiPercentile&#39;, ipi_percentile, &#39;%&#39;, &#39;Use only interpulse intervals shorter than this percentile to compute EOD frequency.&#39;)</code></pre>
</details>
<div class="desc"><p>Add all parameters needed for the eod analysis functions as a new
section to a configuration.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cfg</code></strong> :&ensp;<code>ConfigFile</code></dt>
<dd>The configuration.</dd>
</dl>
<p>See <code><a title="thunderfish.eodanalysis.eod_waveform" href="#thunderfish.eodanalysis.eod_waveform">eod_waveform()</a></code>, <code><a title="thunderfish.eodanalysis.analyze_wave" href="#thunderfish.eodanalysis.analyze_wave">analyze_wave()</a></code>, and <code><a title="thunderfish.eodanalysis.analyze_pulse" href="#thunderfish.eodanalysis.analyze_pulse">analyze_pulse()</a></code> for
details on the remaining arguments.</p></div>
</dd>
<dt id="thunderfish.eodanalysis.eod_waveform_args"><code class="name flex">
<span>def <span class="ident">eod_waveform_args</span></span>(<span>cfg)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eod_waveform_args(cfg):
    &#34;&#34;&#34;Translates a configuration to the respective parameter names of
    the function `eod_waveform()`.
    
    The return value can then be passed as key-word arguments to this
    function.

    Parameters
    ----------
    cfg: ConfigFile
        The configuration.

    Returns
    -------
    a: dict
        Dictionary with names of arguments of the `eod_waveform()` function
        and their values as supplied by `cfg`.
    &#34;&#34;&#34;
    a = cfg.map({&#39;win_fac&#39;: &#39;eodSnippetFac&#39;,
                 &#39;min_win&#39;: &#39;eodMinSnippet&#39;,
                 &#39;max_eods&#39;: &#39;eodMaxEODs&#39;,
                 &#39;min_sem&#39;: &#39;eodMinSem&#39;, 
                 &#39;unfilter_cutoff&#39;: &#39;unfilterCutoff&#39;})
    return a</code></pre>
</details>
<div class="desc"><p>Translates a configuration to the respective parameter names of
the function <code><a title="thunderfish.eodanalysis.eod_waveform" href="#thunderfish.eodanalysis.eod_waveform">eod_waveform()</a></code>.</p>
<p>The return value can then be passed as key-word arguments to this
function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cfg</code></strong> :&ensp;<code>ConfigFile</code></dt>
<dd>The configuration.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>a</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with names of arguments of the <code><a title="thunderfish.eodanalysis.eod_waveform" href="#thunderfish.eodanalysis.eod_waveform">eod_waveform()</a></code> function
and their values as supplied by <code>cfg</code>.</dd>
</dl></div>
</dd>
<dt id="thunderfish.eodanalysis.analyze_wave_args"><code class="name flex">
<span>def <span class="ident">analyze_wave_args</span></span>(<span>cfg)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def analyze_wave_args(cfg):
    &#34;&#34;&#34;Translates a configuration to the respective parameter names of
    the function `analyze_wave()`.
    
    The return value can then be passed as key-word arguments to this
    function.

    Parameters
    ----------
    cfg: ConfigFile
        The configuration.

    Returns
    -------
    a: dict
        Dictionary with names of arguments of the `analyze_wave()` function
        and their values as supplied by `cfg`.
    &#34;&#34;&#34;
    a = cfg.map({&#39;n_harm&#39;: &#39;eodHarmonics&#39;,
                 &#39;power_n_harmonics&#39;: &#39;powerNHarmonics&#39;,
                 &#39;flip_wave&#39;: &#39;flipWaveEOD&#39;})
    return a</code></pre>
</details>
<div class="desc"><p>Translates a configuration to the respective parameter names of
the function <code><a title="thunderfish.eodanalysis.analyze_wave" href="#thunderfish.eodanalysis.analyze_wave">analyze_wave()</a></code>.</p>
<p>The return value can then be passed as key-word arguments to this
function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cfg</code></strong> :&ensp;<code>ConfigFile</code></dt>
<dd>The configuration.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>a</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with names of arguments of the <code><a title="thunderfish.eodanalysis.analyze_wave" href="#thunderfish.eodanalysis.analyze_wave">analyze_wave()</a></code> function
and their values as supplied by <code>cfg</code>.</dd>
</dl></div>
</dd>
<dt id="thunderfish.eodanalysis.analyze_pulse_args"><code class="name flex">
<span>def <span class="ident">analyze_pulse_args</span></span>(<span>cfg)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def analyze_pulse_args(cfg):
    &#34;&#34;&#34;Translates a configuration to the respective parameter names of
    the function `analyze_pulse()`.
    
    The return value can then be passed as key-word arguments to this
    function.

    Parameters
    ----------
    cfg: ConfigFile
        The configuration.

    Returns
    -------
    a: dict
        Dictionary with names of arguments of the `analyze_pulse()` function
        and their values as supplied by `cfg`.
    &#34;&#34;&#34;
    a = cfg.map({&#39;min_pulse_win&#39;: &#39;eodMinPulseSnippet&#39;,
                 &#39;peak_thresh_fac&#39;: &#39;eodPeakThresholdFactor&#39;,
                 &#39;min_dist&#39;: &#39;eodMinimumDistance&#39;,
                 &#39;width_frac&#39;: &#39;eodPulseWidthFraction&#39;,
                 &#39;fit_frac&#39;: &#39;eodExponentialFitFraction&#39;,
                 &#39;flip_pulse&#39;: &#39;flipPulseEOD&#39;,
                 &#39;ipi_cv_thresh&#39;: &#39;ipiCVThresh&#39;,
                 &#39;ipi_percentile&#39;: &#39;ipiPercentile&#39;})
    return a</code></pre>
</details>
<div class="desc"><p>Translates a configuration to the respective parameter names of
the function <code><a title="thunderfish.eodanalysis.analyze_pulse" href="#thunderfish.eodanalysis.analyze_pulse">analyze_pulse()</a></code>.</p>
<p>The return value can then be passed as key-word arguments to this
function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cfg</code></strong> :&ensp;<code>ConfigFile</code></dt>
<dd>The configuration.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>a</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with names of arguments of the <code><a title="thunderfish.eodanalysis.analyze_pulse" href="#thunderfish.eodanalysis.analyze_pulse">analyze_pulse()</a></code> function
and their values as supplied by <code>cfg</code>.</dd>
</dl></div>
</dd>
<dt id="thunderfish.eodanalysis.add_species_config"><code class="name flex">
<span>def <span class="ident">add_species_config</span></span>(<span>cfg, species_file='none', wave_max_rms=0.2, pulse_max_rms=0.2)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_species_config(cfg, species_file=&#39;none&#39;, wave_max_rms=0.2,
                       pulse_max_rms=0.2):
    &#34;&#34;&#34;Add parameters needed for assigning EOD waveforms to species.

    Parameters
    ----------
    cfg: ConfigFile
        The configuration.
    species_file: string
        File path to a file containing species names and corresponding
        file names of EOD waveform templates. If &#39;none&#39;, no species
        assignemnt is performed.
    wave_max_rms: float
        Maximum allowed rms difference (relative to standard deviation
        of EOD waveform) to an EOD waveform template for assignment to
        a wave fish species.
    pulse_max_rms: float
        Maximum allowed rms difference (relative to standard deviation
        of EOD waveform) to an EOD waveform template for assignment to
        a pulse fish species.
    &#34;&#34;&#34;
    cfg.add_section(&#39;Species assignment:&#39;)
    cfg.add(&#39;speciesFile&#39;, species_file, &#39;&#39;, &#39;File path to a file containing species names and corresponding file names of EOD waveform templates.&#39;)
    cfg.add(&#39;maximumWaveSpeciesRMS&#39;, wave_max_rms, &#39;&#39;, &#39;Maximum allowed rms difference (relative to standard deviation of EOD waveform) to an EOD waveform template for assignment to a wave fish species.&#39;)
    cfg.add(&#39;maximumPulseSpeciesRMS&#39;, pulse_max_rms, &#39;&#39;, &#39;Maximum allowed rms difference (relative to standard deviation of EOD waveform) to an EOD waveform template for assignment to a pulse fish species.&#39;)</code></pre>
</details>
<div class="desc"><p>Add parameters needed for assigning EOD waveforms to species.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cfg</code></strong> :&ensp;<code>ConfigFile</code></dt>
<dd>The configuration.</dd>
<dt><strong><code>species_file</code></strong> :&ensp;<code>string</code></dt>
<dd>File path to a file containing species names and corresponding
file names of EOD waveform templates. If 'none', no species
assignemnt is performed.</dd>
<dt><strong><code>wave_max_rms</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum allowed rms difference (relative to standard deviation
of EOD waveform) to an EOD waveform template for assignment to
a wave fish species.</dd>
<dt><strong><code>pulse_max_rms</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum allowed rms difference (relative to standard deviation
of EOD waveform) to an EOD waveform template for assignment to
a pulse fish species.</dd>
</dl></div>
</dd>
<dt id="thunderfish.eodanalysis.add_eod_quality_config"><code class="name flex">
<span>def <span class="ident">add_eod_quality_config</span></span>(<span>cfg,<br>max_clipped_frac=0.1,<br>max_variance=0.0,<br>max_rms_error=0.05,<br>min_power=-100.0,<br>max_thd=0.0,<br>max_crossings=4,<br>max_relampl_harm1=0.0,<br>max_relampl_harm2=0.0,<br>max_relampl_harm3=0.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_eod_quality_config(cfg, max_clipped_frac=0.1, max_variance=0.0,
                           max_rms_error=0.05, min_power=-100.0, max_thd=0.0,
                           max_crossings=4, max_relampl_harm1=0.0,
                           max_relampl_harm2=0.0, max_relampl_harm3=0.0):
    &#34;&#34;&#34;Add parameters needed for assesing the quality of an EOD waveform.

    Parameters
    ----------
    cfg: ConfigFile
        The configuration.
        
    See `wave_quality()` and `pulse_quality()` for details on
    the remaining arguments.
    &#34;&#34;&#34;
    cfg.add_section(&#39;Waveform selection:&#39;)
    cfg.add(&#39;maximumClippedFraction&#39;, max_clipped_frac, &#39;&#39;, &#39;Take waveform of the fish with the highest power only if the fraction of clipped signals is below this value.&#39;)
    cfg.add(&#39;maximumVariance&#39;, max_variance, &#39;&#39;, &#39;Skip waveform of fish if the standard error of the EOD waveform relative to the peak-to-peak amplitude is larger than this number. A value of zero allows any variance.&#39;)
    cfg.add(&#39;maximumRMSError&#39;, max_rms_error, &#39;&#39;, &#39;Skip waveform of wave fish if the root-mean-squared error of the fit relative to the peak-to-peak amplitude is larger than this number.&#39;)
    cfg.add(&#39;minimumPower&#39;, min_power, &#39;dB&#39;, &#39;Skip waveform of wave fish if its power is smaller than this value.&#39;)
    cfg.add(&#39;maximumTotalHarmonicDistortion&#39;, max_thd, &#39;&#39;, &#39;Skip waveform of wave fish if its total harmonic distortion is larger than this value. If set to zero do not check.&#39;)
    cfg.add(&#39;maximumCrossings&#39;, max_crossings, &#39;&#39;, &#39;Maximum number of zero crossings per EOD period.&#39;)
    cfg.add(&#39;maximumFirstHarmonicAmplitude&#39;, max_relampl_harm1, &#39;&#39;, &#39;Skip waveform of wave fish if the amplitude of the first harmonic is higher than this factor times the amplitude of the fundamental. If set to zero do not check.&#39;)
    cfg.add(&#39;maximumSecondHarmonicAmplitude&#39;, max_relampl_harm2, &#39;&#39;, &#39;Skip waveform of wave fish if the ampltude of the second harmonic is higher than this factor times the amplitude of the fundamental. That is, the waveform appears to have twice the frequency than the fundamental. If set to zero do not check.&#39;)
    cfg.add(&#39;maximumThirdHarmonicAmplitude&#39;, max_relampl_harm3, &#39;&#39;, &#39;Skip waveform of wave fish if the ampltude of the third harmonic is higher than this factor times the amplitude of the fundamental. If set to zero do not check.&#39;)</code></pre>
</details>
<div class="desc"><p>Add parameters needed for assesing the quality of an EOD waveform.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cfg</code></strong> :&ensp;<code>ConfigFile</code></dt>
<dd>The configuration.</dd>
</dl>
<p>See <code><a title="thunderfish.eodanalysis.wave_quality" href="#thunderfish.eodanalysis.wave_quality">wave_quality()</a></code> and <code><a title="thunderfish.eodanalysis.pulse_quality" href="#thunderfish.eodanalysis.pulse_quality">pulse_quality()</a></code> for details on
the remaining arguments.</p></div>
</dd>
<dt id="thunderfish.eodanalysis.wave_quality_args"><code class="name flex">
<span>def <span class="ident">wave_quality_args</span></span>(<span>cfg)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wave_quality_args(cfg):
    &#34;&#34;&#34;Translates a configuration to the respective parameter names of
    the function `wave_quality()`.
    
    The return value can then be passed as key-word arguments to this
    function.

    Parameters
    ----------
    cfg: ConfigFile
        The configuration.

    Returns
    -------
    a: dict
        Dictionary with names of arguments of the `wave_quality()` function
        and their values as supplied by `cfg`.
    &#34;&#34;&#34;
    a = cfg.map({&#39;max_clipped_frac&#39;: &#39;maximumClippedFraction&#39;,
                 &#39;max_rms_sem&#39;: &#39;maximumVariance&#39;,
                 &#39;max_rms_error&#39;: &#39;maximumRMSError&#39;,
                 &#39;min_power&#39;: &#39;minimumPower&#39;,
                 &#39;max_crossings&#39;: &#39;maximumCrossings&#39;,
                 &#39;min_freq&#39;: &#39;minimumFrequency&#39;,
                 &#39;max_freq&#39;: &#39;maximumFrequency&#39;,
                 &#39;max_thd&#39;: &#39;maximumTotalHarmonicDistortion&#39;,
                 &#39;max_db_diff&#39;: &#39;maximumPowerDifference&#39;,
                 &#39;max_harmonics_db&#39;: &#39;maximumHarmonicsPower&#39;,
                 &#39;max_relampl_harm1&#39;: &#39;maximumFirstHarmonicAmplitude&#39;,
                 &#39;max_relampl_harm2&#39;: &#39;maximumSecondHarmonicAmplitude&#39;,
                 &#39;max_relampl_harm3&#39;: &#39;maximumThirdHarmonicAmplitude&#39;})
    return a</code></pre>
</details>
<div class="desc"><p>Translates a configuration to the respective parameter names of
the function <code><a title="thunderfish.eodanalysis.wave_quality" href="#thunderfish.eodanalysis.wave_quality">wave_quality()</a></code>.</p>
<p>The return value can then be passed as key-word arguments to this
function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cfg</code></strong> :&ensp;<code>ConfigFile</code></dt>
<dd>The configuration.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>a</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with names of arguments of the <code><a title="thunderfish.eodanalysis.wave_quality" href="#thunderfish.eodanalysis.wave_quality">wave_quality()</a></code> function
and their values as supplied by <code>cfg</code>.</dd>
</dl></div>
</dd>
<dt id="thunderfish.eodanalysis.pulse_quality_args"><code class="name flex">
<span>def <span class="ident">pulse_quality_args</span></span>(<span>cfg)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pulse_quality_args(cfg):
    &#34;&#34;&#34;Translates a configuration to the respective parameter names of
    the function `pulse_quality()`.
    
    The return value can then be passed as key-word arguments to this
    function.

    Parameters
    ----------
    cfg: ConfigFile
        The configuration.

    Returns
    -------
    a: dict
        Dictionary with names of arguments of the `pulse_quality()` function
        and their values as supplied by `cfg`.
    &#34;&#34;&#34;
    a = cfg.map({&#39;max_clipped_frac&#39;: &#39;maximumClippedFraction&#39;,
                 &#39;max_rms_sem&#39;: &#39;maximumRMSNoise&#39;})
    return a</code></pre>
</details>
<div class="desc"><p>Translates a configuration to the respective parameter names of
the function <code><a title="thunderfish.eodanalysis.pulse_quality" href="#thunderfish.eodanalysis.pulse_quality">pulse_quality()</a></code>.</p>
<p>The return value can then be passed as key-word arguments to this
function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cfg</code></strong> :&ensp;<code>ConfigFile</code></dt>
<dd>The configuration.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>a</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary with names of arguments of the <code><a title="thunderfish.eodanalysis.pulse_quality" href="#thunderfish.eodanalysis.pulse_quality">pulse_quality()</a></code> function
and their values as supplied by <code>cfg</code>.</dd>
</dl></div>
</dd>
<dt id="thunderfish.eodanalysis.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    import matplotlib.pyplot as plt
    from .fakefish import pulsefish_eods

    print(&#39;Analysis of EOD waveforms.&#39;)

    # data:
    rate = 44100.0
    data = pulsefish_eods(&#39;Triphasic&#39;, 83.0, rate, 5.0, noise_std=0.02)
    unit = &#39;mV&#39;
    eod_idx, _ = detect_peaks(data, 1.0)
    eod_times = eod_idx/rate

    # analyse EOD:
    mean_eod, eod_times = eod_waveform(data, rate, eod_times)
    mean_eod, props, peaks, power = analyze_pulse(mean_eod, eod_times)

    # plot:
    fig, axs = plt.subplots(1, 2)
    plot_eod_waveform(axs[0], mean_eod, props, peaks, unit=unit)
    axs[0].set_title(f&#39;{props[&#34;type&#34;]} fish: EODf = {props[&#34;EODf&#34;]:.1f} Hz&#39;)
    plot_pulse_spectrum(axs[1], power, props)
    plt.show()</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul>
<li><a href="#eod-waveform-analysis">EOD waveform analysis</a></li>
<li><a href="#similarity-of-eod-waveforms">Similarity of EOD waveforms</a></li>
<li><a href="#quality-assessment">Quality assessment</a></li>
<li><a href="#visualization">Visualization</a></li>
<li><a href="#storage">Storage</a></li>
<li><a href="#fit-functions">Fit functions</a></li>
<li><a href="#filter-functions">Filter functions</a></li>
<li><a href="#configuration">Configuration</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="thunderfish" href="index.html">thunderfish</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="thunderfish.eodanalysis.file_types" href="#thunderfish.eodanalysis.file_types">file_types</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="thunderfish.eodanalysis.eod_waveform" href="#thunderfish.eodanalysis.eod_waveform">eod_waveform</a></code></li>
<li><code><a title="thunderfish.eodanalysis.waveeod_waveform" href="#thunderfish.eodanalysis.waveeod_waveform">waveeod_waveform</a></code></li>
<li><code><a title="thunderfish.eodanalysis.unfilter" href="#thunderfish.eodanalysis.unfilter">unfilter</a></code></li>
<li><code><a title="thunderfish.eodanalysis.fourier_series" href="#thunderfish.eodanalysis.fourier_series">fourier_series</a></code></li>
<li><code><a title="thunderfish.eodanalysis.analyze_wave" href="#thunderfish.eodanalysis.analyze_wave">analyze_wave</a></code></li>
<li><code><a title="thunderfish.eodanalysis.exp_decay" href="#thunderfish.eodanalysis.exp_decay">exp_decay</a></code></li>
<li><code><a title="thunderfish.eodanalysis.analyze_pulse" href="#thunderfish.eodanalysis.analyze_pulse">analyze_pulse</a></code></li>
<li><code><a title="thunderfish.eodanalysis.adjust_eodf" href="#thunderfish.eodanalysis.adjust_eodf">adjust_eodf</a></code></li>
<li><code><a title="thunderfish.eodanalysis.load_species_waveforms" href="#thunderfish.eodanalysis.load_species_waveforms">load_species_waveforms</a></code></li>
<li><code><a title="thunderfish.eodanalysis.wave_similarity" href="#thunderfish.eodanalysis.wave_similarity">wave_similarity</a></code></li>
<li><code><a title="thunderfish.eodanalysis.pulse_similarity" href="#thunderfish.eodanalysis.pulse_similarity">pulse_similarity</a></code></li>
<li><code><a title="thunderfish.eodanalysis.clipped_fraction" href="#thunderfish.eodanalysis.clipped_fraction">clipped_fraction</a></code></li>
<li><code><a title="thunderfish.eodanalysis.wave_quality" href="#thunderfish.eodanalysis.wave_quality">wave_quality</a></code></li>
<li><code><a title="thunderfish.eodanalysis.pulse_quality" href="#thunderfish.eodanalysis.pulse_quality">pulse_quality</a></code></li>
<li><code><a title="thunderfish.eodanalysis.plot_eod_recording" href="#thunderfish.eodanalysis.plot_eod_recording">plot_eod_recording</a></code></li>
<li><code><a title="thunderfish.eodanalysis.plot_pulse_eods" href="#thunderfish.eodanalysis.plot_pulse_eods">plot_pulse_eods</a></code></li>
<li><code><a title="thunderfish.eodanalysis.plot_eod_snippets" href="#thunderfish.eodanalysis.plot_eod_snippets">plot_eod_snippets</a></code></li>
<li><code><a title="thunderfish.eodanalysis.plot_eod_waveform" href="#thunderfish.eodanalysis.plot_eod_waveform">plot_eod_waveform</a></code></li>
<li><code><a title="thunderfish.eodanalysis.plot_wave_spectrum" href="#thunderfish.eodanalysis.plot_wave_spectrum">plot_wave_spectrum</a></code></li>
<li><code><a title="thunderfish.eodanalysis.plot_pulse_spectrum" href="#thunderfish.eodanalysis.plot_pulse_spectrum">plot_pulse_spectrum</a></code></li>
<li><code><a title="thunderfish.eodanalysis.save_eod_waveform" href="#thunderfish.eodanalysis.save_eod_waveform">save_eod_waveform</a></code></li>
<li><code><a title="thunderfish.eodanalysis.load_eod_waveform" href="#thunderfish.eodanalysis.load_eod_waveform">load_eod_waveform</a></code></li>
<li><code><a title="thunderfish.eodanalysis.save_wave_eodfs" href="#thunderfish.eodanalysis.save_wave_eodfs">save_wave_eodfs</a></code></li>
<li><code><a title="thunderfish.eodanalysis.load_wave_eodfs" href="#thunderfish.eodanalysis.load_wave_eodfs">load_wave_eodfs</a></code></li>
<li><code><a title="thunderfish.eodanalysis.save_wave_fish" href="#thunderfish.eodanalysis.save_wave_fish">save_wave_fish</a></code></li>
<li><code><a title="thunderfish.eodanalysis.load_wave_fish" href="#thunderfish.eodanalysis.load_wave_fish">load_wave_fish</a></code></li>
<li><code><a title="thunderfish.eodanalysis.save_pulse_fish" href="#thunderfish.eodanalysis.save_pulse_fish">save_pulse_fish</a></code></li>
<li><code><a title="thunderfish.eodanalysis.load_pulse_fish" href="#thunderfish.eodanalysis.load_pulse_fish">load_pulse_fish</a></code></li>
<li><code><a title="thunderfish.eodanalysis.save_wave_spectrum" href="#thunderfish.eodanalysis.save_wave_spectrum">save_wave_spectrum</a></code></li>
<li><code><a title="thunderfish.eodanalysis.load_wave_spectrum" href="#thunderfish.eodanalysis.load_wave_spectrum">load_wave_spectrum</a></code></li>
<li><code><a title="thunderfish.eodanalysis.save_pulse_spectrum" href="#thunderfish.eodanalysis.save_pulse_spectrum">save_pulse_spectrum</a></code></li>
<li><code><a title="thunderfish.eodanalysis.load_pulse_spectrum" href="#thunderfish.eodanalysis.load_pulse_spectrum">load_pulse_spectrum</a></code></li>
<li><code><a title="thunderfish.eodanalysis.save_pulse_peaks" href="#thunderfish.eodanalysis.save_pulse_peaks">save_pulse_peaks</a></code></li>
<li><code><a title="thunderfish.eodanalysis.load_pulse_peaks" href="#thunderfish.eodanalysis.load_pulse_peaks">load_pulse_peaks</a></code></li>
<li><code><a title="thunderfish.eodanalysis.save_pulse_times" href="#thunderfish.eodanalysis.save_pulse_times">save_pulse_times</a></code></li>
<li><code><a title="thunderfish.eodanalysis.load_pulse_times" href="#thunderfish.eodanalysis.load_pulse_times">load_pulse_times</a></code></li>
<li><code><a title="thunderfish.eodanalysis.parse_filename" href="#thunderfish.eodanalysis.parse_filename">parse_filename</a></code></li>
<li><code><a title="thunderfish.eodanalysis.save_analysis" href="#thunderfish.eodanalysis.save_analysis">save_analysis</a></code></li>
<li><code><a title="thunderfish.eodanalysis.load_analysis" href="#thunderfish.eodanalysis.load_analysis">load_analysis</a></code></li>
<li><code><a title="thunderfish.eodanalysis.load_recording" href="#thunderfish.eodanalysis.load_recording">load_recording</a></code></li>
<li><code><a title="thunderfish.eodanalysis.add_eod_analysis_config" href="#thunderfish.eodanalysis.add_eod_analysis_config">add_eod_analysis_config</a></code></li>
<li><code><a title="thunderfish.eodanalysis.eod_waveform_args" href="#thunderfish.eodanalysis.eod_waveform_args">eod_waveform_args</a></code></li>
<li><code><a title="thunderfish.eodanalysis.analyze_wave_args" href="#thunderfish.eodanalysis.analyze_wave_args">analyze_wave_args</a></code></li>
<li><code><a title="thunderfish.eodanalysis.analyze_pulse_args" href="#thunderfish.eodanalysis.analyze_pulse_args">analyze_pulse_args</a></code></li>
<li><code><a title="thunderfish.eodanalysis.add_species_config" href="#thunderfish.eodanalysis.add_species_config">add_species_config</a></code></li>
<li><code><a title="thunderfish.eodanalysis.add_eod_quality_config" href="#thunderfish.eodanalysis.add_eod_quality_config">add_eod_quality_config</a></code></li>
<li><code><a title="thunderfish.eodanalysis.wave_quality_args" href="#thunderfish.eodanalysis.wave_quality_args">wave_quality_args</a></code></li>
<li><code><a title="thunderfish.eodanalysis.pulse_quality_args" href="#thunderfish.eodanalysis.pulse_quality_args">pulse_quality_args</a></code></li>
<li><code><a title="thunderfish.eodanalysis.main" href="#thunderfish.eodanalysis.main">main</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
